<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Modelo Financiero Interactivo - Conductores del Mundo</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
<!-- Lucide Icons for a professional touch -->
<script src="https://unpkg.com/lucide@latest"></script>

<script>
window.addEventListener("error", (e) => {
  alert("JS Error: " + e.message + " at " + (e.filename || 'file') + ":" + (e.lineno || '?'));
});
console.log("✅ JS Diagnostics Enabled");

if (typeof Chart !== 'undefined') {
    Chart.defaults.font.family = 'Inter, sans-serif';
    Chart.defaults.font.size = 12;
    Chart.defaults.color = '#cbd5e1';
    Chart.defaults.borderColor = 'rgba(148, 163, 184, 0.15)';
    Chart.defaults.elements.arc.borderWidth = 0;
    Chart.defaults.plugins.legend.labels.color = '#cbd5e1';
    Chart.defaults.plugins.legend.labels.font = { family: 'Inter, sans-serif', size: 12 };
    Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(15, 23, 42, 0.92)';
    Chart.defaults.plugins.tooltip.titleColor = '#f8fafc';
    Chart.defaults.plugins.tooltip.bodyColor = '#e2e8f0';
    Chart.defaults.scale.grid.color = 'rgba(148, 163, 184, 0.12)';
    Chart.defaults.scale.ticks.color = '#94a3b8';
    Chart.defaults.scale.ticks.font = { family: 'Inter, sans-serif' };
    Chart.defaults.devicePixelRatio = Math.min((window.devicePixelRatio || 1) * 1.4, 3);
}
</script>

<style>
/* Base Styles - Inspired by the Pitch Deck (Dark Theme) */
body {
font-family: 'Inter', sans-serif;
background-color: #020617; /* slate-950 from Tailwind for dark background */
color: #e2e8f0; /* slate-200 for main text */
overflow-x: hidden; /* Prevent horizontal scroll */
}
h1, h2, h3, h4 {
color: #f8fafc; /* slate-50 for titles */
font-weight: 700; /* Bold */
}
/* Gradient text highlight */
.highlight-text {
background: -webkit-linear-gradient(45deg, #22d3ee, #0ea5e9); /* cyan-400 to sky-500 */
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
}
/* Tabs Navigation */
.tab-button {
transition: all 0.3s ease;
cursor: pointer;
padding: 1rem 1.5rem;
border-bottom: 2px solid transparent;
color: #94a3b8; /* slate-400 */
font-weight: 500;
margin-right: 0.5rem;
border-radius: 0.5rem 0.5rem 0 0;
display: inline-flex; /* Allows icons aligned with text */
align-items: center;
gap: 0.5rem; /* Space between icon and text */
}
.tab-button.active {
border-color: #0ea5e9; /* sky-500 */
color: #f8fafc; /* slate-50 */
background-color: #0f172a; /* slate-900 */
font-weight: 600;
}
.tab-button:hover:not(.active) {
color: #cbd5e1; /* slate-300 */
background-color: #0f172a; /* slate-900 */
}
.scenario-selector {
display: flex;
flex-direction: column;
align-items: center;
gap: 0.75rem;
}
.scenario-selector h3 {
margin: 0;
font-weight: 600;
letter-spacing: 0.04em;
text-transform: uppercase;
color: #94a3b8;
}
.scenario-grid {
display: flex;
flex-wrap: wrap;
justify-content: center;
gap: 0.75rem;
}
.scenario-btn {
min-width: 140px;
border-radius: 0.75rem;
border: 1px solid #1e293b;
background: #1a233b;
color: #cbd5e1;
transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
text-align: center;
padding: 0.75rem 1rem;
font-weight: 500;
line-height: 1.35;
}
.scenario-btn strong {
display: block;
font-size: 0.95rem;
margin-bottom: 0.25rem;
}
.scenario-btn small {
display: block;
font-size: 0.7rem;
letter-spacing: 0.02em;
color: #94a3b8;
}
.scenario-btn:hover {
border-color: #38bdf8;
box-shadow: 0 10px 25px -15px rgba(56, 189, 248, 0.8);
transform: translateY(-2px);
}
.scenario-btn.active {
background: linear-gradient(135deg, #0f766e, #14b8a6);
border-color: #0f766e;
color: #f8fafc;
box-shadow: 0 18px 35px -15px rgba(20, 184, 166, 0.8);
}
.scenario-btn.active small {
color: rgba(248, 250, 252, 0.85);
}
/* Section content */
.content-section { display: none; }
.content-section.active { display: block; }
/* Card Style */
.card {
background-color: #0f172a; /* slate-900 for card interior */
border-radius: 0.75rem; /* rounded-xl */
box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
padding: 1.5rem;
margin-bottom: 1.5rem;
border: 1px solid #1e293b; /* slate-800 for subtle borders */
}
#content-graficos .card {
background: linear-gradient(150deg, rgba(10, 17, 28, 0.96) 0%, rgba(19, 27, 44, 0.88) 100%);
border: 1px solid rgba(148, 163, 184, 0.16);
box-shadow: 0 28px 45px -30px rgba(59, 130, 246, 0.45);
backdrop-filter: blur(6px);
}
#content-graficos canvas {
display: block;
width: 100% !important;
height: 100% !important;
image-rendering: -webkit-optimize-contrast;
image-rendering: crisp-edges;
filter: none;
}
/* Sliders */
.input-slider {
-webkit-appearance: none;
width: 100%;
height: 8px;
background: #1e293b; /* slate-800 */
border-radius: 9999px;
outline: none;
transition: background 0.2s ease-in-out;
}
.input-slider::-webkit-slider-thumb {
-webkit-appearance: none;
width: 20px;
height: 20px;
background: #0ea5e9; /* sky-500 */
border-radius: 9999px;
cursor: pointer;
box-shadow: 0 0 0 4px rgba(14, 165, 233, 0.3); /* Ring when dragging */
transition: background 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}
.input-slider:hover::-webkit-slider-thumb {
background: #38bdf8; /* sky-400 */
}
/* Financial Tables */
.financial-table {
width: 100%;
border-collapse: collapse;
background-color: #0f172a; /* slate-900 */
border-radius: 0.75rem; /* rounded-xl */
overflow: hidden; /* So that rounded borders apply to thead/tbody */
}
.financial-table th, .financial-table td {
padding: 1rem; /* More padding for readability */
text-align: right;
border-bottom: 1px solid #1e293b; /* slate-800 */
font-size: 0.95rem;
}
.financial-table td {
color: #cbd5e1; /* slate-300 */
}
.financial-table th {
background-color: #1a233b; /* A slightly lighter shade than the table background */
font-weight: 600;
color: #94a3b8; /* slate-400 */
text-transform: uppercase;
letter-spacing: 0.05em;
}
.financial-table td:first-child, .financial-table th:first-child {
text-align: left;
color: #e2e8f0; /* slate-200 */
}
.financial-table tr:last-child td {
border-bottom: none; /* Remove bottom border from last row */
}
.financial-table tr.bg-gray-50 { /* Style for total/subtotal rows */
background-color: #1e293b; /* slate-800 */
color: #f8fafc; /* slate-50 */
font-weight: 700;
}
.positive { color: #34d399; /* emerald-400 */ }
.negative { color: #f43f5e; /* rose-500 */ }
/* Key Metrics Indicators */
	.metric-card {
	background: linear-gradient(140deg, rgba(15, 23, 42, 0.96) 0%, rgba(30, 41, 59, 0.88) 100%);
	border: 1px solid rgba(148, 163, 184, 0.12);
	padding: 1.25rem;
	border-radius: 1rem;
	box-shadow: 0 28px 45px -36px rgba(59, 130, 246, 0.6);
	display: flex;
	flex-direction: column;
	justify-content: space-between;
	gap: 0.35rem;
	backdrop-filter: blur(8px);
	}
	.metric-card .text-sm {
	color: #cbd5e1;
	font-weight: 600;
	letter-spacing: 0.02em;
	margin-bottom: 0.15rem;
	}
.metric-card .text-2xl {
color: #f8fafc; /* slate-50 */
font-weight: 800; /* Extra bold */
}
.worst-cash-card {
border: 1px solid rgba(248, 250, 252, 0.05);
transition: border-color 0.3s ease, background 0.3s ease;
}
.worst-cash-card.negative {
background: linear-gradient(150deg, rgba(127, 29, 29, 0.85) 0%, rgba(185, 28, 28, 0.75) 100%);
border-color: rgba(248, 113, 113, 0.6);
box-shadow: 0 28px 45px -36px rgba(248, 113, 113, 0.55);
}
.worst-cash-card.positive {
background: linear-gradient(150deg, rgba(6, 78, 59, 0.85) 0%, rgba(5, 150, 105, 0.75) 100%);
border-color: rgba(34, 197, 94, 0.45);
box-shadow: 0 28px 45px -36px rgba(34, 197, 94, 0.55);
}
.metric-row-title {
font-size: 0.875rem; /* text-sm */
font-weight: 600; /* font-semibold */
color: #64748b; /* slate-500 */
text-transform: uppercase;
letter-spacing: 0.05em;
margin-bottom: 0.75rem; /* mb-3 */
padding-left: 0.25rem;
}
/* Debug Panel */
.debug-info {
background: #1e293b; /* slate-800 */
color: #f8fafc; /* slate-50 */
border: 1px solid #334155; /* slate-700 */
border-radius: 0.5rem;
box-shadow: 0 4px 12px rgba(0,0,0,0.5);
}
.debug-info button {
background-color: #ef4444; /* red-500 */
color: white;
padding: 0.3rem 0.75rem;
border-radius: 0.375rem;
font-size: 0.75rem;
transition: background-color 0.2s ease;
}
.debug-info button:hover {
background-color: #dc2626; /* red-600 */
}
/* IFRS Compliant Cards */
.niif-compliant {
border-left: 4px solid #10b981; /* emerald-500 */
background-color: #0f172a; /* slate-900 */
}
/* Validation Panel */
#validation-panel-content {
background-color: #0f172a; /* slate-900 */
border: 1px solid #1e293b; /* slate-800 */
border-radius: 0.75rem;
box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
}
.validation-item {
border-left: 4px solid;
padding: 0.75rem;
border-radius: 0.5rem;
margin-bottom: 0.5rem;
}
.validation-item.error { background-color: #450a0a; border-color: #dc2626; color: #fecaca; } /* red-950 / red-600 */
.validation-item.warning { background-color: #422006; border-color: #f59e0b; color: #fffbeb; } /* amber-950 / amber-500 */
.validation-item.info { background-color: #075985; border-color: #3b82f6; color: #e0f2fe; } /* sky-950 / blue-500 */
.validation-item.passed { background-color: #064e3b; border-color: #10b981; color: #d1fae5; } /* emerald-950 / green-500 */

.validation-message { color: #cbd5e1; /* slate-300 */ }
.validation-message strong { color: #f8fafc; }
.validation-summary {
background-color: #1a233b; /* slate-800 */
color: #f8fafc;
border: 1px solid #334155;
}
.validation-summary.bg-red-200 { background-color: #450a0a; border-color: #dc2626; color: #fecaca; }
.validation-summary.bg-yellow-200 { background-color: #422006; border-color: #f59e0b; color: #fffbeb; }
.validation-summary.bg-green-200 { background-color: #064e3b; border-color: #10b981; color: #d1fae5; }
/* Tooltips - Maintain visibility and readability */
[data-tooltip] {
position: relative;
cursor: help;
}
[data-tooltip]:before, [data-tooltip]:after {
position: absolute;
visibility: hidden;
opacity: 0;
transition: opacity 0.2s ease-in-out;
pointer-events: none;
background-color: #1e293b; /* slate-800 */
color: #f8fafc;
border: 1px solid #334155; /* slate-700 */
border-radius: 0.5rem;
font-size: 0.8rem;
line-height: 1.4;
padding: 0.75rem;
width: 280px;
z-index: 100;
}
[data-tooltip]:before {
content: attr(data-tooltip);
bottom: 125%;
left: 50%;
transform: translateX(-50%);
}
[data-tooltip]:after {
content: '';
bottom: 125%;
left: 50%;
margin-left: -5px;
border-width: 5px;
border-style: solid;
border-color: #1e293b transparent transparent transparent;
transform: translateY(100% + 5px) translateX(-50%);
}
[data-tooltip]:hover:before, [data-tooltip]:hover:after {
visibility: visible;
opacity: 1;
}
.metric-explain-btn {
display: inline-flex;
align-items: center;
justify-content: center;
width: 28px;
height: 28px;
border-radius: 9999px;
border: 1px solid rgba(56, 189, 248, 0.45);
background: rgba(14, 165, 233, 0.12);
color: #bae6fd;
transition: all 0.2s ease;
}
.metric-explain-btn:hover {
background: rgba(56, 189, 248, 0.24);
border-color: rgba(125, 211, 252, 0.6);
color: #e0f2fe;
}
.metric-explain-btn:focus-visible {
outline: 2px solid rgba(125, 211, 252, 0.65);
outline-offset: 2px;
}
.metric-popover {
position: fixed;
max-width: 280px;
background-color: rgba(15, 23, 42, 0.98);
border: 1px solid rgba(148, 163, 184, 0.22);
color: #e2e8f0;
border-radius: 0.75rem;
padding: 1rem;
font-size: 0.75rem;
line-height: 1.5;
box-shadow: 0 20px 45px -20px rgba(15, 23, 42, 0.6);
z-index: 2000;
display: none;
}
.metric-popover.visible {
display: block;
}
.metric-popover strong {
color: #38bdf8;
font-weight: 600;
}
.metric-popover hr {
border-color: rgba(148, 163, 184, 0.2);
margin: 0.75rem 0;
}
/* Validation States */
.validation-error {
border-color: #dc2626 !important; /* red-600 */
box-shadow: 0 0 0 2px rgba(220, 38, 38, 0.2);
}
.validation-warning {
border-color: #f59e0b !important; /* amber-500 */
box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2);
}
.validation-success {
border-color: #10b981 !important; /* emerald-500 */
box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
}

/* Inputs and Selects */
input[type="number"], input[type="range"] {
background-color: #1a233b; /* slate-800 */
border-color: #334155; /* slate-700 */
color: #e2e8f0; /* slate-200 */
border-radius: 0.375rem; /* rounded-md */
}
input[type="number"]:focus, input[type="range"]::-webkit-slider-thumb:focus {
border-color: #0ea5e9; /* sky-500 */
box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.5); /* Focus ring */
background-color: #1a233b; /* Ensure background doesn't change on focus */
}
label {
color: #cbd5e1; /* slate-300 */
}
/* Styles for slider value text */
span[id$="-valor"] {
color: #81e6d9; /* a green/cyan tone for values */
}
/* NEW: Compact Chart Styles */
.compact-chart {
padding: 1rem;
}
.compact-chart h4 {
font-size: 0.875rem;
margin-bottom: 0.5rem;
line-height: 1.2;
}
/* NEW: Horizontal Control Styles */
.control-grid {
display: flex;
flex-direction: column;
gap: 0.75rem;
}
.control-grid label {
text-align: left;
white-space: normal;
line-height: 1.35;
}
.control-grid .slider-container {
display: flex;
align-items: center;
gap: 0.75rem;
width: 100%;
}
.control-grid .slider-container .input-slider {
flex: 1 1 auto;
min-width: 0;
}
.numeric-display {
flex: 0 0 auto;
min-width: 5.5rem;
text-align: right;
font-variant-numeric: tabular-nums;
font-feature-settings: 'tnum';
}
.numeric-input {
font-variant-numeric: tabular-nums;
font-feature-settings: 'tnum';
text-align: right;
}
.units-grid {
display: grid;
grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
gap: 1rem;
}

/* NEW: Financing Matrix Styles */
#financing-matrix-table {
width: 100%;
border-collapse: collapse;
margin-top: 1rem;
}
#financing-matrix-table th, #financing-matrix-table td {
text-align: center;
padding: 0.5rem;
border: 1px solid #1e293b;
}
#financing-matrix-table th {
font-size: 0.8rem;
font-weight: 600;
}
#financing-matrix-table td:first-child {
text-align: left;
font-weight: 500;
}
#financing-matrix-table input[type="number"] {
width: 100%;
padding: 0.25rem;
font-size: 0.85rem;
text-align: right;
-moz-appearance: textfield;
}
#financing-matrix-table input[type="number"]::-webkit-outer-spin-button,
#financing-matrix-table input[type="number"]::-webkit-inner-spin-button {
-webkit-appearance: none;
margin: 0;
}
#scenario-comparison-table table {
width: 100%;
border-collapse: collapse;
}
#scenario-comparison-table th,
#scenario-comparison-table td {
padding: 0.75rem 1rem;
border-bottom: 1px solid #1e293b;
text-align: right;
font-size: 0.85rem;
}
#scenario-comparison-table th:first-child,
#scenario-comparison-table td:first-child {
text-align: left;
}
#scenario-comparison-table th {
font-weight: 600;
color: #e2e8f0;
}
#scenario-comparison-table tr:nth-child(even) {
background-color: rgba(15, 23, 42, 0.35);
}
#scenario-comparison-table tr:hover {
background-color: rgba(14, 165, 233, 0.08);
}
#scenario-comparison-table .active-scenario {
color: #22d3ee;
}
#audit-change-log {
list-style: none;
margin: 0;
padding: 0;
}
#audit-change-log li {
display: flex;
align-items: flex-start;
gap: 0.75rem;
padding: 0.5rem 0;
border-bottom: 1px solid #1e293b;
}
#audit-change-log li:last-child {
border-bottom: none;
}
#audit-change-log .log-badge {
font-size: 0.65rem;
text-transform: uppercase;
padding: 2px 6px;
border-radius: 9999px;
font-weight: 600;
letter-spacing: 0.04em;
}
#audit-change-log .log-badge.log-escenario {
background: rgba(16, 185, 129, 0.2);
color: #34d399;
}
#audit-change-log .log-badge.log-export {
background: rgba(59, 130, 246, 0.2);
color: #60a5fa;
}
#capital-snapshot > div {
background: rgba(15, 23, 42, 0.85);
border: 1px solid #1e293b;
color: #e2e8f0;
backdrop-filter: blur(8px);
}
#capital-snapshot > div .text-xs {
color: #94a3b8;
}
#capital-snapshot > div strong {
color: #f8fafc;
}
#capital-draw-summary table {
width: 100%;
border-collapse: collapse;
}
#capital-draw-summary thead {
background: rgba(15, 23, 42, 0.9);
}
#capital-draw-summary thead th {
padding: 0.65rem;
font-size: 0.75rem;
text-transform: uppercase;
letter-spacing: 0.08em;
color: #94a3b8;
border-bottom: 1px solid #1f2937;
}
#capital-draw-summary tbody td {
padding: 0.6rem 0.65rem;
font-size: 0.8rem;
border-bottom: 1px solid rgba(30, 41, 59, 0.6);
color: #cbd5e1;
text-align: right;
}
#capital-draw-summary tbody td:first-child {
text-align: left;
color: #f8fafc;
font-weight: 600;
}
#capital-draw-summary tbody tr:last-child td {
border-bottom: none;
}
.additional-value {
    font-weight: 500;
    padding: 0.25rem;
    border-radius: 0.25rem;
    color: #fcd34d; /* amber-300 */
}
.total-value {
    font-weight: 700;
    padding: 0.25rem;
    border-radius: 0.25rem;
    background-color: rgba(14, 165, 233, 0.1);
    color: #7dd3fc; /* sky-300 */
}
.instrument-header {
    background-color: #1a233b;
    color: #f8fafc;
    font-weight: 600;
    text-align: left;
    padding-left: 1rem;
}


/* Dynamic Validation Styles */
.validation-error {
border-color: #ef4444 !important;
box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2) !important;
}
.validation-warning {
border-color: #f59e0b !important;
box-shadow: 0 0 0 2px rgba(245, 158, 11, 0.2) !important;
}
.validation-success {
border-color: #10b981 !important;
box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2) !important;
}
@media (max-width: 1024px) {
.compact-chart {
min-height: 280px;
}
}
</style>
</head>
<body class="text-gray-800">

<!-- Debug Panel -->
<div id="debug-info" class="debug-info" style="display:none; position: fixed; top: 10px; right: 10px; z-index: 1000; padding: 10px; max-height: 400px; overflow-y: auto;">
<div id="debug-content"></div>
<button onclick="toggleDebug()" class="bg-red-500 text-white px-2 py-1 rounded mt-2 text-xs">Cerrar</button>
</div>

<div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
<!-- Header and Key Metrics -->
<header class="mb-8 text-center bg-transparent rounded-xl p-6 space-y-4">
<h1 class="text-4xl lg:text-5xl font-black text-white leading-tight tracking-tighter">Modelo Financiero - <span class="highlight-text">Conductores</span></h1>
<p class="text-xl text-slate-400">NIIF-Compliant | Series A Due Diligence</p>
<p class="text-sm text-amber-400">⚠️ Modelo en desarrollo - Validación continua</p>
<button onclick="toggleDebug()" class="bg-sky-600 hover:bg-sky-500 text-white px-4 py-2 rounded-lg font-medium transition duration-300 inline-flex items-center gap-2">
<i data-lucide="bug" class="w-5 h-5"></i> Debug
</button>
<button id="toggle-data-room" class="bg-emerald-600 hover:bg-emerald-500 text-white px-4 py-2 rounded-lg font-medium transition duration-300 inline-flex items-center gap-2">
<i data-lucide="file-text" class="w-5 h-5"></i> Modo Data Room
</button>

<!-- NEW SCENARIO SELECTOR -->
<div class="scenario-selector mt-4">
  <h3 class="text-center text-slate-400 text-sm font-medium">📊 Escenarios de Crecimiento</h3>
  <div class="scenario-grid">
    <button id="scenario-pesimista" class="scenario-btn">
      📉 <strong>Pesimista</strong><br><small>250 unidades</small>
    </button>
    <button id="scenario-base" class="scenario-btn active">
      📊 <strong>Base</strong><br><small>500 unidades</small>
    </button>
    <button id="scenario-optimista" class="scenario-btn">
      📈 <strong>Optimista</strong><br><small>750 unidades</small>
    </button>
    <button id="scenario-stress" class="scenario-btn">
      ⚠️ <strong>Stress</strong><br><small>1,000 unidades</small>
    </button>
  </div>
</div>
</header>

<!-- User Guide Panel -->
<section id="model-user-guide" class="mb-10">
    <div class="bg-slate-900/80 border border-slate-800 rounded-2xl p-6 lg:p-8 shadow-lg shadow-slate-900/30">
        <div class="flex flex-col gap-6">
            <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
                <div>
                    <h2 class="text-2xl font-semibold text-white flex items-center gap-2">
                        <i data-lucide="map" class="w-6 h-6 text-sky-400"></i>
                        Cómo leer este modelo
                    </h2>
                    <p class="text-sm text-slate-400 max-w-3xl">
                        Sigue estos cuatro pasos cada vez que abras el modelo. Todo el flujo de trabajo está guiado y no necesitas revisar código para validar resultados.
                    </p>
                </div>
                <div class="flex items-center gap-3 text-xs text-slate-400">
                    <span class="inline-flex items-center gap-1 text-emerald-300"><i data-lucide="sparkle" class="w-4 h-4"></i>UX pensado para analistas</span>
                    <span class="inline-flex items-center gap-1 text-sky-300"><i data-lucide="book-open" class="w-4 h-4"></i>Documentado en pantalla</span>
                </div>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4">
                <article class="p-4 bg-slate-800/70 border border-slate-700 rounded-xl h-full">
                    <header class="flex items-center gap-2 mb-2">
                        <span class="text-xs font-semibold px-2 py-1 rounded bg-slate-700 text-slate-200">Paso 1</span>
                        <h3 class="text-sm font-semibold text-white">Selecciona escenario y revisa el tablero</h3>
                    </header>
                    <p class="text-sm text-slate-400 leading-relaxed">
                        Elige un escenario (Pesimista/Base/Optimista/Stress) y valida las métricas superiores: EBITDA, TIR, DSCR y cash flow. Todas tienen íconos de ayuda que explican la fórmula.
                    </p>
                </article>
                <article class="p-4 bg-slate-800/70 border border-slate-700 rounded-xl h-full">
                    <header class="flex items-center gap-2 mb-2">
                        <span class="text-xs font-semibold px-2 py-1 rounded bg-slate-700 text-slate-200">Paso 2</span>
                        <h3 class="text-sm font-semibold text-white">Ajusta supuestos con los controles guiados</h3>
                    </header>
                    <p class="text-sm text-slate-400 leading-relaxed">
                        Navega cada sección del tab Control. Cada slider o campo tiene un tooltip que describe el impacto financiero. Modifica tasas, líneas y crecimiento sin tocar fórmulas.
                    </p>
                </article>
                <article class="p-4 bg-slate-800/70 border border-slate-700 rounded-xl h-full">
                    <header class="flex items-center gap-2 mb-2">
                        <span class="text-xs font-semibold px-2 py-1 rounded bg-slate-700 text-slate-200">Paso 3</span>
                        <h3 class="text-sm font-semibold text-white">Revisa alertas y checklist NIIF</h3>
                    </header>
                    <p class="text-sm text-slate-400 leading-relaxed">
                        El monitor financiero y el tab Auditoría muestran si hay brechas de capital, DSCR crítico o ajustes contables pendientes. Todo se colorea automáticamente.
                    </p>
                </article>
                <article class="p-4 bg-slate-800/70 border border-slate-700 rounded-xl h-full">
                    <header class="flex items-center gap-2 mb-2">
                        <span class="text-xs font-semibold px-2 py-1 rounded bg-slate-700 text-slate-200">Paso 4</span>
                        <h3 class="text-sm font-semibold text-white">Exporta y comparte</h3>
                    </header>
                    <p class="text-sm text-slate-400 leading-relaxed">
                        Al terminar, descarga los supuestos y resultados desde la sección Auditoría. Tendrás todo listo para due diligence o para documentar cambios sin abrir Excel.
                    </p>
                </article>
            </div>
        </div>
    </div>
</section>

<!-- Scenario Comparison Panel -->
<section id="scenario-comparison-panel" class="mb-10">
    <div class="bg-slate-900/80 border border-slate-800 rounded-2xl p-6 lg:p-8 shadow-lg shadow-slate-900/30">
        <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4 mb-4">
            <div>
                <h2 class="text-2xl font-semibold text-white flex items-center gap-2">
                    <i data-lucide="table" class="w-6 h-6 text-emerald-300"></i>
                    Comparador de escenarios
                </h2>
                <p class="text-sm text-slate-400 max-w-3xl">
                    Recalcula cualquiera de los presets (o tu escenario personalizado) y el modelo guardará la foto clave: TIR, DSCR, cobertura, equity y deuda desplegada. Aquí puedes contrastarlos sin tomar capturas.
                </p>
            </div>
            <span class="inline-flex items-center gap-1 text-xs px-3 py-1 rounded-full bg-slate-800 text-slate-300">
                <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                Actualiza al recalcular
            </span>
        </div>
        <div id="scenario-comparison-table" class="overflow-x-auto text-sm text-slate-200"></div>
    </div>
</section>

<!-- Quick Sanity Panel -->
<section id="sanity-overview" class="mb-8">
    <div class="bg-slate-900/80 border border-slate-800 rounded-2xl p-6 lg:p-7 shadow-lg shadow-slate-900/30">
        <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4 mb-4">
            <div>
                <h2 class="text-xl font-semibold text-white flex items-center gap-2">
                    <i data-lucide="activity" class="w-5 h-5 text-teal-300"></i>
                    Chequeo rápido
                </h2>
                <p class="text-sm text-slate-400">KPIs esenciales después de cada recálculo para validar que el escenario siga dentro de guardrails.</p>
            </div>
            <button id="reset-base-btn" class="inline-flex items-center gap-2 px-3 py-2 text-xs font-semibold rounded-lg bg-slate-800 border border-slate-700 text-slate-200 hover:bg-slate-700 transition">
                <i data-lucide="history" class="w-4 h-4"></i>
                Reset a Base
            </button>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 text-sm text-slate-200">
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Margen core</div>
                <div class="text-lg font-semibold" id="sanity-core-margin">$0 (0.0%)</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Cobertura CAPEX</div>
                <div class="text-lg font-semibold" id="sanity-coverage">0.0%</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">DSCR final</div>
                <div class="text-lg font-semibold" id="sanity-dscr">0.0x</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">TIR equity</div>
                <div class="text-lg font-semibold" id="sanity-tir">0.0%</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Cash After Financing Y5</div>
                <div class="text-lg font-semibold" id="sanity-caf">$0</div>
            </div>
        </div>
    </div>
</section>

<!-- Data Room Overlay -->
<div id="data-room-overlay" class="hidden fixed inset-0 z-50 backdrop-blur-xl bg-slate-950/85 px-4 py-8 overflow-y-auto">
    <div class="max-w-5xl mx-auto bg-slate-900/90 border border-slate-800 rounded-2xl p-6 lg:p-8 shadow-xl shadow-black/40 space-y-6">
        <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
            <div>
                <h2 class="text-2xl font-semibold text-white flex items-center gap-2">
                    <i data-lucide="shield-check" class="w-6 h-6 text-emerald-300"></i>
                    Snapshot Data Room
                </h2>
                <p class="text-sm text-slate-400">Vista de sólo lectura para compartir con fondos o bancos. Resume retornos, cobertura y liquidez del escenario activo.</p>
            </div>
            <button id="close-data-room" class="inline-flex items-center gap-2 px-4 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 text-slate-200 text-xs font-semibold">
                <i data-lucide="x" class="w-4 h-4"></i>
                Salir de Data Room
            </button>
        </div>
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 text-sm text-slate-200">
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Escenario</div>
                <div class="text-lg font-semibold" id="data-room-scenario">Base (500u)</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">TIR equity</div>
                <div class="text-lg font-semibold" id="data-room-tir">0.0%</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">DSCR final</div>
                <div class="text-lg font-semibold" id="data-room-dscr">0.0x</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Cobertura CAPEX</div>
                <div class="text-lg font-semibold" id="data-room-coverage">0.0%</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Cash After Financing Y5</div>
                <div class="text-lg font-semibold" id="data-room-caf">$0</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Margen core</div>
                <div class="text-lg font-semibold" id="data-room-margin">$0 (0.0%)</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Equity desplegado</div>
                <div class="text-lg font-semibold" id="data-room-equity">$0</div>
            </div>
            <div class="p-3 rounded-lg bg-slate-800/60 border border-slate-700">
                <div class="text-xs uppercase tracking-wide text-slate-400">Deuda desplegada</div>
                <div class="text-lg font-semibold" id="data-room-debt">$0</div>
            </div>
        </div>
        <div>
            <h3 class="text-sm font-semibold text-slate-300 mb-2 flex items-center gap-2"><i data-lucide="layers" class="w-4 h-4 text-sky-300"></i>Comparación rápida</h3>
            <div id="data-room-comparison" class="overflow-x-auto text-xs text-slate-200 bg-slate-800/40 border border-slate-700 rounded-lg"></div>
        </div>
        <p class="text-xs text-slate-400">⚠️ NIIF 9 utiliza PD estáticas por tramo (limitación conocida); ajusta manualmente para stress tests.</p>
    </div>
</div>

<!-- =================================================================== -->
<!-- ===== NEW INVESTOR-FOCUSED METRICS DASHBOARD ====================== -->
<!-- =================================================================== -->
<div class="space-y-8 mb-8">
<!-- Fila 1: Retorno y Escala (El "Hook") -->
<div>
<h3 class="metric-row-title">Retorno y Escala</h3>
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6">
<div class="metric-card" data-tooltip="Indicador clave de la rentabilidad operativa del negocio al final del periodo de proyección.">
<div class="text-sm">EBITDA Año 5</div>
<div class="text-2xl font-bold" id="ebitda-year5">$0M</div>
<div class="text-xs text-emerald-400">Rentabilidad Operativa</div>
</div>
<div class="metric-card growth-metric" data-tooltip="Flujo de caja operativo menos salidas de financiamiento (balloon). Clarifica sostenibilidad después de servicio de deuda.">
  <div class="text-sm">Cash Flow After Financing (Y5)</div>
  <div class="text-2xl font-bold" id="cash-after-financing-display">$0</div>
  <div class="text-xs text-cyan-400">Operativo - Balloon Financiero</div>
  </div>
  <div class="metric-card steady-metric" style="display:none;">
    <span class="text-sm">Normalized CFO (Y5)</span>
    <span class="text-2xl font-bold" id="normalized-cfo-y5">$0</span>
    <div class="text-xs text-slate-400">CFO + ΔCxC (steady-state)</div>
  </div>
  <div class="metric-card steady-metric" style="display:none;">
    <span class="text-sm">Normalized Cash After Financing (Y5)</span>
    <span class="text-2xl font-bold" id="normalized-cfaf-y5">$0</span>
    <div class="text-xs text-slate-400">Steady-state (sin expansión de cartera)</div>
  </div>
<div class="metric-card" data-tooltip="Calculada sobre los flujos de efectivo para el accionista (después de deuda) y un valor terminal conservador (Múltiplo P/B de 1.8x). Es el retorno real y magnificado de su inversión gracias al apalancamiento.">
<div class="flex items-center justify-between gap-2">
<div class="text-sm">TIR Equity</div>
<button type="button" class="metric-explain-btn" data-metric="tir" aria-label="Ver fórmula de la TIR Equity">
    <i data-lucide="info" class="w-4 h-4"></i>
</button>
</div>
<div class="text-2xl font-bold" id="tir-equity">0%</div>
<div class="text-xs text-sky-400">Retorno para el Inversionista</div>
</div>
<div class="metric-card" data-tooltip="Fórmula: Efectivo + Cuentas por Cobrar Netas + Activos Fijos Netos. Es el indicador estándar de la industria para medir la escala total del negocio que hemos construido.">
<div class="text-sm">Activos Totales Bajo Gestión</div>
<div class="text-2xl font-bold" id="aum-value">$0M</div>
<div class="text-xs text-purple-400">Magnitud del Negocio</div>
</div>
<div class="metric-card" data-tooltip="Número acumulado de unidades financiadas en 5 años. Mide nuestra capacidad para capturar clientes y la penetración de mercado.">
<div class="text-sm">Vagonetas Totales Financiadas</div>
<div class="text-2xl font-bold" id="total-vans-financed">0</div>
<div class="text-xs text-pink-400">Penetración de Mercado</div>
</div>
</div>
</div>
<!-- Fila 2: La Maquinaria de Crecimiento (El "Motor") -->
<div>
<h3 class="metric-row-title">La Maquinaria de Crecimiento</h3>
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6">
<div class="metric-card" data-tooltip="Capital total aportado por los socios (Serie A y futuras capitalizaciones). Es el 'costo' de la inversión para los accionistas.">
<div class="text-sm">Capital de Socios Levantado</div>
<div class="text-2xl font-bold" id="equity-raised">$0M</div>
<div class="text-xs text-blue-400">Serie A + Capital Calls</div>
</div>
<div class="metric-card" data-tooltip="Deuda total (Venture + Comercial) levantada para financiar la flota. Demuestra nuestra capacidad para apalancar el capital de socios.">
<div class="text-sm">Deuda Total Levantada</div>
<div class="text-2xl font-bold" id="total-debt-raised">$0M</div>
<div class="text-xs text-amber-400">Apalancamiento para Escalar</div>
</div>
<div class="metric-card" data-tooltip="Mide cuántos ingresos generamos por cada peso de financiamiento total (Equity + Deuda). Un ratio >0.8x indica una excelente productividad del capital.">
<div class="text-sm">Funding Efficiency</div>
<div class="text-2xl font-bold" id="funding-efficiency">0.0x</div>
<div class="text-xs text-cyan-400">Revenue / Total Funding</div>
</div>
<div class="metric-card" data-tooltip="CAPEX total dividido entre unidades totales. Un valor <$750K demuestra una excelente eficiencia en la adquisición y preparación de activos.">
<div class="text-sm">Capital Efficiency</div>
<div class="text-2xl font-bold" id="capital-per-unit">$0K</div>
<div class="text-xs text-blue-400">CAPEX por Unidad</div>
</div>
</div>
</div>
<!-- Fila 3: Resiliencia y Sostenibilidad (La "Base") -->
<div>
<h3 class="metric-row-title">Resiliencia y Sostenibilidad</h3>
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-6">
<div class="metric-card" data-tooltip="Métrica de resiliencia. No solo muestra cuántas unidades financiamos, sino cuántas mantenemos productivas gracias a nuestro ecosistema de IA (PMA). Ajustado por NIIF 5.">
<div class="text-sm">Vagonetas Operativas (Año 5)</div>
<div class="text-2xl font-bold" id="vagonetas-operativas">0</div>
<div class="text-xs text-emerald-400">Ajustado por NIIF 5</div>
</div>
<div class="metric-card" data-tooltip="Fórmula: EBITDA / Servicio de Deuda. Un ratio >1.5x es saludable y demuestra nuestra capacidad para pagar cómodamente la deuda, un requisito para futuros prestamistas.">
<div class="flex items-center justify-between gap-2">
<div class="text-sm">Debt Service Coverage</div>
<button type="button" class="metric-explain-btn" data-metric="dscr" aria-label="Ver fórmula del DSCR">
    <i data-lucide="info" class="w-4 h-4"></i>
</button>
</div>
<div class="text-2xl font-bold" id="dscr-final">0.0x</div>
<div class="text-xs text-sky-400">EBITDA / Servicio de Deuda</div>
</div>
<div class="metric-card worst-cash-card" id="worst-cash-card" data-tooltip="Saldo mínimo de caja proyectado después de equity calls automáticos. Úsalo para calendarizar fondeos o gatillar planes de contingencia.">
<div class="flex items-center justify-between gap-2">
<div class="text-sm">Worst Cash Headroom</div>
<i data-lucide="alert-triangle" class="w-4 h-4"></i>
</div>
<div class="text-2xl font-bold" id="worst-cash-amount">$0</div>
<div class="text-xs" id="worst-cash-year-label">Sin stress</div>
</div>
<div class="metric-card" data-tooltip="Margen de Interés Neto (NIM) del último año. Mide la rentabilidad de la cartera de crédito después de costos de financiamiento. Estándar de la industria.">
<div class="flex items-center justify-between gap-2">
<div class="text-sm">Net Interest Margin (NIM) Y5</div>
<button type="button" class="metric-explain-btn" data-metric="nim" aria-label="Ver fórmula del NIM">
    <i data-lucide="info" class="w-4 h-4"></i>
</button>
</div>
<div class="text-2xl font-bold" id="nim-y5">0.0%</div>
<div class="text-xs text-emerald-400">Rentabilidad de Cartera</div>
</div>
<div class="metric-card" data-tooltip="El año en que los ingresos operativos superan los gastos operativos, marcando el punto en que el negocio se sostiene por sí mismo sin necesidad de nuevas inyecciones de capital.">
<div class="text-sm">Autosuficiencia</div>
<div class="text-2xl font-bold" id="autosuficiency-year">Año 0</div>
<div class="text-xs text-blue-400">Ingresos > Gastos Operativos</div>
</div>
</div>
</div>
</div>
<!-- Tab Navigation -->
<div class="mb-6 border-b border-slate-800">
<nav class="flex flex-wrap -mb-px">
<button id="tab-control" class="tab-button active"> <i data-lucide="settings" class="w-5 h-5"></i> Control</button>
<button id="tab-financieros" class="tab-button"> <i data-lucide="wallet" class="w-5 h-5"></i> Financieros</button>
<button id="tab-niif" class="tab-button"> <i data-lucide="book" class="w-5 h-5"></i> NIIF</button>
<button id="tab-auditoria" class="tab-button"> <i data-lucide="clipboard-check" class="w-5 h-5"></i> Auditoría</button>
<button id="tab-graficos" class="tab-button"> <i data-lucide="bar-chart-2" class="w-5 h-5"></i> Gráficos</button>
<button id="tab-investor" class="tab-button"> <i data-lucide="pie-chart" class="w-5 h-5"></i> Investor Snapshot</button>
<button id="tab-validacion" class="tab-button"> <i data-lucide="check-circle" class="w-5 h-5"></i> Validación</button>
</nav>
</div>
<!-- Tab Content: Control -->
<div id="content-control" class="content-section active">
<div class="space-y-10">

    <section class="space-y-4">
        <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-3">
            <h3 class="text-lg font-semibold text-white flex items-center gap-2">
                📦 Producto & Escala
            </h3>
            <p class="text-sm text-slate-400 max-w-3xl">
                Ajusta la oferta financiada y el plan de despliegue. Cada cambio impacta los flujos del modelo, así que mantén un ojo en las métricas de la parte superior antes de presentar a inversionistas.
            </p>
        </div>
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
            <div class="card">
                <h4 class="font-semibold text-lg mb-4 text-white">Paquete Financiado <span class="text-sm text-slate-400">(El Producto Principal)</span></h4>
                <div id="paquete-financiado-controls" class="space-y-4"></div>
                <div id="package-summary" class="mt-4 p-3 bg-slate-800 rounded"></div>
            </div>
            <div class="card">
                <h4 class="font-semibold text-lg mb-4 text-white">Plan de Crecimiento y Operaciones</h4>
                <div id="plan-crecimiento-controls" class="space-y-4"></div>
            </div>
        </div>
    </section>

    <section class="space-y-4">
        <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-3">
            <h3 class="text-lg font-semibold text-white flex items-center gap-2">
                🧭 Relación con el Cliente
            </h3>
            <p class="text-sm text-slate-400 max-w-3xl">
                Define las condiciones del crédito y los ingresos transaccionales. Estos controles modifican directamente el NIM, el payback y la resiliencia de caja.
            </p>
        </div>
        <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
            <div class="card">
                <h4 class="font-semibold text-lg mb-4 text-white">Condiciones del Crédito al Cliente</h4>
                <div id="condiciones-credito-controls" class="space-y-4"></div>
            </div>
            <div class="card">
                <h4 class="font-semibold text-lg mb-4 text-white">Ingresos Operativos Adicionales</h4>
                <div id="ingresos-adicionales-controls" class="space-y-4"></div>
            </div>
        </div>
    </section>

    <section class="space-y-4">
        <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-3">
            <h3 class="text-lg font-semibold text-white flex items-center gap-2">
                💰 Motor de Capital
            </h3>
            <p class="text-sm text-slate-400 max-w-3xl">
                Administra las líneas disponibles, tasas y seguros. La cascada siguiente refleja los drawdowns reales del modelo, alineados con el Protected Capital Engine.
            </p>
        </div>
        <div class="card">
            <div id="matriz-financiamiento-controls" class="space-y-6"></div>
        </div>
    </section>

    <section class="space-y-4">
        <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-3">
            <h3 class="text-lg font-semibold text-white flex items-center gap-2">
                🛡️ Riesgo & Supuestos de Salida
            </h3>
            <p class="text-sm text-slate-400 max-w-3xl">
                Ajusta supuestos de morosidad, recuperación y múltiplos. Los indicadores de covenants y cobertura se actualizan tras recalcular el modelo.
            </p>
        </div>
        <div class="card">
            <div id="riesgo-salida-controls" class="space-y-4"></div>
        </div>
    </section>

    <div class="sticky bottom-6 flex justify-end">
        <button onclick="handleManualRecalc(this)" class="bg-emerald-600 hover:bg-emerald-500 text-white px-6 py-3 rounded-lg font-medium transition duration-300 inline-flex items-center gap-2 shadow-lg">
            <i data-lucide="refresh-cw" class="w-5 h-5"></i>
            Recalcular modelo
        </button>
    </div>
</div>
</div>
<!-- Tab Content: Financials -->
<div id="content-financieros" class="content-section">
<div class="space-y-6">
<div class="card">
<h3 class="text-xl font-semibold mb-4 text-white">Estado de Resultados (P&L)</h3>
<div class="overflow-x-auto">
<table id="pl-table" class="financial-table">
<thead>
<tr>
<th>Concepto</th>
<th>Año 1</th>
<th>Año 2</th>
<th>Año 3</th>
<th>Año 4</th>
<th>Año 5</th>
</tr>
</thead>
<tbody id="pl-table-body"></tbody>
</table>
</div>
</div>
<div class="card">
<h3 class="text-xl font-semibold mb-4 text-white">Flujo de Efectivo</h3>
<div class="overflow-x-auto">
<table id="cf-table" class="financial-table">
<thead>
<tr>
<th>Concepto</th>
<th>Año 0</th>
<th>Año 1</th>
<th>Año 2</th>
<th>Año 3</th>
<th>Año 4</th>
<th>Año 5</th>
</tr>
</thead>
<tbody id="cf-table-body"></tbody>
</table>
</div>
</div>
<div class="card">
<h3 class="text-xl font-semibold mb-4 text-white">Balance General</h3>
<div class="overflow-x-auto">
<table id="bs-table" class="financial-table">
<thead>
<tr>
<th>Concepto</th>
<th>Año 1</th>
<th>Año 2</th>
<th>Año 3</th>
<th>Año 4</th>
<th>Año 5</th>
</tr>
</thead>
<tbody id="bs-table-body"></tbody>
</table>
</div>
<div id="balance-validation" class="mt-4 text-center font-semibold p-2 rounded-lg bg-gray-50"></div>
</div>
</div>
</div>
<!-- Tab Content: IFRS -->
<div id="content-niif" class="content-section">
<div class="space-y-6">
<div class="card niif-compliant">
<h3 class="text-xl font-semibold mb-4 text-white">NIIF 15 - Reconocimiento de Ingresos <span class="text-sm text-slate-400">(Cómo se reconocen los ingresos del negocio de financiamiento)</span></h3>
<div id="niif15-container">Calculando datos NIIF 15...</div>
</div>
<div class="card niif-compliant">
<h3 class="text-xl font-semibold mb-4 text-white">NIIF 9 - Provisiones Crediticias <span class="text-sm text-slate-400">(Impacto de la morosidad y las pérdidas esperadas)</span></h3>
<div id="niif9-container">Calculando datos NIIF 9...</div>
</div>
<div class="card niif-compliant">
<h3 class="text-xl font-semibold mb-4 text-white">NIIF 5 - Activos Mantenidos para Venta <span class="text-sm text-slate-400">(Tratamiento contable de vagonetas reposedas)</span></h3>
<div id="niif5-container">Calculando datos NIIF 5...</div>
</div>
</div>
</div>
<!-- Tab Content: Auditoría -->
<div id="content-auditoria" class="content-section">
    <div class="space-y-6">
        <div class="card">
            <h3 class="text-xl font-semibold mb-3 text-white flex items-center gap-2">
                <i data-lucide="waypoints" class="w-5 h-5 text-sky-300"></i>
                Auditoría guiada
            </h3>
            <p class="text-sm text-slate-400 mb-4">
                Usa esta pestaña como checklist vivo: valida NIIF, caja y supuestos clave antes de compartir el modelo. Todo se calcula automáticamente con los datos del escenario actual.
            </p>
            <ol class="grid gap-3 md:grid-cols-2 text-sm text-slate-300">
                <li class="p-3 bg-slate-900/60 border border-slate-800 rounded-lg">
                    <strong class="block text-white text-sm mb-1">1. Verifica NIIF</strong>
                    <span class="text-xs text-slate-400">Confirma que NIIF 9, 15 y 5 estén activos y con cifras esperadas.</span>
                </li>
                <li class="p-3 bg-slate-900/60 border border-slate-800 rounded-lg">
                    <strong class="block text-white text-sm mb-1">2. Revisa caja y covenants</strong>
                    <span class="text-xs text-slate-400">Chequea el peor año de caja, DSCR final y leverage.</span>
                </li>
                <li class="p-3 bg-slate-900/60 border border-slate-800 rounded-lg">
                    <strong class="block text-white text-sm mb-1">3. Documenta supuestos</strong>
                    <span class="text-xs text-slate-400">Descarga los supuestos para enviarlos con el deck.</span>
                </li>
                <li class="p-3 bg-slate-900/60 border border-slate-800 rounded-lg">
                    <strong class="block text-white text-sm mb-1">4. Lista hallazgos</strong>
                    <span class="text-xs text-slate-400">Toma nota de las alertas y define acciones antes del próximo comité.</span>
                </li>
            </ol>
        </div>

        <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
            <div class="card">
                <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                    <h4 class="text-lg font-semibold text-white">Checklist NIIF & salud financiera</h4>
                    <span class="text-xs text-slate-400">Se actualiza con cada recalculo</span>
                </div>
                <div id="audit-niif-status" class="mt-4 space-y-3"></div>
            </div>
            <div class="card">
                <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                    <h4 class="text-lg font-semibold text-white">Caja & covenants clave</h4>
                    <span class="text-xs text-slate-400">Headroom real del escenario</span>
                </div>
                <div id="audit-cash-summary" class="mt-4 space-y-3"></div>
                <div id="audit-balance-adjustments" class="mt-4 text-xs text-amber-300 space-y-2"></div>
            </div>
        </div>

        <div class="card">
            <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 mb-4">
                <h4 class="text-lg font-semibold text-white">Supuestos esenciales del modelo</h4>
                <div class="flex items-center gap-2">
                    <button id="download-assumptions-btn" class="bg-sky-600 hover:bg-sky-500 text-white text-sm px-4 py-2 rounded-lg inline-flex items-center gap-2 transition">
                        <i data-lucide="download" class="w-4 h-4"></i>
                        Descargar supuestos
                    </button>
                    <button id="download-results-btn" class="bg-emerald-600 hover:bg-emerald-500 text-white text-sm px-4 py-2 rounded-lg inline-flex items-center gap-2 transition">
                        <i data-lucide="file-chart" class="w-4 h-4"></i>
                        Exportar snapshot
                    </button>
            </div>
        </div>
        <div class="flex flex-wrap gap-2 mt-3">
            <button id="export-pl-csv-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs px-3 py-2 rounded-lg inline-flex items-center gap-2 transition">
                <i data-lucide="table" class="w-4 h-4"></i>
                P&L CSV
            </button>
            <button id="export-cf-csv-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs px-3 py-2 rounded-lg inline-flex items-center gap-2 transition">
                <i data-lucide="file-text" class="w-4 h-4"></i>
                Cash Flow CSV
            </button>
            <button id="export-bs-csv-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white text-xs px-3 py-2 rounded-lg inline-flex items-center gap-2 transition">
                <i data-lucide="layers" class="w-4 h-4"></i>
                Balance CSV
            </button>
            <button id="export-covenants-csv-btn" class="bg-teal-600 hover:bg-teal-500 text-white text-xs px-3 py-2 rounded-lg inline-flex items-center gap-2 transition">
                <i data-lucide="shield" class="w-4 h-4"></i>
                Covenants CSV
            </button>
            <button id="export-pdf-btn" class="bg-amber-600 hover:bg-amber-500 text-white text-xs px-3 py-2 rounded-lg inline-flex items-center gap-2 transition">
                <i data-lucide="printer" class="w-4 h-4"></i>
                Reporte PDF
            </button>
        </div>
        <p class="text-[11px] text-slate-500 mt-2">Los CSV/PDF incluyen los datos vigentes del escenario que tengas activo.</p>
        <div id="audit-assumptions-table" class="grid grid-cols-1 lg:grid-cols-2 gap-4 mt-3"></div>
    </div>

        <div class="card">
            <h4 class="text-lg font-semibold text-white mb-2">Glosario de fórmulas clave</h4>
            <p class="text-xs text-slate-400 mb-4">Cada métrica muestra la fórmula aplicada y los valores del escenario actual para que puedas documentarla o replicarla rápidamente.</p>
            <div id="audit-formulas" class="grid grid-cols-1 xl:grid-cols-2 gap-4"></div>
        </div>

        <div class="card">
            <h4 class="text-lg font-semibold text-white mb-2">Radar de salud financiera</h4>
            <p class="text-xs text-slate-400 mb-4">Los ejes están normalizados (1.0 = en objetivo Serie A). Evalúa DSCR, cobertura de CAPEX, leverage, NIM y liquidez final.</p>
            <div style="height: 280px;">
                <canvas id="covenantRadarChart"></canvas>
            </div>
        </div>

        <div class="card">
            <h4 class="text-lg font-semibold text-white mb-2">Bitácora de cambios</h4>
            <p class="text-xs text-slate-400 mb-4">Registro de los últimos cálculos y descargas. Ideal para auditar qué escenario se revisó y qué se compartió.</p>
            <ul id="audit-change-log" class="space-y-2 text-xs text-slate-300"></ul>
        </div>
    </div>
</div>
<!-- Tab Content: Charts -->
<div id="content-graficos" class="content-section">
<div class="space-y-6">
    <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
        <div class="card">
            <h4 class="text-lg font-semibold mb-3 text-white">💰 Capital Allocation Cascade</h4>
            <div style="height: 320px;"><canvas id="fundingCascadeChart"></canvas></div>
        </div>
        <div class="card">
            <h4 class="text-lg font-semibold mb-3 text-white">💵 Revenue Mix Evolution</h4>
            <div style="height: 320px;"><canvas id="revenueMixChart"></canvas></div>
        </div>
    </div>

    <div class="card">
        <h4 class="text-lg font-semibold mb-3 text-white">🚚 Growth vs. Net Cash Impact</h4>
        <div style="height: 320px;"><canvas id="unitsCashChart"></canvas></div>
    </div>

    <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
        <div class="card">
            <h4 class="text-lg font-semibold mb-3 text-white">📐 Cost of Capital vs Returns</h4>
            <div style="height: 300px;"><canvas id="capitalSpreadChart"></canvas></div>
        </div>
        <div class="card">
            <h4 class="text-lg font-semibold mb-3 text-white">🛡️ Covenant Health</h4>
            <div style="height: 300px;"><canvas id="riskRatiosChart"></canvas></div>
        </div>
    </div>

    <div class="grid grid-cols-1 xl:grid-cols-2 gap-6">
        <div class="card">
            <h4 class="text-lg font-semibold mb-3 text-white">💧 Liquidity Coverage</h4>
            <div style="height: 300px;"><canvas id="cashCoverageChart"></canvas></div>
        </div>
        <div class="card">
            <h4 class="text-lg font-semibold mb-3 text-white">🚀 Capital Efficiency</h4>
            <div style="height: 300px;"><canvas id="capitalEfficiencyChart"></canvas></div>
        </div>
    </div>

    <div class="card">
        <h4 class="text-lg font-semibold mb-3 text-white">💸 Cash Flow Resilience</h4>
        <div style="height: 300px;"><canvas id="cashFlowResilienceChart"></canvas></div>
    </div>
</div>
</div>
<!-- Tab Content: Investor Snapshot -->
<div id="content-investor" class="content-section">
    <div class="space-y-10">
        <section class="space-y-4">
            <div class="flex flex-col lg:flex-row lg:items-center lg:justify-between gap-4">
                <div>
                    <h2 id="investor-snapshot-title" class="text-2xl font-semibold text-white">Investor Snapshot · Escenario Base</h2>
                    <p id="investor-eca-subtitle" class="text-sm text-slate-400">sin cobertura ECA</p>
                </div>
                <label class="flex items-center gap-3 text-sm font-medium text-slate-200">
                    <input type="checkbox" id="investor-eca-toggle" class="h-5 w-5 rounded border-slate-600 bg-slate-800" />
                    <span>Añadir cobertura SINOSURE (Y2+)</span>
                </label>
            </div>
        </section>

        <section class="space-y-4">
            <div class="flex items-center justify-between">
                <h3 class="text-lg font-semibold text-white">Why it Works</h3>
            </div>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div class="metric-card" id="investor-tir-card">
                    <div class="text-sm">TIR Equity</div>
                    <div class="text-3xl font-bold text-emerald-400" id="investor-tir">0.0%</div>
                    <div class="text-xs text-slate-400">Retorno sobre capital propio</div>
                </div>
                <div class="metric-card" id="investor-dscr-card">
                    <div class="text-sm">DSCR Final</div>
                    <div class="text-3xl font-bold text-sky-400" id="investor-dscr">0.0x</div>
                    <div class="text-xs text-slate-400">Cobertura servicio de deuda</div>
                </div>
                <div class="metric-card" id="investor-coverage-card">
                    <div class="text-sm">Cobertura CAPEX</div>
                    <div class="text-3xl font-bold text-cyan-400" id="investor-coverage">0.0%</div>
                    <div class="text-xs text-slate-400">Fondeo vs inversión</div>
                </div>
            </div>
            <p class="text-xs uppercase tracking-wide text-slate-500">Spread 29% | NIM Año 5 | Autosuficiencia Año 1</p>
        </section>

        <section class="space-y-4">
            <div class="flex items-center justify-between">
                <h3 class="text-lg font-semibold text-white">Growth Engine</h3>
            </div>
            <div class="card bg-slate-900/60 border border-slate-700">
                <div class="flex flex-col gap-4">
                    <div class="flex items-center justify-between">
                        <span class="text-sm font-semibold text-slate-200">Contribución de ingresos Año 5</span>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="min-w-full text-sm text-slate-300" id="investor-revenue-table">
                            <thead class="text-xs uppercase tracking-wide text-slate-500">
                                <tr>
                                    <th class="px-4 py-2 text-left">Línea</th>
                                    <th class="px-4 py-2 text-right">Monto</th>
                                    <th class="px-4 py-2 text-right">Mix</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="px-4 py-2">Intereses</td>
                                    <td class="px-4 py-2 text-right">$0</td>
                                    <td class="px-4 py-2 text-right">0%</td>
                                </tr>
                                <tr>
                                    <td class="px-4 py-2">Comisión GNV</td>
                                    <td class="px-4 py-2 text-right">$0</td>
                                    <td class="px-4 py-2 text-right">0%</td>
                                </tr>
                                <tr>
                                    <td class="px-4 py-2">Originación NIIF 15</td>
                                    <td class="px-4 py-2 text-right">$0</td>
                                    <td class="px-4 py-2 text-right">0%</td>
                                </tr>
                                <tr>
                                    <td class="px-4 py-2">Aftersales</td>
                                    <td class="px-4 py-2 text-right">$0</td>
                                    <td class="px-4 py-2 text-right">0%</td>
                                </tr>
                            </tbody>
                            <tfoot class="border-t border-slate-700 text-slate-200">
                                <tr>
                                    <td class="px-4 py-2 font-semibold">Total</td>
                                    <td class="px-4 py-2 text-right font-semibold" id="investor-revenue-total">$0</td>
                                    <td class="px-4 py-2 text-right font-semibold">100%</td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <p class="text-xs text-slate-400" id="investor-revenue-footnote">Margen core 15.7% · NIM Y5 0.0% · Autosuficiencia Año 0</p>
                </div>
            </div>
        </section>

        <section class="space-y-4">
            <div class="flex items-center justify-between">
                <h3 class="text-lg font-semibold text-white">Capital Stack</h3>
            </div>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="card bg-slate-900/60 border border-slate-700 space-y-4">
                    <div class="flex flex-col gap-1">
                        <h4 class="text-lg font-semibold text-white" id="investor-stack-title-left">Estado actual</h4>
                        <p class="text-xs text-slate-400" id="investor-stack-description-left">Bridge 0M, Commercial 0M, Venture 0M</p>
                    </div>
                    <div class="space-y-2 text-sm text-slate-300">
                        <div class="flex justify-between"><span>Equity desplegado</span><span id="investor-equity-left">$0</span></div>
                        <div class="flex justify-between"><span>Deuda desplegada</span><span id="investor-debt-left">$0</span></div>
                        <div class="flex justify-between"><span>Mix</span><span id="investor-mix-left">0%</span></div>
                        <div class="flex justify-between"><span>Cash After Financing</span><span id="investor-caf-left">$0</span></div>
                        <div class="flex justify-between"><span>NIM Y5</span><span id="investor-nim-left">0.0%</span></div>
                        <div class="flex justify-between"><span>DSCR Final</span><span id="investor-dscr-left">0.0x</span></div>
                    </div>
                    <ul class="text-xs text-slate-400 space-y-1" id="investor-stack-bullets-left"></ul>
                </div>
                <div class="card bg-slate-900/40 border border-slate-700 space-y-4">
                    <div class="flex flex-col gap-1">
                        <h4 class="text-lg font-semibold text-white" id="investor-stack-title-right">Estado alterno</h4>
                        <p class="text-xs text-slate-400" id="investor-stack-description-right">Bridge 0M, Commercial 0M, Venture 0M</p>
                    </div>
                    <div class="space-y-2 text-sm text-slate-300">
                        <div class="flex justify-between"><span>Equity desplegado</span><span id="investor-equity-right">$0</span></div>
                        <div class="flex justify-between"><span>Deuda desplegada</span><span id="investor-debt-right">$0</span></div>
                        <div class="flex justify-between"><span>Mix</span><span id="investor-mix-right">0%</span></div>
                        <div class="flex justify-between"><span>Cash After Financing</span><span id="investor-caf-right">$0</span></div>
                        <div class="flex justify-between"><span>NIM Y5</span><span id="investor-nim-right">0.0%</span></div>
                        <div class="flex justify-between"><span>DSCR Final</span><span id="investor-dscr-right">0.0x</span></div>
                    </div>
                    <ul class="text-xs text-slate-400 space-y-1" id="investor-stack-bullets-right"></ul>
                </div>
            </div>
        </section>

        <section class="space-y-4">
            <h3 class="text-lg font-semibold text-white">Risk &amp; Mitigation</h3>
            <ul class="list-disc list-inside text-sm text-slate-300 space-y-1">
                <li>Protección Conductores™: LGD 50% soportado por telemetría y reestructura in situ.</li>
                <li>Equity calls automáticos: worst cash = 0, motor evita saldo negativo.</li>
                <li>NIIF 9/15/5 visibles: PD 0.8/8/40; ⚠️ PD estática documentada.</li>
                <li>Seguro pass-through: margen core limpio, pasivo separado en balance.</li>
            </ul>
        </section>

        <section class="space-y-4">
            <h3 class="text-lg font-semibold text-white">Escenarios en contexto</h3>
            <div class="card bg-slate-900/60 border border-slate-700 overflow-x-auto">
                <table class="min-w-full text-left text-sm text-slate-300">
                    <thead class="uppercase tracking-wide text-xs text-slate-500">
                        <tr>
                            <th class="px-4 py-2">Escenario</th>
                            <th class="px-4 py-2">TIR equity</th>
                            <th class="px-4 py-2">DSCR</th>
                            <th class="px-4 py-2">Cash AF Y5</th>
                        </tr>
                    </thead>
                    <tbody id="investor-scenarios-table" class="divide-y divide-slate-800">
                        <tr>
                            <td class="px-4 py-2">250 unidades</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                        </tr>
                        <tr>
                            <td class="px-4 py-2">500 unidades</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                        </tr>
                        <tr>
                            <td class="px-4 py-2">750 unidades</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                        </tr>
                        <tr>
                            <td class="px-4 py-2">1000 unidades</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                            <td class="px-4 py-2">N/A</td>
                        </tr>
                    </tbody>
                </table>
                <p class="text-[11px] text-slate-500" id="investor-scenarios-footnote"></p>
            </div>
        </section>

        <section class="space-y-4">
            <h3 class="text-lg font-semibold text-white">Ask / Next Steps</h3>
            <div class="text-sm text-slate-300 space-y-1">
                <p>Seed actual (en curso): $10,000,000 MXN para afinar la plataforma tech y desplegar el piloto.</p>
                <p>Serie A objetivo: $50,000,000 MXN · 60% CAPEX, 25% working capital, 15% tech &amp; risk ops.</p>
            </div>
            <button id="investor-export-pack" class="inline-flex items-center justify-center px-4 py-2 rounded-lg bg-sky-600 hover:bg-sky-500 text-white text-sm font-semibold transition" type="button">Exportar Investor Pack</button>
        </section>
    </div>
</div>
<!-- Tab Content: Validation -->
<div id="content-validacion" class="content-section">
<div id="validation-panel-content">
<h3 class="text-xl font-semibold mb-4 text-white">Resultados de Validación del Modelo</h3>
<div id="validation-results-container">
<!-- Validation results will be inserted here -->
</div>
<!-- REMOVED: PDF Report Button -->
</div>
</div>
</div>
<script>
// Initializes Lucide icons
lucide.createIcons();

// ===================================================================
// ===== FASE 1: CONFIGURACIÓN Y DATOS INICIALES (EL QUÉ) =========
// ===================================================================
// (Aquí se definen todas las variables y la configuración inicial del modelo)
let debugLogs = []; // Array to store debug logs
let charts = {}; // Object to store Chart.js instances
let plannedFinancingData = {}; // NEW: To store pre-calculation financing plan
let scenarioSnapshots = {}; // NEW: Stores recalculated scenario metrics for comparison
let actionLog = []; // NEW: Simple history of key actions (recalcs/exports)
let metricPopoverEl = null;
let metricPopoverAnchor = null;
let investorToggleECA = false;
let investorScenarioCache = {};

/**
* @typedef {Object} ModelData
* This object holds all the dynamic inputs for the financial model.
*/
let modelData = {
// Unit Economics & Pricing
tasaInteres: 29.0,
downPaymentPercentage: 20,
upfrontCommissionPercentage: 3,
vanPrice: 750000,
vanCost: 625000,
conversionPrice: 54000,
bancasPrice: 21000,
gpsPrice: 12000,
insuranceAnnualPrice: 37205,
insuranceYears: 4,
conversionCost: 50000,
bancasCost: 20000,
gpsCost: 11000,
refaccionesCostPerUnit: 8000,
// Risk Assumptions
pdStage1: 0.008,
pdStage2: 0.08,
pdStage3: 0.40,
lgd: 0.50,
portfolioAllocationStage1: 0.82,
portfolioAllocationStage2: 0.10,
portfolioAllocationStage3: 0.08,

// Growth Strategy
unitsPerYear: [15, 50, 100, 180, 250], // Base scenario - Updated

// Capital Structure - CORRECTED SEED + SERIES A
seed: 10000000,    // $10M MXN Seed fijo en Año 0
seriesA: 50000000, // $50M MXN - Growth capital Year 0 for scaling
ventureDebtLineAvailable: 100000000, 
commercialDebtLineAvailable: 300000000, 
bridgeDebtLineAvailable: 150000000,
ventureDebtRate: 18.0,
commercialDebtRate: 14.0,
bridgeDebtRate: 16.0,
commercialGraceMonths: 18,
commercialLoanTermMonths: 72,
commercialBalloonPercent: 20,
bridgeGraceMonths: 18,
bridgeLoanTermMonths: 72,
bridgeBalloonPercent: 10,
targetDSCR: 1.2,
costOfEquityManual: 25,
// Planned Drawdowns
ventureDebtYear1: 50000000,
ventureDebtYear2: 50000000,
ventureDebtYear3: 0,
ventureDebtYear4: 0,
ventureDebtYear5: 0,
commercialDebtYear1: 0,
commercialDebtYear2: 0,
commercialDebtYear3: 100000000,
commercialDebtYear4: 100000000,
commercialDebtYear5: 100000000,
partnerCapitalizationYear1: 50000000,
partnerCapitalizationYear2: 50000000,
partnerCapitalizationYear3: 0,
partnerCapitalizationYear4: 0,
partnerCapitalizationYear5: 0,
seriesB_newInvestors_year2: 0,
seriesB_newInvestors_year3: 70000000,

// Other Assumptions
ebitdaMultipleProject: 9.0,
floorEquityMultiple: 1.4,
proteccionRodando: true,
economicAdjustmentFactor: 1.0,
margenRefacciones: 30,
periodoAmortizacionDeuda: 5,
clientLoanTermYears: 4,
depreciationYears: 10,
opexRates: [17, 14, 11, 10, 9],
margenVagoneta: 9.5,
tasaReposicion: 5,
fairValueVenta: 78,
costosVenta: 7,
corporateTaxRate: 31,
litrosPromedioMensualPorUnidad: 900,
precioLitroGNV: 13.99,
comisionGNVPorcentaje: 15,
gmvPromedioMensualPorUnidad: 9000,
takeRateMarketplace: 3.0,
avgRemainingTermCartera: 2.5,
// SINOSURE Configuration
sinosureAvailable: false
};

// EMERGENCY ROLLBACK FUNCTION
function emergencyRollback() {
    console.log('🚨 EMERGENCY ROLLBACK INITIATED');
    location.reload(); // Nuclear option - reload page
}
// Test: emergencyRollback() in console if anything breaks

// ===================================================================
// ===== STEP 1: CONSTRAINT ANALYSIS ENGINE (CORE - NO UI YET) ====
// ===================================================================

// Dynamic constraint calculation
function calculateDynamicConstraints() {
    const scenarioLimits = {
        pesimista: [8, 25, 45, 70, 90],
        base: [15, 50, 100, 180, 250],
        optimista: [25, 80, 180, 320, 450]
    };
    
    const constraints = {
        capitalHealth: analyzeCapitalHealth(),
        dscrStatus: analyzeDSCRStatus(),
        cashFlowHealth: analyzeCashFlowHealth(),
        sinosureOpportunity: analyzeSinosureOpportunity(),
        unitLimits: calculateUnitLimits(scenarioLimits),
        recommendations: []
    };
    
    constraints.recommendations = generateSmartRecommendations(constraints);
    
    return constraints;
}

function analyzeCapitalHealth() {
    const totalCapex = modelData.unitsPerYear.reduce((sum, units) => sum + (units * getTotalPackageCost()), 0);
    const totalFunding = totalFundingFromCF();
    const coverage = totalFunding > 0 ? Math.min((totalFunding / totalCapex) * 100, 105) : 0;
    
    return {
        totalCapex,
        totalFunding,
        coverage,
        gap: Math.max(0, totalCapex - totalFunding),
        status: coverage >= 100 ? 'sufficient' : coverage >= 90 ? 'tight' : 'insufficient'
    };
}

function analyzeDSCRStatus() {
    let finalDSCR = null;
    if (financialResults.pl && financialResults.pl.length >= 5 && financialResults.cf && financialResults.cf.length >= 5) {
        const year5EBITDA = financialResults.pl[4].ebitda || 0;
        const year5Interest = financialResults.pl[4].interestExpense || 0;
        const year5Principal = financialResults.cf[4].debtPrincipalRepayment || 0;
        const year5Balloon = financialResults.cf[4].balloonPayment || 0;
        const totalDebtService = year5Interest + year5Principal + year5Balloon;
        finalDSCR = safeRatio(year5EBITDA, totalDebtService, null);
    }
    
    const status = finalDSCR === null
        ? 'n/a'
        : finalDSCR >= 2.0
            ? 'healthy'
            : finalDSCR >= 1.5
                ? 'adequate'
                : finalDSCR >= 1.2
                    ? 'warning'
                    : 'critical';

    return {
        current: finalDSCR,
        covenant: 1.5,
        status
    };
}

function analyzeCashFlowHealth() {
    let worstCash = 0;
    let worstYear = 0;
    
    if (financialResults.bs && financialResults.bs.length > 0) {
        financialResults.bs.forEach((bs, index) => {
            if (bs.cash < worstCash) {
                worstCash = bs.cash;
                worstYear = index + 1;
            }
        });
    }
    
    return {
        worstBalance: worstCash,
        worstYear: worstYear,
        status: worstCash >= 0 ? 'positive' : worstCash >= -10000000 ? 'manageable' : 'critical'
    };
}

function analyzeSinosureOpportunity() {
    const totalUnits = modelData.unitsPerYear.reduce((sum, units) => sum + units, 0);
    const maxSinosureAmount = totalUnits * 365000; // $365K per unit
    
    // Calculate potential savings vs Venture Debt
    const ventureDebtUsed = calculateTotalDebtRaised(); // Current VD usage
    const potentialSavings = Math.min(maxSinosureAmount, ventureDebtUsed) * (modelData.ventureDebtRate - 6.0) / 100;
    
    return {
        available: maxSinosureAmount,
        currentlyEnabled: modelData.sinosureAvailable,
        potentialSavings: potentialSavings,
        coverage: maxSinosureAmount,
        recommendation: !modelData.sinosureAvailable && maxSinosureAmount > 0 ? 'enable' : 'enabled'
    };
}

function calculateUnitLimits(scenarioLimits) {
    const limits = [];
    
    for (let year = 0; year < 5; year++) {
        const minUnits = scenarioLimits.pesimista[year];
        const maxUnits = scenarioLimits.optimista[year];
        const baseUnits = scenarioLimits.base[year];
        
        // Calculate capital-constrained maximum
        const availableCapitalForYear = calculateAvailableCapitalForYear(year + 1);
        const capitalConstrainedMax = Math.floor(availableCapitalForYear / getTotalPackageCost());
        
        // Apply DSCR constraint (simplified)
        const dscrConstrainedMax = Math.floor(capitalConstrainedMax * 0.8); // Conservative factor
        
        // Final safe maximum
        const safeMax = Math.min(maxUnits, capitalConstrainedMax, dscrConstrainedMax);
        
        limits.push({
            year: year + 1,
            hardMin: minUnits,
            hardMax: Math.max(minUnits, safeMax), // Ensure min <= max
            recommended: baseUnits,
            current: modelData.unitsPerYear[year],
            status: modelData.unitsPerYear[year] >= minUnits && modelData.unitsPerYear[year] <= safeMax ? 'safe' : 'warning'
        });
    }
    
    return limits;
}

function calculateAvailableCapitalForYear(year) {
    // Simplified calculation of available capital
    let available = modelData.seed + modelData.seriesA;
    
    for (let y = 1; y <= year; y++) {
        available += (modelData[`ventureDebtYear${y}`] || 0);
        available += (modelData[`commercialDebtYear${y}`] || 0);
        available += (modelData[`partnerCapitalizationYear${y}`] || 0);
        available += (modelData[`seriesB_newInvestors_year${y}`] || 0);
    }
    
    if (modelData.sinosureAvailable) {
        const unitsUpToYear = modelData.unitsPerYear.slice(0, year).reduce((sum, units) => sum + units, 0);
        available += unitsUpToYear * 365000; // SINOSURE coverage
    }
    
    return available;
}

// Smart recommendations generator
function generateSmartRecommendations(constraints) {
    const recommendations = [];
    
    // Capital recommendations
    if (constraints.capitalHealth.status === 'insufficient') {
        recommendations.push({
            type: 'capital',
            priority: 'high',
            title: 'Funding Gap Detected',
            message: `Need additional ${formatCurrency(constraints.capitalHealth.gap)} funding`,
            action: 'Reduce units or increase funding lines'
        });
    }
    
    // DSCR recommendations
    if (constraints.dscrStatus.current !== null && constraints.dscrStatus.status === 'critical') {
        recommendations.push({
            type: 'dscr',
            priority: 'high',
            title: 'DSCR Critical',
            message: `DSCR ${constraints.dscrStatus.current.toFixed(1)}x below covenant ${constraints.dscrStatus.covenant}x`,
            action: 'Reduce debt or increase equity ratio'
        });
    }
    
    // SINOSURE recommendations
    if (constraints.sinosureOpportunity.recommendation === 'enable') {
        recommendations.push({
            type: 'sinosure',
            priority: 'medium',
            title: 'SINOSURE Opportunity',
            message: `Potential annual savings: ${formatCurrency(constraints.sinosureOpportunity.potentialSavings)}`,
            action: 'Enable SINOSURE to reduce financing costs'
        });
    }
    
    // Cash flow recommendations
    if (constraints.cashFlowHealth.status === 'critical') {
        recommendations.push({
            type: 'cashflow',
            priority: 'high',
            title: 'Cash Flow Warning',
            message: `Year ${constraints.cashFlowHealth.worstYear} shows ${formatCurrency(constraints.cashFlowHealth.worstBalance)} cash`,
            action: 'Review timing of capital deployment'
        });
    }
    
    return recommendations;
}

// ===================================================================
// ===== STEP 2: CONSTRAINT DASHBOARD FUNCTIONS (UI READY) =========
// ===================================================================

function createConstraintDashboard() {
    const dashboardHTML = `
        <div id="constraint-dashboard" class="mt-6 p-4 bg-gradient-to-r from-slate-900 to-slate-800 rounded-lg border border-slate-700">
            <h3 class="text-sm font-semibold text-white mb-3 flex items-center">
                🛡️ Financial Health Monitor
                <span id="overall-status" class="ml-2 px-2 py-1 text-xs rounded bg-emerald-900 text-emerald-300">✅ Healthy</span>
            </h3>
            <div class="flex items-center gap-2 mt-2">
                <label class="text-sm text-slate-400">Modo:</label>
                <button id="toggle-mode-btn" class="px-3 py-1 rounded bg-slate-800 hover:bg-slate-700 text-white text-sm">Growth Mode</button>
            </div>
            
            <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 text-xs">
                <div id="capital-status" class="p-2 bg-slate-800 rounded border-l-2 border-blue-500">
                    <div class="font-medium text-blue-400">💰 Capital</div>
                    <div class="text-white" id="capital-value">Loading...</div>
                </div>
                
                <div id="dscr-status" class="p-2 bg-slate-800 rounded border-l-2 border-green-500">
                    <div class="font-medium text-green-400">📊 DSCR</div>
                    <div class="text-white" id="dscr-value">Loading...</div>
                </div>
                
                <div id="cashflow-status" class="p-2 bg-slate-800 rounded border-l-2 border-yellow-500">
                    <div class="font-medium text-yellow-400">💸 Cash Flow</div>
                    <div class="text-white" id="cashflow-value">Loading...</div>
                </div>
                
                <div id="sinosure-status" class="p-2 bg-slate-800 rounded border-l-2 border-purple-500">
                    <div class="font-medium text-purple-400">🇨🇳 SINOSURE</div>
                    <div class="text-white" id="sinosure-value">Loading...</div>
                </div>
            </div>
            
            <div id="recommendations-container" class="mt-3 space-y-1"></div>
        </div>
    `;
    
    // Insert after scenario selector
    const scenarioSelector = document.querySelector('.scenario-selector');
    if (scenarioSelector) {
        scenarioSelector.insertAdjacentHTML('afterend', dashboardHTML);
    }
}

function updateConstraintDashboard() {
    const constraints = calculateDynamicConstraints();
    const recommendations = constraints.recommendations;
    
    // Update capital status
    const capitalElement = document.getElementById('capital-value');
    if (capitalElement) {
        capitalElement.textContent = `${constraints.capitalHealth.coverage.toFixed(0)}% covered`;
        const capitalPanel = document.getElementById('capital-status');
        capitalPanel.className = `p-2 bg-slate-800 rounded border-l-2 ${
            constraints.capitalHealth.status === 'sufficient' ? 'border-green-500' :
            constraints.capitalHealth.status === 'tight' ? 'border-yellow-500' : 'border-red-500'
        }`;
    }
    
    // Update DSCR status
    const dscrElement = document.getElementById('dscr-value');
    if (dscrElement) {
        if (constraints.dscrStatus.current !== null) {
            dscrElement.textContent = `${constraints.dscrStatus.current.toFixed(1)}x`;
        } else {
            dscrElement.textContent = 'N/A';
        }
        const dscrPanel = document.getElementById('dscr-status');
        const dscrClass = constraints.dscrStatus.status === 'healthy' || constraints.dscrStatus.status === 'adequate'
            ? 'border-green-500'
            : constraints.dscrStatus.status === 'warning'
                ? 'border-yellow-500'
                : constraints.dscrStatus.status === 'critical'
                    ? 'border-red-500'
                    : 'border-slate-600';
        dscrPanel.className = `p-2 bg-slate-800 rounded border-l-2 ${dscrClass}`;
    }
    
    // Update cash flow status
    const cashflowElement = document.getElementById('cashflow-value');
    if (cashflowElement) {
        cashflowElement.textContent = constraints.cashFlowHealth.status === 'positive' ? 'Positive' : 
            `${formatCurrency(constraints.cashFlowHealth.worstBalance, false)} Y${constraints.cashFlowHealth.worstYear}`;
        const cashflowPanel = document.getElementById('cashflow-status');
        cashflowPanel.className = `p-2 bg-slate-800 rounded border-l-2 ${
            constraints.cashFlowHealth.status === 'positive' ? 'border-green-500' :
            constraints.cashFlowHealth.status === 'manageable' ? 'border-yellow-500' : 'border-red-500'
        }`;
    }
    
    // Update SINOSURE status
    const sinosureElement = document.getElementById('sinosure-value');
    if (sinosureElement) {
        sinosureElement.textContent = constraints.sinosureOpportunity.currentlyEnabled ? 
            'Active' : `${formatCurrency(constraints.sinosureOpportunity.potentialSavings, false)} potential`;
        const sinosurePanel = document.getElementById('sinosure-status');
        sinosurePanel.className = `p-2 bg-slate-800 rounded border-l-2 ${
            constraints.sinosureOpportunity.currentlyEnabled ? 'border-green-500' : 'border-purple-500'
        }`;
    }
    
    // Update overall status
    const overallElement = document.getElementById('overall-status');
    if (overallElement) {
        const criticalIssues = recommendations.filter(r => r.priority === 'high').length;
        if (criticalIssues > 0) {
            overallElement.textContent = `⚠️ ${criticalIssues} Issues`;
            overallElement.className = 'ml-2 px-2 py-1 text-xs rounded bg-red-900 text-red-300';
        } else {
            overallElement.textContent = '✅ Healthy';
            overallElement.className = 'ml-2 px-2 py-1 text-xs rounded bg-emerald-900 text-emerald-300';
        }
    }
    
    // Update recommendations
    const recsContainer = document.getElementById('recommendations-container');
    if (recsContainer && recommendations.length > 0) {
        const topRecs = recommendations.slice(0, 2); // Show top 2 recommendations
        recsContainer.innerHTML = topRecs.map(rec => `
            <div class="text-xs p-2 rounded ${
                rec.priority === 'high' ? 'bg-red-900/30 text-red-300' : 'bg-yellow-900/30 text-yellow-300'
            }">
                <strong>${rec.title}:</strong> ${rec.message}
            </div>
        `).join('');
    }
}

// ===== MODE TOGGLE (Growth vs Steady-State)
let currentMode = "growth";
try {
    const savedMode = localStorage.getItem('currentModePreference');
    if (savedMode === 'growth' || savedMode === 'steady') {
        currentMode = savedMode;
    }
} catch (error) {
    console.warn('No se pudo recuperar el modo preferido:', error.message);
}
let dataRoomActive = false;
function toggleMode() {
    currentMode = currentMode === "growth" ? "steady" : "growth";
    const btn = document.getElementById('toggle-mode-btn');
    if (btn) btn.textContent = currentMode === "growth" ? "Growth Mode" : "Steady-State Mode";
    updateFinancialModeUI();
    try {
        localStorage.setItem('currentModePreference', currentMode);
    } catch (error) {
        console.warn('No se pudo guardar el modo preferido:', error.message);
    }
}
function toggleDataRoomMode(forceOff = false) {
    const overlay = document.getElementById('data-room-overlay');
    if (!overlay) return;
    dataRoomActive = forceOff ? false : !dataRoomActive;
    if (dataRoomActive) {
        renderDataRoomOverlay();
        overlay.classList.remove('hidden');
        document.body.classList.add('overflow-hidden');
        if (window.lucide && typeof window.lucide.createIcons === 'function') {
            window.lucide.createIcons();
        }
    } else {
        overlay.classList.add('hidden');
        document.body.classList.remove('overflow-hidden');
    }
}
function renderDataRoomOverlay() {
    if (!financialResults || !financialResults.pl || financialResults.pl.length < 5) return;
    const scenarioDef = SCENARIO_DEFS[currentScenario] || { name: 'Personalizado', units: modelData.unitsPerYear.slice() };
    const dscrMetrics = calculateDebtMetricsBreakdown();
    const coverageRatio = safeRatio(totalFundingFromCF(), calculateTotalCapex(), 0) * 100;
    const cashAfterFinancing = financialResults.cf?.[4]?.cashAfterFinancing || 0;
    const corePrice = getTotalPackagePrice();
    const coreCost = getTotalPackageCost();
    const coreMargin = corePrice - coreCost;
    const coreMarginPct = corePrice > 0 ? (coreMargin / corePrice) * 100 : 0;
    const cfAggregates = (financialResults.cf || []).reduce((acc, cf) => {
        acc.equity += Math.max(0, (cf.equityInjection || 0) + (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0));
        acc.bridge += Math.max(0, cf.bridgeFundingRaised || 0);
        acc.commercial += Math.max(0, cf.additionalFundingRaised || 0);
        acc.venture += Math.max(0, cf.currentYearVentureDebtDraw || 0);
        acc.sinosure += Math.max(0, cf.sinosureDrawn || 0);
        return acc;
    }, { equity: 0, bridge: 0, commercial: 0, venture: 0, sinosure: 0 });
    const totalEquityDisplayed = (modelData.seed || 0) + (modelData.seriesA || 0) + cfAggregates.equity;
    const totalDebtDisplayed = cfAggregates.sinosure + cfAggregates.bridge + cfAggregates.commercial + cfAggregates.venture;

    const setText = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    };

    setText('data-room-scenario', `${scenarioDef.name || 'Escenario'} (${currentScenario}u)`);
    setText('data-room-tir', `${financialResults.tirEquity.toFixed(1)}%`);
    setText('data-room-dscr', dscrMetrics.finalDSCR !== null ? `${dscrMetrics.finalDSCR.toFixed(2)}x` : 'N/A');
    setText('data-room-coverage', `${coverageRatio.toFixed(1)}%`);
    setText('data-room-caf', formatCurrency(cashAfterFinancing));
    setText('data-room-margin', `${formatCurrency(coreMargin, true)} (${coreMarginPct.toFixed(1)}%)`);
    setText('data-room-equity', formatCurrency(totalEquityDisplayed));
    setText('data-room-debt', formatCurrency(totalDebtDisplayed));

    const comparisonContainer = document.getElementById('data-room-comparison');
    const sourceTable = document.getElementById('scenario-comparison-table');
    if (comparisonContainer && sourceTable) {
        comparisonContainer.innerHTML = sourceTable.innerHTML;
    }
}
function updateFinancialModeUI() {
    const growthCards = document.querySelectorAll('.growth-metric');
    const steadyCards = document.querySelectorAll('.steady-metric');
    if (currentMode === 'growth') {
        growthCards.forEach(c => c.style.display = 'block');
        steadyCards.forEach(c => c.style.display = 'none');
    } else {
        growthCards.forEach(c => c.style.display = 'none');
        steadyCards.forEach(c => c.style.display = 'block');
    }
}
// ===================================================================
// ===== STEP 3: SMART UNIT CONSTRAINTS (PROTECT INPUTS) ===========
// ===================================================================

function enhanceUnitInputsWithConstraints() {
    const constraints = calculateDynamicConstraints();
    
    constraints.unitLimits.forEach((limit, index) => {
        const input = document.getElementById(`unitsPerYear-${limit.year}`);
        if (input) {
            // Set hard limits
            input.min = limit.hardMin;
            input.max = limit.hardMax;
            
            // Add visual guidance
            input.addEventListener('input', function() {
                const value = parseInt(this.value);
                
                // CONSTRAINT ENFORCEMENT - AUTO-CORRECT OUT OF BOUNDS
                if (value < limit.hardMin) {
                    this.value = limit.hardMin;
                    showTemporaryMessage(`Minimum ${limit.hardMin} units required for Year ${limit.year}`, 'warning');
                } else if (value > limit.hardMax) {
                    this.value = limit.hardMax;
                    showTemporaryMessage(`Maximum ${limit.hardMax} units available for Year ${limit.year} (capital constraint)`, 'warning');
                }
                
                // Visual feedback
                const finalValue = parseInt(this.value);
                if (finalValue >= limit.hardMin && finalValue <= limit.hardMax) {
                    if (Math.abs(finalValue - limit.recommended) <= 10) {
                        this.style.borderColor = '#10b981'; // Green - optimal
                        this.style.boxShadow = '0 0 0 2px rgba(16, 185, 129, 0.2)';
                    } else {
                        this.style.borderColor = '#f59e0b'; // Yellow - acceptable
                        this.style.boxShadow = '0 0 0 2px rgba(245, 158, 11, 0.2)';
                    }
                } else {
                    this.style.borderColor = '#ef4444'; // Red - constrained
                    this.style.boxShadow = '0 0 0 2px rgba(239, 68, 68, 0.2)';
                }
                
                // Update modelData and recalculate
                modelData.unitsPerYear[index] = finalValue;
                forceCalculate();
            });
            
            // Add tooltip with constraints info
            input.setAttribute('title', `Range: ${limit.hardMin} - ${limit.hardMax} units (Recommended: ${limit.recommended})`);
        }
    });
}

function showTemporaryMessage(message, type = 'info') {
    const existingMsg = document.getElementById('temp-constraint-message');
    if (existingMsg) existingMsg.remove();
    
    const msgDiv = document.createElement('div');
    msgDiv.id = 'temp-constraint-message';
    msgDiv.className = `fixed top-20 right-4 p-3 rounded-lg shadow-lg z-50 text-sm ${
        type === 'warning' ? 'bg-amber-900 border border-amber-600 text-amber-200' :
        type === 'error' ? 'bg-red-900 border border-red-600 text-red-200' :
        'bg-blue-900 border border-blue-600 text-blue-200'
    }`;
    msgDiv.textContent = message;
    
    document.body.appendChild(msgDiv);
    
    setTimeout(() => {
        if (msgDiv.parentNode) msgDiv.parentNode.removeChild(msgDiv);
    }, 3000);
}

// ===================================================================
// ===== STEP 4: PROTECTED CAPITAL MOTOR DISPLAY ===================
// ===================================================================

function updateProtectedCapitalMotor() {
    const statusContainer = document.querySelector('#financing-summary-card');
    if (!statusContainer) return;

    if (!financialResults || !Array.isArray(financialResults.cf) || financialResults.cf.length === 0) {
        statusContainer.innerHTML = '<p class="text-sm text-slate-300">Waiting for calculation...</p>';
        return;
    }

    // --- SSOT: Aggregate real cash-flow based draws ---
    const cfAgg = financialResults.cf.reduce((acc, cf) => {
        if ((cf.year || 0) > 0) {
            acc.equity += Math.max(0, (cf.equityInjection || 0) + (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0));
        }
        acc.sinosure += Math.max(0, cf.sinosureDrawn || 0);
        acc.bridge += Math.max(0, cf.bridgeFundingRaised || 0);
        acc.commercial += Math.max(0, cf.additionalFundingRaised || 0);
        acc.venture += Math.max(0, cf.currentYearVentureDebtDraw || 0);
        return acc;
    }, { equity: 0, sinosure: 0, bridge: 0, commercial: 0, venture: 0 });

const totalUnits = modelData.unitsPerYear.reduce((sum, units) => sum + units, 0);
const capexRequired = calculateTotalCapex();
const totalEquityFunding = (modelData.seed || 0) + (modelData.seriesA || 0) + cfAgg.equity;
const totalDebtFunding = cfAgg.sinosure + cfAgg.bridge + cfAgg.commercial + cfAgg.venture;
const totalFunding = totalEquityFunding + totalDebtFunding;
const coverage = capexRequired > 0 ? (totalFunding / capexRequired) * 100 : 0;

    const scenarioInfo = SCENARIO_DEFS[currentScenario] || { name: 'Escenario', units: [] };
    const scenarioUnitsTotal = (scenarioInfo.units || []).reduce((sum, value) => sum + (Number(value) || 0), 0);
    const dscrValue = typeof financialResults.finalDSCR === 'number' ? financialResults.finalDSCR : calculateDebtMetricsBreakdown().finalDSCR;
    const dscrClass = dscrValue === null ? 'text-slate-400' : dscrValue >= 1.5 ? 'text-emerald-400' : 'text-red-400';
    const dscrText = dscrValue === null ? 'N/A' : `${dscrValue.toFixed(1)}x`;

    statusContainer.innerHTML = `
        <h5 class="font-semibold text-white mb-3 flex items-center">
            🧠 Protected Capital Engine
            <span class="ml-2 text-xs px-2 py-1 rounded bg-slate-700 text-slate-300">Auto-Managed</span>
        </h5>
        <div class="text-sm space-y-3 text-slate-300">
            <div class="p-2 bg-slate-800/50 rounded border border-slate-700">
                <div class="font-semibold text-blue-400 mb-1">Input Analysis</div>
                <div class="flex justify-between text-xs">
                    <span>Total Units:</span> <strong class="text-white">${totalUnits.toLocaleString()}</strong>
                </div>
                <div class="flex justify-between text-xs">
                    <span>CAPEX Required:</span> <strong class="text-white">${formatCurrency(capexRequired)}</strong>
                </div>
                <div class="flex justify-between text-xs">
                    <span>Scenario:</span> <strong class="text-emerald-400">${scenarioInfo.name} (${scenarioUnitsTotal} unidades)</strong>
                </div>
            </div>
            <div class="p-2 bg-slate-800/50 rounded border border-slate-700">
                <div class="font-semibold text-green-400 mb-1">Auto-Allocation Cascade (CF Real)</div>
                <div class="space-y-1 text-xs">
                    <div class="flex justify-between"><span>1. Seed (Fixed):</span> <strong class="text-blue-400">${formatCurrency(modelData.seed)}</strong></div>
                    <div class="flex justify-between"><span>2. Serie A:</span> <strong class="text-emerald-400">${formatCurrency(modelData.seriesA)}</strong></div>
                    <div class="flex justify-between"><span>3. SINOSURE (6%):</span> <strong class="${cfAgg.sinosure > 0 ? 'text-yellow-400' : 'text-slate-500'}">${formatCurrency(cfAgg.sinosure)}</strong></div>
                    <div class="flex justify-between"><span>4. Bridge / Warehousing (${modelData.bridgeDebtRate.toFixed(1)}%):</span> <strong class="${cfAgg.bridge > 0 ? 'text-purple-300' : 'text-slate-500'}">${formatCurrency(cfAgg.bridge)}</strong></div>
                    <div class="flex justify-between"><span>5. Commercial (${modelData.commercialDebtRate.toFixed(1)}%):</span> <strong class="text-orange-400">${formatCurrency(cfAgg.commercial)}</strong></div>
                    <div class="flex justify-between"><span>6. Venture (${modelData.ventureDebtRate.toFixed(1)}%):</span> <strong class="text-red-400">${formatCurrency(cfAgg.venture)}</strong></div>
                </div>
            </div>
            <div class="p-2 bg-slate-800/50 rounded border border-slate-700">
                <div class="font-semibold text-purple-400 mb-1">Engine Output</div>
                <div class="flex justify-between text-xs">
                    <span>Total Funding (CF):</span> <strong class="text-white">${formatCurrency(totalFunding)}</strong>
                </div>
                <div class="flex justify-between text-xs">
                    <span>Coverage:</span> <strong class="${coverage >= 100 ? 'text-emerald-400' : 'text-amber-400'}">${coverage.toFixed(1)}%</strong></div>
                <div class="flex justify-between text-xs">
                    <span>DSCR Impact:</span> <strong class="${dscrClass}">${dscrText}</strong>
                </div>
            </div>
            <div class="text-xs p-2 bg-slate-700/30 rounded border border-slate-600">
                🛡️ <strong>Protected:</strong> Display synced with cash-flow engine. Modify units to see updated allocation.
            </div>
        </div>
    `;
}

// ===================================================================
// ===== V3.1 STABILITY ENGINE: UTILS, SCENARIOS & STATE MGMT =======
// ===================================================================

function deepClone(value) {
    if (value === null || typeof value !== 'object') return value;
    if (typeof structuredClone === 'function') {
        try {
            return structuredClone(value);
        } catch (error) {
            // structuredClone not supported for this payload, fallback below
        }
    }
    try {
        return JSON.parse(JSON.stringify(value));
    } catch (error) {
        console.warn('deepClone fallback failed:', error.message);
        return value;
    }
}

function hardResetEngine() {
    financialResults = { pl: [], cf: [], bs: [], niifDetails: [], tirProyecto: 0, tirCartera: 0, tirEquity: 0, roe: [], roic: [], balanceAdjustments: [] };
    if (typeof sinosureCohorts !== 'undefined') sinosureCohorts = [];
    if (typeof ventureDebtCohorts !== 'undefined') ventureDebtCohorts = [];
    if (typeof commercialDebtCohorts !== 'undefined') commercialDebtCohorts = [];
    log('🧼 Engine hard-reset completed');
}

function injectInitialEquity() {
    hardResetEngine();
    financialResults.cf.push({
        year: 0,
        partnerCapitalization: modelData.seed || 0,
        seriesBNewInvestors: modelData.seriesA || 0,
    });
    log(`💡 Initial Equity Y0 Injected: ${formatCurrency((modelData.seed || 0) + (modelData.seriesA || 0))}`);
}

const SCENARIO_DEFS = {
    250: { units: [10, 40, 60, 65, 75], name: 'Pesimista' },
    500: { units: [15, 70, 120, 150, 145], name: 'Base' },
    750: { units: [20, 100, 200, 220, 210], name: 'Optimista' },
    1000: { units: [25, 150, 250, 300, 275], name: 'Stress' }
};

const VENTURE_DEBT_CAPS = [20000000, 30000000, 25000000, 15000000, 10000000];
const COMMERCIAL_DEBT_CAPS = [40000000, 90000000, 130000000, 160000000, 180000000];

let currentScenario = 500;
try {
    const savedScenario = JSON.parse(localStorage.getItem('selectedScenario'));
    if (savedScenario && savedScenario.units && SCENARIO_DEFS[savedScenario.units]) {
        currentScenario = Number(savedScenario.units);
    }
} catch (error) {
    console.warn('No se pudo recuperar el escenario guardado:', error.message);
}
let capitalPlanOutput = null;

function updateUnitInputs(units) {
    units.forEach((value, index) => {
        const input = document.getElementById(`unitsPerYear-${index+1}`);
        if (input) {
            input.value = value;
            input.style.borderColor = '#10b981';
            input.style.boxShadow = '0 0 0 2px rgba(16, 185, 129, 0.2)';
            setTimeout(() => {
                input.style.borderColor = '';
                input.style.boxShadow = '';
            }, 1500);
        }
    });
}

function updateScenarioButtons(activeScenario) {
    document.querySelectorAll('.scenario-btn').forEach(btn => {
        btn.classList.remove('active', 'bg-emerald-700', 'text-white', 'border-emerald-600', 'font-medium', 'shadow-lg');
        btn.classList.add('bg-slate-700', 'text-slate-300', 'border-slate-600');
    });

    const idMap = {
        250: 'scenario-pesimista',
        '250': 'scenario-pesimista',
        500: 'scenario-base',
        '500': 'scenario-base',
        750: 'scenario-optimista',
        '750': 'scenario-optimista',
        1000: 'scenario-stress',
        '1000': 'scenario-stress'
    };
    const targetId = idMap[activeScenario] || `scenario-${activeScenario}`;
    const activeBtn = document.getElementById(targetId);
    if (activeBtn) {
        activeBtn.classList.remove('bg-slate-700', 'text-slate-300', 'border-slate-600');
        activeBtn.classList.add('active', 'bg-emerald-700', 'text-white', 'border-emerald-600', 'font-medium', 'shadow-lg');
    }
}

function renderCapitalAnalysisCF(totalEquity, mix) {
    const card = document.getElementById('capital-analysis-card');
    if (!card || !mix) return;
    const totalDebt = (mix.sinosure || 0) + (mix.bridge || 0) + (mix.commercial || 0) + (mix.venture || 0);
    const total = totalEquity + totalDebt;
    const equityShare = total > 0 ? (totalEquity / total) * 100 : 0;
    const debtShare = total > 0 ? (totalDebt / total) * 100 : 0;
    card.innerHTML = `
        <div class="text-sm space-y-1 text-slate-200">
            <div class="flex justify-between"><span>Equity desplegado</span><strong>${formatCurrency(totalEquity)}</strong></div>
            <div class="flex justify-between"><span>Deuda total</span><strong>${formatCurrency(totalDebt)}</strong></div>
            <div class="flex justify-between"><span>Mix Equity</span><strong>${equityShare.toFixed(1)}%</strong></div>
            <div class="flex justify-between"><span>Mix Deuda</span><strong>${debtShare.toFixed(1)}%</strong></div>
            <hr class="border-slate-700 my-2">
            <div class="grid grid-cols-2 gap-2 text-xs">
                <div class="flex justify-between"><span>SINOSURE</span><strong>${formatCurrency(mix.sinosure || 0)}</strong></div>
                <div class="flex justify-between"><span>Bridge</span><strong>${formatCurrency(mix.bridge || 0)}</strong></div>
                <div class="flex justify-between"><span>Comercial</span><strong>${formatCurrency(mix.commercial || 0)}</strong></div>
                <div class="flex justify-between"><span>Venture</span><strong>${formatCurrency(mix.venture || 0)}</strong></div>
            </div>
        </div>
    `;
}

function updateCapitalStatus(capitalPlan) {
    if (!capitalPlan) return;
    log('✅ Capital plan optimized; revisa el Motor de Capital para la versión consolidada.');
}

function _applyGrowthScenario(units) {
    try {
        const scenarioKey = SCENARIO_DEFS[units] ? Number(units) : 500;
        const scenario = SCENARIO_DEFS[scenarioKey] || { units: modelData.unitsPerYear, name: 'Personalizado' };
        modelData.unitsPerYear = [...scenario.units];
        currentScenario = scenarioKey;
        try {
            localStorage.setItem('selectedScenario', JSON.stringify({ units: scenarioKey, name: scenario.name }));
        } catch (error) {
            console.warn('No se pudo guardar el escenario activo:', error.message);
        }
        log(`🧩 Scenario set: ${scenario.name} (${scenarioKey}u)`);

        updateUnitInputs(scenario.units);
        updateScenarioButtons(scenarioKey);

        hardResetEngine();
        forceCalculate();

        setTimeout(() => {
            const capex = calculateTotalCapex();
            const coverage = capex > 0 ? ((totalFundingFromCF() / capex) * 100).toFixed(1) : '0.0';
            const dscr = calculateFinalDSCR();
            log(`✅ Post-scenario Validation: Coverage=${coverage}% | DSCR=${dscr ? dscr.toFixed(2) + 'x' : 'N/A'}`);
        }, 300);
    } catch (error) {
        console.error('❌ _applyGrowthScenario Error:', error);
    }
}
window.applyGrowthScenario = _applyGrowthScenario;

function setupScenarioListeners() {
    const bind = () => {
        document.getElementById('scenario-pesimista')?.addEventListener('click', () => window.applyGrowthScenario(250));
        document.getElementById('scenario-base')?.addEventListener('click', () => window.applyGrowthScenario(500));
        document.getElementById('scenario-optimista')?.addEventListener('click', () => window.applyGrowthScenario(750));
        document.getElementById('scenario-stress')?.addEventListener('click', () => window.applyGrowthScenario(1000));
        log('✅ Scenario listeners bound successfully');
    };
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bind, { once: true });
    } else {
        bind();
    }
}

// UI controls configuration by section
const controlsConfig = {
paqueteFinanciado: [
{ id: 'vanPrice', label: 'Precio Vagoneta Base', min: 650000, max: 900000, step: 5000, type: 'number', format: val => formatCurrency(val, true), tooltip: '📊 Serie A guidance: Margen >15% vs costo para unit economics defendibles', investorRange: { green: [729000, 800000], yellow: [680000, 729000], red: [650000, 680000] } },
{ id: 'conversionPrice', label: 'Precio Conversión GNV', min: 45000, max: 70000, step: 1000, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Margen típico: 8-15% sobre costo de conversión' },
{ id: 'bancasPrice', label: 'Precio Bancas GNV', min: 18000, max: 26000, step: 1000, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Premium sobre costo: 5-30% según diferenciación' },
{ id: 'gpsPrice', label: 'Precio GPS/Telemática', min: 11000, max: 20000, step: 500, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Value-add service: Margen 20-60% típico' },
{ id: 'insuranceAnnualPrice', label: 'Seguro Anual', min: 25000, max: 40000, step: 500, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Pass-through cost: Sin margen para Conductores' },
{ id: 'insuranceYears', label: 'Años Seguro', min: 2, max: 4, step: 1, type: 'number', format: val => val.toFixed(0) + ' años', tooltip: '⚖️ Balance: Más años = mayor loan size = mejor unit economics' },
{ id: 'vanCost', label: 'Costo Vagoneta (Conductores)', min: 500000, max: 700000, step: 5000, type: 'number', format: val => formatCurrency(val, true), tooltip: '🎯 Critical: Debe ser <85% del precio para margen mínimo Serie A', investorRange: { green: [500000, 580000], yellow: [580000, 620000], red: [620000, 700000] } },
{ id: 'conversionCost', label: 'Costo Conversión GNV', min: 40000, max: 65000, step: 1000, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Costo directo: Incluye instalación y certificación' },
{ id: 'bancasCost', label: 'Costo Bancas GNV', min: 17000, max: 24000, step: 1000, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Costo manufacturng: Base para pricing strategy' },
{ id: 'gpsCost', label: 'Costo GPS/Telemática', min: 9000, max: 18000, step: 500, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Hardware + instalación: Optimizar para escala' },
],
condicionesCredito: [
{ id: 'tasaInteres', label: 'Tasa de Interés (Clientes)', min: 28, max: 30, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: "Palanca clave de rentabilidad. El rango 28-30% equilibra competitividad comercial y retorno suficiente para la Serie A.", investorRange: { green: [29, 30], yellow: [28, 29], red: [30, 35] } },
{ id: 'downPaymentPercentage', label: '% Enganche Cliente', min: 15, max: 25, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: "Balance entre accesibilidad para el cliente y flujo de caja para Conductores. Por debajo del 15% aumenta nuestro riesgo; por encima del 25% limita nuestro mercado objetivo.", investorRange: { green: [20, 25], yellow: [15, 20], red: [25, 30] } },
{ id: 'clientLoanTermYears', label: 'Plazo Préstamo Cliente (Años)', min: 3, max: 5, step: 1, type: 'range', format: val => val.toFixed(0) + ' años', tooltip: '⚖️ Payment vs interest: 4 años = optimal balance. 3 años = high payments, 5+ años = interest rate risk', investorRange: { green: [4, 4], yellow: [3, 4], red: [5, 5] } },
{ id: 'upfrontCommissionPercentage', label: '% Comisión Upfront', min: 1, max: 6, step: 0.1, type: 'range', format: val => val.toFixed(1) + '%', tooltip: 'NIIF 15 deferral: 2-3% típico para cash flow inicial sin penalizar accesibilidad' },
],
ingresosAdicionales: [
{ id: 'litrosPromedioMensualPorUnidad', label: 'Litros GNV/Unidad (Mensual)', min: 800, max: 1000, step: 10, type: 'number', format: val => val.toFixed(0) + ' L', tooltip: 'Usage pattern: 900L = optimal efficiency. Dependiente de rutas y utilización' },
{ id: 'precioLitroGNV', label: 'Precio Litro GNV (MXN)', min: 12.50, max: 13.99, step: 0.01, type: 'number', format: val => '$' + val.toFixed(2) + ' MXN', tooltip: 'Market price: Conductores no controla, pero impacta commission revenue' },
{ id: 'comisionGNVPorcentaje', label: 'Comisión GNV (%)', min: 8, max: 15, step: 0.1, type: 'range', format: val => val.toFixed(1) + '%', tooltip: '🚀 Recurring revenue: 10-12% competitive. <8% = low value capture, >13% = partner resistance' },
{ id: 'gmvPromedioMensualPorUnidad', label: 'Ventas Brutas Marketplace/Unidad (Mensual)', min: 6000, max: 12000, step: 100, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Marketplace traction: $9K = baseline, growth dependent on platform adoption' },
{ id: 'takeRateMarketplace', label: 'Take Rate Marketplace (%)', min: 1.5, max: 3.0, step: 0.1, type: 'range', format: val => val.toFixed(1) + '%', tooltip: 'Platform economics: 2% competitive vs other B2B marketplaces. Limited upside near-term' },
{ id: 'refaccionesCostPerUnit', label: 'Costo Refacciones/Unidad', min: 5000, max: 10000, step: 200, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Service cost base: Optimizar para margen pero mantener quality' },
{ id: 'margenRefacciones', label: 'Margen Refacciones', min: 20, max: 35, step: 1, type: 'range', format: val => val.toFixed(0) + '%', tooltip: '🔧 Service margin: 25-30% realistic. <20% = low profitability, >35% = price resistance' },
],
planCrecimiento: [
{ id: 'unitsPerYear', label: 'Unidades por Año', type: 'array', min: 0, max: 2000, step: 10, format: val => val.toFixed(0), tooltip: 'El crecimiento está limitado por el capital disponible. El modelo no permitirá financiar más unidades de las que el capital total (Equity + Deuda) puede cubrir para evitar un flujo de caja negativo.' },
{ id: 'opexRates', label: 'Tasa OPEX por Año (%)', type: 'array', min: 12, max: 20, step: 0.5, format: val => val.toFixed(1) + '%', tooltip: 'Eficiencia operativa por año. Se espera que disminuya con la escala.' },
{ id: 'depreciationYears', label: 'Años Depreciación (Vagoneta)', min: 8, max: 12, step: 1, type: 'number', format: val => val.toFixed(0) + ' años', tooltip: 'Asset life: 10 años = standard. 8 años = conservative, 12 años = aggressive' },
],
riesgoYSalida: [
{ id: 'proteccionRodando', label: 'Protección Rodando™', type: 'checkbox', tooltip: "Activa nuestro foso competitivo clave. Reduce las provisiones NIIF 9 en un 50%, cuantificando el impacto de nuestra tecnología de intervención proactiva para estabilizar la cartera." },
{ id: 'pdStage1', label: 'PD Etapa 1 (12M)', min: 0.003, max: 0.012, step: 0.001, type: 'range', format: val => (val * 100).toFixed(1) + '%', tooltip: '📊 Serie A reality check: 0.8% es una base conservadora. <0.5% = optimista, >1.2% = riesgo alto.', investorRange: { green: [0.004, 0.008], yellow: [0.003, 0.004], red: [0.008, 0.012] } },
{ id: 'pdStage2', label: 'PD Etapa 2 (Lifetime)', min: 0.06, max: 0.12, step: 0.005, type: 'range', format: val => (val * 100).toFixed(1) + '%', tooltip: '⚖️ Lifetime default: 7-10% benchmark. <6% = optimistic, >12% = high risk segment', investorRange: { green: [0.07, 0.10], yellow: [0.06, 0.07], red: [0.10, 0.12] } },
{ id: 'pdStage3', label: 'PD Etapa 3 (Lifetime)', min: 0.30, max: 0.50, step: 0.01, type: 'range', format: val => (val * 100).toFixed(1) + '%', tooltip: '🚨 Impaired assets: 35-45% realistic. <30% = recovery overestimate, >50% = write-off territory' },
{ id: 'lgd', label: 'LGD (Pérdida Incumplimiento)', min: 0.45, max: 0.60, step: 0.01, type: 'range', format: val => (val * 100).toFixed(1) + '%', tooltip: '💔 Loss severity: 50-55% typical for vehicle collateral. Asset depreciation + recovery costs' },
{ id: 'portfolioAllocationStage1', label: 'Port. Etapa 1 (%)', min: 0.75, max: 0.90, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: '✅ Healthy portfolio: 80-87% in Stage 1. >90% = unrealistic, <75% = risk concentration' },
{ id: 'portfolioAllocationStage2', label: 'Port. Etapa 2 (%)', min: 0.08, max: 0.18, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: '⚠️ Watch list: 10-15% normal. <8% = understated, >18% = portfolio stress' },
{ id: 'portfolioAllocationStage3', label: 'Port. Etapa 3 (%)', min: 0.02, max: 0.08, step: 0.01, type: 'range', format: val => (val * 100).toFixed(0) + '%', tooltip: '🚨 Problem loans: 3-6% manageable. >8% = collection issues, <2% = unrealistic' },
{ id: 'tasaReposicion', label: '% Unidades Reposición', min: 3, max: 7, step: 0.5, type: 'number', format: val => val.toFixed(1) + '%', tooltip: '🔄 Repossession rate: 4-6% realistic. <3% = recovery overestimate, >7% = business model stress' },
{ id: 'fairValueVenta', label: '% Fair Value Venta', min: 75, max: 90, step: 1, type: 'number', format: val => val.toFixed(0) + '%', tooltip: '💰 Recovery value: 85% reasonable for well-maintained vehicles. Market dependent' },
{ id: 'costosVenta', label: '% Costos Venta', min: 4, max: 8, step: 0.5, type: 'number', format: val => val.toFixed(1) + '%', tooltip: '💸 Transaction costs: 5-6% typical (storage, auction, legal, transport)' },
{ id: 'ebitdaMultipleProject', label: 'Múltiplo EBITDA TIR', min: 8, max: 10, step: 0.5, type: 'range', format: val => val.toFixed(1) + 'X', tooltip: '🎯 Tech-enabled equipment finance: 8-10x base en rondas growth. Conductores target: 9x.' },
{ id: 'floorEquityMultiple', label: 'Múltiplo Valor en Libros (P/B)', min: 1.2, max: 1.8, step: 0.1, type: 'range', format: val => val.toFixed(1) + 'X', tooltip: "Floor value protection. 1.2-1.4x conservative, 1.4-1.6x growth, 1.6x+ aggressive. Solo como valor mínimo vs EBITDA multiple." },
{ id: 'costOfEquityManual', label: 'Costo Equity (Ke)', min: 15, max: 35, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: 'Se usa como fallback en WACC cuando no hay TIR equity disponible.' },
{ id: 'ventureDebtRate', label: 'Tasa Venture Debt', min: 17.0, max: 21.0, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: "Costo del capital de crecimiento. 18-19% es el estándar del mercado mexicano. Tasas superiores impactan la TIR y el DSCR." },
{ id: 'commercialDebtRate', label: 'Tasa Deuda Comercial', min: 13.0, max: 16.0, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: "Costo del capital de escala. 14-15% es el estándar para deuda bancaria en esta etapa." }
],
};

// SINOSURE Configuration
const sinosureConfig = {
    rate: 6.0,
    maxDuration: 12,
    productionCostPercentage: 100,
    productionCostUSD: 18250,
    exchangeRate: 20,
    availabilityMonth: 13
};

// Object to store calculated financial results
let financialResults = {
pl: [], // Profit & Loss
cf: [], // Cash Flow
bs: [], // Balance Sheet
niifDetails: [], // IFRS application details
tirProyecto: 0, // Project Internal Rate of Return
tirCartera: 0, // Customer Portfolio Internal Rate of Return
tirEquity: 0, // Equity Internal Rate of Return
roe: [], // Annual Return on Equity
roic: [], // Annual Return on Invested Capital
balanceAdjustments: [] // Equity tweaks applied to close within tolerance
};

// New global array for IFRS 5 assets
let heldForSaleAssets = [];

// SINOSURE cohort tracking
let sinosureCohorts = [];

// Auto-equity injection tracking
let debtOptimizationHistory = [];

// Tolerance for balance sheet validation (MXN)
const BALANCE_TOLERANCE = 1000;

// ===================================================================
// ===== FASE 2: MOTOR DE CÁLCULO FINANCIERO (EL CÓMO) ============
// ===================================================================
// (Aquí se encuentran todas las funciones de cálculo puro que no tocan el DOM)

/**
* Formats a numeric value to currency format (millions, thousands, or no prefix).
* @param {number} value - The numeric value to format.
* @param {boolean} [full=false] - If true, use full format with commas; otherwise, use abbreviations.
* @returns {string} The value formatted as a string.
*/
function formatCurrency(value, full = false) {
if (value === null || value === undefined || isNaN(value)) return '$0 MXN';
value = parseFloat(value);

if (full) {
return '$' + value.toLocaleString('es-MX', { minimumFractionDigits: 0, maximumFractionDigits: 0 }) + ' MXN';
} else if (Math.abs(value) >= 1000000) {
return '$' + (value / 1000000).toFixed(1) + 'M';
} else if (Math.abs(value) >= 1000) {
return '$' + (value / 1000).toFixed(1) + 'K';
}
return '$' + Math.round(value).toLocaleString();
}

function formatPercentage(value, decimals = 1) {
if (value === null || value === undefined || isNaN(value)) return 'N/A';
return `${(value * 100).toFixed(decimals)}%`;
}

function safeRatio(numerator, denominator, fallback = 0) {
    const num = Number(numerator);
    const den = Number(denominator);
    if (!isFinite(num) || !isFinite(den) || den === 0) return fallback;
    const result = num / den;
    return isFinite(result) ? result : fallback;
}

/**
* Calculates the total price of financed insurance.
* @returns {number}
*/
function getInsuranceTotalPrice() {
return modelData.insuranceAnnualPrice * modelData.insuranceYears;
}
/**
* Calculates the TOTAL PRICE of the complete package.
* @returns {number}
*/
function getTotalPackagePrice() {
return modelData.vanPrice + modelData.conversionPrice +
modelData.bancasPrice + modelData.gpsPrice;
}
function getTotalPackagePriceFull() {
return getTotalPackagePrice() + getInsuranceTotalPrice();
}
/**
* Calculates the TOTAL COST of the package para Conductores (sin seguro pass-through).
* @returns {number}
*/
function getTotalPackageCost() {
return modelData.vanCost + modelData.conversionCost +
modelData.bancasCost + modelData.gpsCost;
}
function getTotalPackageCostFull() {
return getTotalPackageCost();
}
/**
* Calculates the total CAPEX required based on current units.
* @returns {number} Total CAPEX in MXN.
*/
function calculateTotalCapex() {
let totalCapex = 0;
for (let i = 0; i < modelData.unitsPerYear.length; i++) {
totalCapex += modelData.unitsPerYear[i] * getTotalPackageCost();
}
return totalCapex;
}
/**
* Calculates the total available funding based on the PLAN.
* @returns {number} Total funding in MXN.
*/
/**
* SSOT: Calculates total funding received from CF (real, positive draws only).
* Sums equity (from CF if available, otherwise from modelData per year), venture debt, commercial debt, and SINOSURE drawn.
* Ignores negative amounts (repayments/amortizations).
* @returns {number} Total funding actually received.
*/
function totalFundingFromCF() {
    if (!financialResults || !Array.isArray(financialResults.cf)) return 0;
    let total = 0;
    financialResults.cf.forEach(cf => {
        const equity = Math.max(0, (cf.equityInjection || 0) + (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0));
        const venture = Math.max(0, cf.currentYearVentureDebtDraw || 0);
        const bridge = Math.max(0, cf.bridgeFundingRaised || 0);
        const commercial = Math.max(0, cf.additionalFundingRaised || 0);
        const sinosure = Math.max(0, cf.sinosureDrawn || 0);
        total += equity + venture + bridge + commercial + sinosure;
    });
    return total;
}
/**
* Calculates SINOSURE balance for a given year.
* @param {number} year - The year to calculate balance for.
* @param {Array} sinosureCohorts - Array of SINOSURE cohorts.
* @returns {number} SINOSURE balance in MXN.
*/
function getSinosureBalance(year, sinosureCohorts) {
    let balance = 0;
    sinosureCohorts.forEach(cohort => {
        const yearsPassed = year - cohort.yearOriginated;
        if (yearsPassed >= 0) {
            const principalPaid = (cohort.originalAmount / modelData.periodoAmortizacionDeuda) * yearsPassed;
            balance += Math.max(0, cohort.originalAmount - principalPaid);
        }
    });
    return balance;
}

/**
* Estimates EBITDA for a given year for capital optimization.
* @param {number} year - The year to estimate EBITDA for.
* @returns {number} Estimated EBITDA in MXN.
*/
function calculateProjectedEBITDA(year) {
    // Simple estimation based on units and margins
    const unitsUpToYear = modelData.unitsPerYear.slice(0, year).reduce((a, b) => a + b, 0);
    const estimatedRevenue = unitsUpToYear * getTotalPackagePriceFull() * 0.15; // 15% annual revenue rate
    const estimatedOpex = estimatedRevenue * (modelData.opexRates[year - 1] / 100);
    return estimatedRevenue - estimatedOpex;
}

/**
* Validates and optimizes capital structure to maintain DSCR >= 1.5x.
* @param {number} year - Current year.
* @param {number} requiredCapex - Required capital expenditure.
* @param {number} projectedEBITDA - Projected EBITDA for the year.
* @returns {Object} Optimization results.
*/
function validateAndOptimizeCapitalStructure(year, requiredCapex, projectedEBITDA) {
    const dscrTarget = (modelData.targetDSCR && modelData.targetDSCR > 0) ? modelData.targetDSCR : 1.5;
    const maxSafeDebtService = dscrTarget > 0 ? projectedEBITDA / dscrTarget : projectedEBITDA / 1.5;
    const maxAffordableDebt = maxSafeDebtService * modelData.periodoAmortizacionDeuda;
    
    if (requiredCapex > maxAffordableDebt) {
        const equityGap = requiredCapex - maxAffordableDebt;
        
        // Auto-inject in optimal year (current or previous)
        const optimalYear = year <= 2 ? year : year - 1;
        const equityKey = `partnerCapitalizationYear${optimalYear}`;
        
        modelData[equityKey] = (modelData[equityKey] || 0) + equityGap;
        plannedFinancingData[equityKey] = (plannedFinancingData[equityKey] || 0) + equityGap;
        
        debtOptimizationHistory.push({
            year: year,
            targetYear: optimalYear,
            equityInjected: equityGap,
            reason: 'DSCR_MAINTENANCE'
        });
        
        log(`🤖 AUTO-EQUITY: Injected ${formatCurrency(equityGap)} in Year ${optimalYear} to maintain DSCR >= ${dscrTarget.toFixed(2)}x`);

        return { equityInjected: equityGap, targetYear: optimalYear };
    }

    return { feasible: true, dscr: projectedEBITDA / (requiredCapex * 0.2) }; // Estimated debt service
}

/**
* Calculates dynamic unit limit based on capital constraints.
* @param {number} year - The year to calculate limit for.
* @returns {number} Maximum units allowed.
*/
function calculateDynamicUnitLimit(year) {
    const costPerUnit = getTotalPackageCost();
    
    // 1. Available capital constraint
    let availableFunding = 0;
    for (let y = year; y <= 5; y++) {
        availableFunding += (modelData[`partnerCapitalizationYear${y}`] || 0) +
                           (modelData[`ventureDebtYear${y}`] || 0) +
                           (modelData[`commercialDebtYear${y}`] || 0) +
                           (modelData[`seriesB_newInvestors_year${y}`] || 0);
    }
    
    const maxByCapital = Math.floor(availableFunding / costPerUnit);
    
    // 2. DSCR constraint (simplified)
    const maxByDSCR = Math.floor((modelData.seriesA * 2) / costPerUnit); // Conservative estimate
    
    // 3. SINOSURE boost
    const sinosureBoost = modelData.sinosureAvailable && year >= 2 ? 
        Math.floor((sinosureConfig.productionCostUSD * sinosureConfig.exchangeRate * 0.3) / costPerUnit) : 0;
    
    return Math.min(maxByCapital, maxByDSCR) + sinosureBoost;
}

/**
* NEW: Calculates the total venture debt raised over the projection period.
* @returns {number} Venture debt raised in MXN.
*/
function calculateTotalVentureDebtRaised() {
let total = 0;
for (let i = 1; i <= 5; i++) {
    total += (modelData[`ventureDebtYear${i}`] || 0);
}
return total;
}
/**
* NEW: Calculates the total commercial debt raised over the projection period.
* @returns {number} Commercial debt raised in MXN.
*/
function calculateTotalCommercialDebtRaised() {
let total = 0;
for (let i = 1; i <= 5; i++) {
    total += (modelData[`commercialDebtYear${i}`] || 0);
}
return total;
}
function calculateTotalSinosureRaised() {
const plan = ensureCapitalPlan();
return plan.totals ? (plan.totals.sinosure || 0) : 0;
}
function calculateTotalBridgeDebtRaised() {
    if (!financialResults || !Array.isArray(financialResults.cf)) return 0;
    return financialResults.cf.reduce((sum, cf) => sum + Math.max(0, cf.bridgeFundingRaised || 0), 0);
}
function calculateTotalDebtRaised() {
return calculateTotalVentureDebtRaised() + calculateTotalCommercialDebtRaised() + calculateTotalBridgeDebtRaised() + calculateTotalSinosureRaised();
}
/**
* NEW: Calculates the total equity raised over the projection period based on OPTIMIZED values.
* @returns {number} Total equity raised in MXN.
*/
function calculateTotalEquityRaised() {
let total = (modelData.seed || 0) + (modelData.seriesA || 0);
for (let i = 1; i <= 5; i++) {
    total += (modelData[`partnerCapitalizationYear${i}`] || 0) +
             (modelData[`seriesB_newInvestors_year${i}`] || 0);
}
return total;
}
/**
* Calculates the residual balance of Venture Debt for a given year.
* @param {number} year - The projection year (1-5).
* @returns {number} The residual balance of Venture Debt.
*/
function getVentureDebtBalance(year, debtCohorts) {
    let balance = 0;
    debtCohorts.forEach(cohort => {
        const yearsPassed = year - cohort.yearOriginated;
        if (yearsPassed >= 0) {
            const principalPaid = (cohort.originalAmount / modelData.periodoAmortizacionDeuda) * yearsPassed;
            balance += cohort.originalAmount - principalPaid;
        }
    });
    return Math.max(0, balance);
}
/**
* Calculates the residual balance of Commercial Debt for a given year.
* @param {number} year - The projection year (1-5).
* @returns {number} The residual balance of Commercial Debt.
*/
function getCommercialDebtBalance(year, debtCohorts) {
    let balance = 0;
    debtCohorts.forEach(cohort => {
        const yearsPassed = year - cohort.yearOriginated;
        if (yearsPassed >= 0) {
            const principalPaid = (cohort.originalAmount / modelData.periodoAmortizacionDeuda) * yearsPassed;
            balance += cohort.originalAmount - principalPaid;
        }
    });
    return Math.max(0, balance);
}

/**
 * NUEVO: Calcula las necesidades de financiamiento año por año con lógica de cascada, respetando las líneas de crédito.
 */
function calculateYearlyFinancingNeeds(year, capexThisYear, operatingCashFlow, startingCash, debtCohorts) {
    const currentYear = year + 1;
    const bufferCash = 5000000; // 5M buffer mínimo

    const totalCashNeed = capexThisYear + Math.max(0, -operatingCashFlow) + bufferCash;
    let remainingNeed = Math.max(0, totalCashNeed - startingCash);

    let sourcingPlan = {
        useExistingCash: Math.min(startingCash, totalCashNeed),
        newEquity: 0,
        newVentureDebt: 0,
        newCommercialDebt: 0
    };

    if (remainingNeed <= 0) return sourcingPlan;

    // Equity is assumed to be fully available as planned
    const plannedEquity = (plannedFinancingData[`partnerCapitalizationYear${currentYear}`] || 0) +
                          (plannedFinancingData[`seriesB_newInvestors_year${currentYear}`] || 0);
    if (plannedEquity > 0 && remainingNeed > 0) {
        const equityToUse = Math.min(plannedEquity, remainingNeed);
        sourcingPlan.newEquity = equityToUse;
        remainingNeed -= equityToUse;
    }

    // Planned Debt Drawdowns
    const plannedVentureDebt = plannedFinancingData[`ventureDebtYear${currentYear}`] || 0;
    const plannedCommercialDebt = plannedFinancingData[`commercialDebtYear${currentYear}`] || 0;
    
    // Use planned debt first
    if(plannedVentureDebt > 0 && remainingNeed > 0) {
        const debtToUse = Math.min(plannedVentureDebt, remainingNeed);
        sourcingPlan.newVentureDebt += debtToUse;
        remainingNeed -= debtToUse;
    }
    if(plannedCommercialDebt > 0 && remainingNeed > 0) {
        const debtToUse = Math.min(plannedCommercialDebt, remainingNeed);
        sourcingPlan.newCommercialDebt += debtToUse;
        remainingNeed -= debtToUse;
    }

    // Use additional debt from available lines if still needed, prioritizing cheaper debt if available
    if (remainingNeed > 0) {
        const totalVentureDebtUsed = debtCohorts.venture.reduce((sum, cohort) => sum + cohort.originalAmount, 0) + sourcingPlan.newVentureDebt;
        const ventureLineRemaining = modelData.ventureDebtLineAvailable - totalVentureDebtUsed;
        
        const totalCommercialDebtUsed = debtCohorts.commercial.reduce((sum, cohort) => sum + cohort.originalAmount, 0) + sourcingPlan.newCommercialDebt;
        const commercialLineRemaining = modelData.commercialDebtLineAvailable - totalCommercialDebtUsed;

        // CFO Logic: Use cheaper debt first if available
        if (modelData.commercialDebtRate < modelData.ventureDebtRate && commercialLineRemaining > 0) {
            const additionalCommercial = Math.min(remainingNeed, commercialLineRemaining);
            sourcingPlan.newCommercialDebt += additionalCommercial;
            remainingNeed -= additionalCommercial;
        }

        // Then use Venture Debt
        if (remainingNeed > 0 && ventureLineRemaining > 0) {
            const additionalVenture = Math.min(remainingNeed, ventureLineRemaining);
            sourcingPlan.newVentureDebt += additionalVenture;
            remainingNeed -= additionalVenture;
        }
        
        // Then use any remaining Commercial Debt
        if (remainingNeed > 0 && commercialLineRemaining > (sourcingPlan.newCommercialDebt - plannedCommercialDebt)) {
             const additionalCommercial = Math.min(remainingNeed, commercialLineRemaining - (sourcingPlan.newCommercialDebt - plannedCommercialDebt));
            sourcingPlan.newCommercialDebt += additionalCommercial;
            remainingNeed -= additionalCommercial;
        }
    }


    if (remainingNeed > 1000000) {
        log(`⚠️ FUNDING GAP Year ${currentYear}: ${formatCurrency(remainingNeed)} sin financiar. Revisar líneas de crédito o plan de unidades.`);
    }

    return sourcingPlan;
}

/**
* Allocates capital for a given year based on priority: Equity → Sinosure → Commercial → Venture.
* Enforces DSCR gating for commercial debt and throttles units if coverage is insufficient.
* @param {number} year - Calendar year (1-5)
* @param {number} remainingCapex - CAPEX to fund for the year
* @returns {{equity:number,sinosure:number,commercial:number,venture:number}}
*/
function allocateCapital(year, capexThisYear, capitalContext) {
    const draws = { equity: 0, sinosure: 0, bridge: 0, commercial: 0, venture: 0 };
    let remaining = capexThisYear;

    if (!capitalContext) {
        if (remaining > 0) draws.equity = remaining;
        return draws;
    }

    let headroom = Math.max(0, capitalContext.currentServiceHeadroom || 0);

    const computeServiceFactor = ({ rate = 0, amortizationPortion = 0, amortizationMonths = 0, balloonPortion = 0, termMonths = 0, graceMonths = 0 }) => {
        const interestFactor = rate > 0 ? rate / 100 : 0;
        const amortPortion = Math.max(0, Math.min(1, amortizationPortion));
        const amortMonthsTotal = Math.max(0, amortizationMonths);
        const graceAppliedThisYear = Math.max(0, Math.min(12, graceMonths || 0));
        const amortMonthsThisYear = Math.max(0, Math.min(12, 12 - graceAppliedThisYear));
        const amortizationFactor = amortMonthsTotal > 0 ? amortPortion * (amortMonthsThisYear / amortMonthsTotal) : 0;
        const balloonShare = Math.max(0, Math.min(1, balloonPortion));
        const termMonthsSafe = Math.max(0, termMonths);
        const balloonFactor = termMonthsSafe > 0 ? balloonShare * (12 / termMonthsSafe) : 0;
        return interestFactor + amortizationFactor + balloonFactor;
    };

    const applyHeadroomConsumption = (amount, serviceFactor) => {
        if (serviceFactor > 0 && amount > 0) {
            headroom = Math.max(0, headroom - amount * serviceFactor);
        }
    };

    const calculateHeadroomCapacity = (serviceFactor, fallback = 0) => {
        if (serviceFactor <= 0) return fallback;
        if (headroom <= 0) return 0;
        return headroom / serviceFactor;
    };

    // 1. Venture Debt (apalancamiento principal, consume headroom)
    if (remaining > 0 && capitalContext.ventureLineRemaining > 0 && modelData.ventureDebtRate > 0) {
        const ventureCap = capitalContext.ventureCapsRemaining[year - 1] ?? capitalContext.ventureLineRemaining;
        const ventureTermYears = modelData.periodoAmortizacionDeuda || 0;
        const ventureTermMonths = ventureTermYears > 0 ? ventureTermYears * 12 : 0;
        const ventureServiceFactor = computeServiceFactor({
            rate: modelData.ventureDebtRate,
            amortizationPortion: 1,
            amortizationMonths: ventureTermMonths,
            termMonths: ventureTermMonths,
            graceMonths: 0,
            balloonPortion: 0
        });
        const ventureHeadroomCapacity = calculateHeadroomCapacity(ventureServiceFactor, remaining);
        const ventureDraw = Math.max(0, Math.min(remaining, capitalContext.ventureLineRemaining, ventureCap, ventureHeadroomCapacity));
        if (ventureDraw > 0) {
            draws.venture = ventureDraw;
            remaining -= ventureDraw;
            applyHeadroomConsumption(ventureDraw, ventureServiceFactor);
        }
    }

    // 2. SINOSURE (si está disponible a partir de Y2, no consume headroom)
    if (modelData.sinosureAvailable && year >= (window.sinosureConfig?.availabilityStartYear || 2) && remaining > 0) {
        const productionCostPerUnit = (window.sinosureConfig?.productionCostUSD || 18250) * (window.sinosureConfig?.exchangeRate || 20);
        const sinosureLimit = modelData.unitsPerYear[year - 1] * productionCostPerUnit;
        const sinosureDraw = Math.max(0, Math.min(remaining, sinosureLimit));
        if (sinosureDraw > 0) {
            draws.sinosure = sinosureDraw;
            remaining -= sinosureDraw;
        }
    }

    // 3. Bridge / Warehousing (disponible desde Y2 si SINOSURE no está activo)
    const bridgeWindowActive = year >= (window.sinosureConfig?.availabilityStartYear || 2);
    if (!modelData.sinosureAvailable && bridgeWindowActive && remaining > 0 && capitalContext.bridgeLineRemaining > 0 && modelData.bridgeDebtRate > 0) {
        const bridgeGraceMonths = modelData.bridgeGraceMonths !== undefined ? modelData.bridgeGraceMonths : (modelData.commercialGraceMonths || 0);
        const bridgeTermMonths = modelData.bridgeLoanTermMonths !== undefined ? modelData.bridgeLoanTermMonths : (modelData.commercialLoanTermMonths || 60);
        const bridgeBalloonShare = (modelData.bridgeBalloonPercent !== undefined ? modelData.bridgeBalloonPercent : (modelData.commercialBalloonPercent || 0)) / 100;
        const amortMonths = Math.max(0, bridgeTermMonths - bridgeGraceMonths);
        const bridgeServiceFactor = computeServiceFactor({
            rate: modelData.bridgeDebtRate || modelData.ventureDebtRate,
            amortizationPortion: Math.max(0, 1 - bridgeBalloonShare),
            amortizationMonths: amortMonths,
            balloonPortion: bridgeBalloonShare,
            termMonths: bridgeTermMonths,
            graceMonths: bridgeGraceMonths
        });
        const bridgeHeadroomCapacity = calculateHeadroomCapacity(bridgeServiceFactor, remaining);
        const bridgeDraw = Math.max(0, Math.min(remaining, capitalContext.bridgeLineRemaining, bridgeHeadroomCapacity));
        if (bridgeDraw > 0) {
            draws.bridge = bridgeDraw;
            remaining -= bridgeDraw;
            applyHeadroomConsumption(bridgeDraw, bridgeServiceFactor);
        }
    }

    // 4. Deuda Comercial (consume headroom restante)
    if (remaining > 0 && capitalContext.commercialLineRemaining > 0 && modelData.commercialDebtRate > 0) {
        const commercialCap = capitalContext.commercialCapsRemaining[year - 1] ?? capitalContext.commercialLineRemaining;
        const commercialGrace = modelData.commercialGraceMonths || 0;
        const commercialTerm = modelData.commercialLoanTermMonths || 60;
        const commercialBalloonShare = (modelData.commercialBalloonPercent || 0) / 100;
        const amortMonths = Math.max(0, commercialTerm - commercialGrace);
        const commercialServiceFactor = computeServiceFactor({
            rate: modelData.commercialDebtRate,
            amortizationPortion: Math.max(0, 1 - commercialBalloonShare),
            amortizationMonths: amortMonths,
            balloonPortion: commercialBalloonShare,
            termMonths: commercialTerm,
            graceMonths: commercialGrace
        });
        const commercialHeadroomCapacity = calculateHeadroomCapacity(commercialServiceFactor, remaining);
        const commercialDraw = Math.max(0, Math.min(remaining, capitalContext.commercialLineRemaining, commercialCap, commercialHeadroomCapacity));
        if (commercialDraw > 0) {
            draws.commercial = commercialDraw;
            remaining -= commercialDraw;
            applyHeadroomConsumption(commercialDraw, commercialServiceFactor);
        }
    }

    headroom = Math.max(0, headroom);

    // 5. Equity Call (si aún falta capital)
    if (remaining > 0) {
        draws.equity = remaining;
        capitalContext.equityCalls[year - 1] += remaining;
        log(`📈 Equity call triggered in Y${year}: ${formatCurrency(remaining)} added to close funding gap.`);
        remaining = 0;
    }

    capitalContext.currentServiceHeadroom = headroom;
    return draws;
}

/**
* Calculates the final Debt Service Coverage Ratio.
* @returns {number} DSCR based on Year 5 EBITDA and total debt service.
*/
function calculateFinalDSCR() {
if (!financialResults.pl || financialResults.pl.length < 5) return null;

const year5EBITDA = financialResults.pl[4].ebitda;
const year5Interest = financialResults.pl[4].interestExpense;
const year5PrincipalRepayment = financialResults.cf[4].debtPrincipalRepayment;
const year5Balloon = financialResults.cf[4].balloonPayment;

const totalDebtService = (year5Interest || 0) + (year5PrincipalRepayment || 0) + (year5Balloon || 0);

return safeRatio(year5EBITDA, totalDebtService, null);
}
/**
* Calculates granular debt metrics for Serie A analysis.
* @returns {Object} Debt metrics breakdown.
*/
function calculateDebtMetricsBreakdown() {
const finalDSCR = calculateFinalDSCR();

return {
    finalDSCR,
    isHealthyDSCR: finalDSCR !== null && finalDSCR >= 1.5,
    riskLevel: finalDSCR === null ? 'n/a' : finalDSCR >= 2.0 ? 'low' : finalDSCR >= 1.5 ? 'medium' : 'high'
};
}

/**
* Calculates projected debt service coverage ratio.
* @returns {Object} DSCR analysis.
*/
function calculateDebtServiceCoverage() {
const totalVentureDebt = calculateTotalVentureDebtRaised();
const totalCommercialDebt = calculateTotalCommercialDebtRaised();
const totalBridgeDebt = calculateTotalBridgeDebtRaised();
const ventureInterest = totalVentureDebt * (modelData.ventureDebtRate / 100);
const commercialInterest = totalCommercialDebt * (modelData.commercialDebtRate / 100);
const bridgeInterest = totalBridgeDebt * ((modelData.bridgeDebtRate || modelData.commercialDebtRate) / 100);
const principalService = Array.isArray(financialResults.cf)
    ? financialResults.cf.reduce((sum, cf) => sum + Math.max(0, cf.debtPrincipalRepayment || 0), 0)
    : 0;
const balloonService = Array.isArray(financialResults.cf)
    ? financialResults.cf.reduce((sum, cf) => sum + Math.max(0, cf.balloonPayment || 0), 0)
    : 0;
const totalDebtService = ventureInterest + commercialInterest + bridgeInterest + principalService + balloonService;

const estimatedRevenue = totalFundingFromCF() * 0.8;
const estimatedEBITDA = estimatedRevenue * 0.25;

const dscr = safeRatio(estimatedEBITDA, totalDebtService, null);

return {
totalDebtService,
estimatedEBITDA,
dscr,
isHealthy: dscr !== null && dscr >= 1.5,
maxSafeVentureRate: totalVentureDebt > 0 ? (estimatedEBITDA * 0.2) / totalVentureDebt * 100 : 20,
maxSafeCommercialRate: totalCommercialDebt > 0 ? (estimatedEBITDA * 0.15) / totalCommercialDebt * 100 : 16,
maxSafeBridgeRate: totalBridgeDebt > 0 ? (estimatedEBITDA * 0.18) / totalBridgeDebt * 100 : (modelData.bridgeDebtRate || 16)
};
}
/**
* Evaluates unit economics health.
* @returns {Object} Unit economics analysis.
*/
function evaluateUnitEconomics() {
const totalPrice = getTotalPackagePrice();
const totalCost = getTotalPackageCost();
const margin = totalPrice - totalCost;
const marginPercent = totalPrice > 0 ? (margin / totalPrice) * 100 : 0;

return {
margin,
marginPercent,
isHealthy: marginPercent >= 15,
investorGrade: marginPercent >= 20 ? 'excellent' : marginPercent >= 15 ? 'good' : marginPercent >= 10 ? 'concerning' : 'critical'
};
}

function calculateSeriesAMetrics() {
    if (!financialResults.pl || financialResults.pl.length < 5) return {};

    const totalUnits = financialResults.pl.reduce((sum, pl) => sum + (pl.addedUnits || 0), 0);
    const totalCapex = totalUnits * getTotalPackageCost();
    const year5Index = financialResults.pl.length - 1;

    const capitalPerUnit = totalUnits > 0 ? totalCapex / totalUnits : 0;

    // --- NEW: Net Interest Margin (NIM) Calculation for Year 5 ---
    const year5PL = financialResults.pl[4];
    const year4BS = financialResults.bs[3];
    const year5BS = financialResults.bs[4];
    
    const interestRevenueY5 = year5PL.interestRevenue || 0;
    const interestExpenseY5 = year5PL.interestExpense || 0;
    
    const startOfYearReceivables = year4BS.receivables || 0;
    const endOfYearReceivables = year5BS.receivables || 0;
    const avgEarningAssets = (startOfYearReceivables + endOfYearReceivables) / 2;
    
    const netInterestIncome = interestRevenueY5 - interestExpenseY5;
    const netInterestMargin = avgEarningAssets > 0 ? (netInterestIncome / avgEarningAssets) * 100 : 0;

    const activePortfolioValue = financialResults.bs[year5Index]?.receivables || 0;

    const cumulativeRevenue = financialResults.pl.reduce((sum, pl) => sum + (pl.totalRevenue || 0), 0);
    const totalFunding = totalFundingFromCF();
    const fundingEfficiency = totalFunding > 0 ? cumulativeRevenue / totalFunding : 0;

    const currentCash = financialResults.bs[year5Index]?.cash || 0;
    const year5Opex = financialResults.pl[year5Index]?.opex || 0;
    const monthlyBurn = year5Opex > 0 ? year5Opex / 12 : 1;
    const cashRunwayMonths = currentCash / monthlyBurn;

    const year1Units = financialResults.pl[0]?.addedUnits || 1;
    const finalYearUnits = totalUnits;
    const unitCAGR = year1Units > 0 ? (Math.pow(finalYearUnits / year1Units, 1/5) - 1) * 100 : 0;

    return {
        capitalPerUnit: capitalPerUnit / 1000,
        netInterestMargin: Math.max(0, netInterestMargin),
        activePortfolioValue: activePortfolioValue,
        fundingEfficiency: fundingEfficiency,
        cashRunwayMonths: Math.min(Math.max(0, cashRunwayMonths), 999),
        unitCAGR: Math.max(0, unitCAGR),
        benchmarks: {
            capitalPerUnitGood: capitalPerUnit / 1000 <= 750,
            netInterestMarginGood: netInterestMargin >= 4,
            fundingEfficiencyGood: fundingEfficiency >= 0.6,
            cashRunwayGood: cashRunwayMonths >= 12,
            unitCAGRGood: unitCAGR >= 30
        }
    };
}
/**
* Calculates general investor score.
* @returns {Object} Investor health score.
*/
function calculateInvestorScore() {
    let issues = [];
    let score = 10;
    const debtMetrics = calculateDebtMetricsBreakdown();

    if (debtMetrics.finalDSCR !== null) {
        if (debtMetrics.finalDSCR < 1.2) {
            score -= 3;
            issues.push('🚨 DSCR crítico (<1.2x)');
        } else if (debtMetrics.finalDSCR < 1.5) {
            score -= 1.5;
            issues.push('⚠️ DSCR bajo (<1.5x)');
        }
    }
    
    if (financialResults.bs.length > 4 && financialResults.bs[4].equity > 0 && financialResults.bs[4].debt > financialResults.bs[4].equity * 2.5) {
        score -= 1;
        issues.push('📊 Leverage alto (Debt/Equity >2.5x)');
    }

    return {
        score: Math.max(0, score),
        grade: score >= 9 ? 'A' : score >= 7 ? 'B' : 'C',
        issues,
        isInvestable: score >= 7
    };
}
// ===== IFRS CALCULATION MODULES =====
// ===== IFRS CALCULATION MODULES =====
/**
* Calculates the Probability of Default (PD) based on the age of the loan cohort.
* IFRS 9: Aligns with the 3-stage model, with dynamic PDs.
* @param {number} cohortAgeYears - Age of the loan in years.
* @returns {number} The adjusted probability of default.
*/
function calculatePDBasedOnAge(cohortAgeYears) {
// Dynamic rule: PD increases 50% if loan > 2 years
let basePD;
if (cohortAgeYears <= 1) { // Young loans (Year 1) -> Stage 1
basePD = modelData.pdStage1; // 12-month PD
} else if (cohortAgeYears === 2) { // 2-year loans -> Stage 2
basePD = modelData.pdStage2; // Lifetime PD (for Stage 2)
} else { // 3-year or older loans -> Stage 3
basePD = modelData.pdStage3; // Lifetime PD (for Stage 3)
// Apply dynamic adjustment: increases 50% if loan > 2 years
if (cohortAgeYears > 2) {
basePD *= 1.5;
}
}
return basePD;
}
/**
* Calculates the Expected Credit Loss (ECL) according to IFRS 9.
* Process: Iterates over loan cohorts, calculates average exposure,
* applies dynamic PD and macroeconomic adjustment factor.
* @param {Array<Object>} loanCohorts - Array of active loan cohorts.
* @param {number} currentYear - The current projection year (1-5).
* @param {number} currentProvisionsBalance - Accumulated provision balance at the beginning of the year.
* @param {number} currentYearEndReceivables - Accounts receivable balance at the end of the current year.
* @returns {Object} Contains annual provision, accumulated balance, and details by stage.
*/
function calculateNIIF9ECL(loanCohorts, currentYear, currentProvisionsBalance, currentYearEndReceivables) {
const loanTermAdjustmentFactor = modelData.clientLoanTermYears === 4 ? 0.8 : 1.0;
const adjustedPDStage1 = modelData.pdStage1 * loanTermAdjustmentFactor;
const adjustedPDStage2 = modelData.pdStage2 * loanTermAdjustmentFactor;
log(`📊 NIIF 9 - Ajuste préstamos ${modelData.clientLoanTermYears} años: Factor ${loanTermAdjustmentFactor}`);
let totalECLForYear = 0;
let eclByStage = { stage1: 0, stage2: 0, stage3: 0 };

const totalExposure = loanCohorts.reduce((sum, cohort) => sum + cohort.avgExposureDuringYear, 0);

if (totalExposure > 0) {
const stage1Exposure = totalExposure * modelData.portfolioAllocationStage1;
const stage2Exposure = totalExposure * modelData.portfolioAllocationStage2;
const stage3Exposure = totalExposure * modelData.portfolioAllocationStage3;

eclByStage.stage1 = stage1Exposure * adjustedPDStage1 * modelData.lgd;
eclByStage.stage2 = stage2Exposure * adjustedPDStage2 * modelData.lgd;
eclByStage.stage3 = stage3Exposure * modelData.pdStage3 * modelData.lgd;
totalECLForYear = eclByStage.stage1 + eclByStage.stage2 + eclByStage.stage3;

log(`📊 NIIF 9 PORTFOLIO ALLOCATIONS - Año ${currentYear}:`);
log(`   Total exposure: ${formatCurrency(totalExposure)}`);
log(`   Stage 1 (${(modelData.portfolioAllocationStage1*100).toFixed(0)}%): ${formatCurrency(eclByStage.stage1)}`);
log(`   Stage 2 (${(modelData.portfolioAllocationStage2*100).toFixed(0)}%): ${formatCurrency(eclByStage.stage2)}`);
log(`   Stage 3 (${(modelData.portfolioAllocationStage3*100).toFixed(0)}%): ${formatCurrency(eclByStage.stage3)}`);
}

totalECLForYear *= modelData.economicAdjustmentFactor;
eclByStage.stage1 *= modelData.economicAdjustmentFactor;
eclByStage.stage2 *= modelData.economicAdjustmentFactor;
eclByStage.stage3 *= modelData.economicAdjustmentFactor;

const annualProvisionExpense = totalECLForYear * (modelData.proteccionRodando ? 0.5 : 1.0);

let newProvisionsBalance = currentProvisionsBalance + annualProvisionExpense;

const provisionesEsperadas = currentYearEndReceivables * (adjustedPDStage1 * modelData.portfolioAllocationStage1 +
adjustedPDStage2 * modelData.portfolioAllocationStage2 +
modelData.pdStage3 * modelData.portfolioAllocationStage3) * modelData.lgd * modelData.economicAdjustmentFactor;

if (Math.abs(newProvisionsBalance - provisionesEsperadas) > 10000) {
log("IFRS 9 provisions adjustment applied for consistency");
newProvisionsBalance = provisionesEsperadas;
}

return {
annualProvisionExpense: annualProvisionExpense,
newProvisionsBalance: newProvisionsBalance,
totalECLBeforeAdjustment: totalECLForYear,
eclByStage: eclByStage
};
}
/**
* Conceptually validates if a performance obligation is met to recognize revenue under IFRS 15.
* @param {Object} cohort - The loan cohort to validate.
* @returns {boolean} True if revenue can be recognized.
*/
function validatePerformanceObligation(cohort) {
// A simple but effective check: revenue is earned as the service (loan) is provided.
// This is true if payments have started and the principal has been reduced.
const isServiceBeingProvided = cohort.paymentsMadeMonths > 0 && cohort.remainingPrincipal < cohort.originalPrincipal;
if (!isServiceBeingProvided) {
log(`NIIF 15 - Obligación de desempeño para la cohorte del año ${cohort.yearOriginated} aún no satisfecha. No se reconocen ingresos.`);
}
return isServiceBeingProvided;
}
/**
* Calculates contract revenue and liabilities according to IFRS 15.
* @param {Array<Object>} loanCohorts - Array of active loan cohorts.
* @param {Array<Object>} fixedAssetsCohorts - Array of active fixed asset (van) cohorts.
* @param {number} addedUnitsThisYear - New units added in the current year.
* @param {number} currentYear - The current projection year (1-5).
* @returns {Object} Contains recognized revenue and contract liability balance.
*/
function calculateNIIF15Revenue(loanCohorts, fixedAssetsCohorts, addedUnitsThisYear, currentYear) {
let annualOriginationCommissionRecognized = 0;
let totalContractLiabilitiesBalance = 0;
loanCohorts.forEach(cohort => {
//           ✅           CORREGIDO: Added IFRS 15 validation for performance obligation.
if (validatePerformanceObligation(cohort)) {
let monthlyInterestRateClient = cohort.monthlyInterestRate;
const totalPaymentsMonthsClient = modelData.clientLoanTermYears * 12;
log(`📋 NIIF 15 - Amortización comisiones en ${totalPaymentsMonthsClient} meses (${modelData.clientLoanTermYears} años)`);
let currentRemainingPrincipal = cohort.startOfYearPrincipal;
let initialPrincipal = cohort.originalPrincipal;
let recognizedOriginationFromPrincipal = 0;
let recognizedUpfrontCommission = 0;
for (let m = 0; m < 12; m++) {
if (currentRemainingPrincipal <= 0 || cohort.paymentsMadeMonths + m >= totalPaymentsMonthsClient) {
break;
}
const interestThisMonth = currentRemainingPrincipal * monthlyInterestRateClient;
let principalThisMonth = cohort.monthlyPayment - interestThisMonth;
principalThisMonth = Math.min(principalThisMonth, currentRemainingPrincipal);
currentRemainingPrincipal -= principalThisMonth;

if (initialPrincipal > 0) {
const recognitionRatioThisMonth = principalThisMonth / initialPrincipal;
const recognizedByPrincipal = cohort.originationCommissionInitial * recognitionRatioThisMonth;
recognizedOriginationFromPrincipal += Math.min(recognizedByPrincipal, cohort.remainingOriginationCommission);
}

if (cohort.originalUpfrontLiability > 0) {
const monthlyUpfrontAmortization = cohort.originalUpfrontLiability / totalPaymentsMonthsClient;
recognizedUpfrontCommission += Math.min(monthlyUpfrontAmortization, cohort.remainingUpfrontLiability);
}
}

const actualRecognizedOrigination = Math.min(recognizedOriginationFromPrincipal, cohort.remainingOriginationCommission);
const actualRecognizedUpfront = Math.min(recognizedUpfrontCommission, cohort.remainingUpfrontLiability);
annualOriginationCommissionRecognized += (actualRecognizedOrigination + actualRecognizedUpfront);
cohort.remainingOriginationCommission = Math.max(0, cohort.remainingOriginationCommission - actualRecognizedOrigination);
cohort.remainingUpfrontLiability = Math.max(0, cohort.remainingUpfrontLiability - actualRecognizedUpfront);
}

totalContractLiabilitiesBalance += cohort.remainingOriginationCommission || 0;
totalContractLiabilitiesBalance += cohort.remainingUpfrontLiability || 0;
});

const totalActiveUnits = fixedAssetsCohorts.reduce((sum, cohort) => sum + cohort.units, 0);
const gnvCommissions = totalActiveUnits * modelData.litrosPromedioMensualPorUnidad * 12 * modelData.precioLitroGNV * (modelData.comisionGNVPorcentaje / 100);

const sparePartsCost = addedUnitsThisYear * modelData.refaccionesCostPerUnit;
const sparePartsRevenue = sparePartsCost * (1 + modelData.margenRefacciones / 100);

const marketplaceRevenue = totalActiveUnits * modelData.gmvPromedioMensualPorUnidad * 12 * (modelData.takeRateMarketplace / 100);

return {
recognizedOriginationRevenue: annualOriginationCommissionRecognized,
gnvCommissions: gnvCommissions,
sparePartsRevenue: sparePartsRevenue,
sparePartsCOGS: sparePartsCost,
marketplaceRevenue: marketplaceRevenue,
contractLiabilitiesBalance: totalContractLiabilitiesBalance,
// Pass these through for niifDetails
originationContractValueInitial: loanCohorts.filter(c => c.yearOriginated === currentYear).reduce((sum, c) => sum + (c.originationCommissionInitial || 0), 0),
upfrontCommissionInitial: loanCohorts.filter(c => c.yearOriginated === currentYear).reduce((sum, c) => sum + (c.originalUpfrontLiability || 0), 0),
};
}
/**
* Conceptually validates if an asset qualifies to be classified as Held for Sale under IFRS 5.
* @param {Object} asset - The asset cohort to validate.
* @returns {boolean} True if the asset qualifies.
*/
function qualifiesForHeldForSale(asset) {
// In a real-world scenario, these would be properties of the asset.
// For this model, we assume all repossessed assets meet the criteria.
const managementCommittedToSell = true;
const availableForImmediateSale = true;
const saleHighlyProbableWithin12Months = true;
const qualifies = managementCommittedToSell && availableForImmediateSale && saleHighlyProbableWithin12Months;
if (!qualifies) {
log(`NIIF 5 - Activo de la cohorte ${asset.yearAcquired} no califica para ser Mantenido para la Venta.`);
}
return qualifies;
}
/**
* Manages assets held for sale (IFRS 5).
* @param {Array<Object>} fixedAssetsCohorts - Array of fixed asset cohorts (will be modified).
* @param {Array<Object>} heldForSaleAssets - Global array of IFRS 5 assets (will be modified).
* @param {number} currentYear - The current projection year (1-5).
* @returns {Object} Contains this year's impairment loss and reclassification details.
*/
function manageNIIF5Assets(fixedAssetsCohorts, heldForSaleAssets, currentYear) {
let totalImpairmentThisYear = 0;
const totalOperationalUnits = fixedAssetsCohorts.reduce((sum, c) => sum + c.units, 0);
let unitsToRepossess = Math.round(totalOperationalUnits * (modelData.tasaReposicion / 100));
let remainingUnitsToRepossess = unitsToRepossess;

let valueOfAssetsReclassifiedToNIIF5ThisYearOriginalCarryingAmount = 0;
let valueOfAssetsReclassifiedToNIIF5ThisYearFairValue = 0;
let valueOfAssetsReclassifiedToNIIF5ThisYearCostsToSell = 0;
let valueOfAssetsReclassifiedToNIIF5ThisYearNetFairValue = 0;

fixedAssetsCohorts.sort((a, b) => a.yearAcquired - b.yearAcquired);

for (let i = 0; i < fixedAssetsCohorts.length && remainingUnitsToRepossess > 0; i++) {
let cohort = fixedAssetsCohorts[i];
//           ✅           CORREGIDO: Added IFRS 5 validation.
if (cohort.units > 0 && qualifiesForHeldForSale(cohort)) {
const actualUnitsToRepossessFromThisCohort = Math.min(remainingUnitsToRepossess, cohort.units);
if (actualUnitsToRepossessFromThisCohort > 0) {
const proportionToRepossess = actualUnitsToRepossessFromThisCohort / cohort.units;
const repossessedOriginalCost = cohort.totalOriginalCost * proportionToRepossess;
const repossessedAccumulatedDepreciation = cohort.accumulatedDepreciation * proportionToRepossess;
const repossessedCarryingAmount = repossessedOriginalCost - repossessedAccumulatedDepreciation;

const repossessedFairValue = repossessedOriginalCost * (modelData.fairValueVenta / 100);
const repossessedCostsToSell = repossessedFairValue * (modelData.costosVenta / 100);
const repossessedFairValueLessCosts = repossessedFairValue - repossessedCostsToSell;

const impairmentForRepossessed = Math.max(0, repossessedCarryingAmount - repossessedFairValueLessCosts);
totalImpairmentThisYear += impairmentForRepossessed;

cohort.units -= actualUnitsToRepossessFromThisCohort;
cohort.totalOriginalCost -= repossessedOriginalCost;
cohort.accumulatedDepreciation -= repossessedAccumulatedDepreciation;

heldForSaleAssets.push({
units: actualUnitsToRepossessFromThisCohort,
originalCost: repossessedOriginalCost,
accumulatedDepreciation: repossessedAccumulatedDepreciation,
carryingAmountAtHFS: repossessedCarryingAmount,
currentFairValueLessCosts: repossessedFairValueLessCosts,
heldForSaleYear: currentYear,
impairmentRecorded: impairmentForRepossessed
});
remainingUnitsToRepossess -= actualUnitsToRepossessFromThisCohort;

valueOfAssetsReclassifiedToNIIF5ThisYearOriginalCarryingAmount += repossessedCarryingAmount;
valueOfAssetsReclassifiedToNIIF5ThisYearFairValue += repossessedFairValue;
valueOfAssetsReclassifiedToNIIF5ThisYearCostsToSell += repossessedCostsToSell;
valueOfAssetsReclassifiedToNIIF5ThisYearNetFairValue += repossessedFairValueLessCosts;
}
}
}

fixedAssetsCohorts = fixedAssetsCohorts.filter(c => c.units > 0);

const totalUnitsAccumulatedHeldForSale = heldForSaleAssets.reduce((sum, asset) => sum + asset.units, 0);
const assetsHeldForSaleNet = heldForSaleAssets.reduce((sum, asset) => sum + asset.currentFairValueLessCosts, 0);
return {
impairmentExpense: totalImpairmentThisYear,
niif5Details: {
unidadesClasificadasAnuales: unitsToRepossess - remainingUnitsToRepossess,
valorEnLibrosClasificado: valueOfAssetsReclassifiedToNIIF5ThisYearOriginalCarryingAmount,
valorRazonable: valueOfAssetsReclassifiedToNIIF5ThisYearFairValue,
costosDeVenta: valueOfAssetsReclassifiedToNIIF5ThisYearCostsToSell,
valorRazonableMenosCostos: valueOfAssetsReclassifiedToNIIF5ThisYearNetFairValue,
perdidaPorDeterioro: totalImpairmentThisYear,
saldoActivosParaVentaAcumulado: assetsHeldForSaleNet,
totalUnitsAccumulatedHeldForSale: totalUnitsAccumulatedHeldForSale
},
updatedFixedAssetsCohorts: fixedAssetsCohorts,
updatedHeldForSaleAssets: heldForSaleAssets
};
}
/**
* Calculates a time-weighted average for balances,
* considering capital events that occur during the year.
* @param {number} startBalance - Balance at the beginning of the year.
* @param {number} endBalance - Balance at the end of the year.
* @param {Array<Object>} capitalEvents - Array of objects { month: number, amount: number }.
* @returns {number} The time-weighted average.
*/
function calculateTimeWeightedAverage(startBalance, endBalance, capitalEvents = []) {
if (!capitalEvents.length || capitalEvents.length === 0) {
// If no events, fall back to simple average for consistency
return (startBalance + endBalance) / 2;
}

let weightedSum = 0;
let totalMonths = 12;
capitalEvents.sort((a, b) => a.month - b.month);
let currentBalance = startBalance;
let lastMonth = 0;

capitalEvents.forEach(event => {
const monthsInPeriod = event.month - lastMonth;
if (monthsInPeriod > 0) {
weightedSum += currentBalance * monthsInPeriod;
}
currentBalance += event.amount;
lastMonth = event.month;
});

if (lastMonth < 12) {
weightedSum += currentBalance * (12 - lastMonth);
}

return weightedSum / totalMonths;
}
/**
* Performs the annual calculation of fixed asset depreciation.
* IFRS 6: Do not depreciate in the year of acquisition. Adjust depreciable base for impairment.
* @param {Array<Object>} fixedAssetsCohorts - Fixed asset cohorts.
* @param {number} currentYear - Current projection year.
* @returns {number} Total annual depreciation amount.
*/
function calculateAnnualDepreciation(fixedAssetsCohorts, currentYear) {
let annualDepreciation = 0;
fixedAssetsCohorts.forEach(cohort => {
const yearsHeld = currentYear - cohort.yearAcquired;

if (yearsHeld > 0 && modelData.depreciationYears > 0) {
const depreciationRate = 1 / modelData.depreciationYears;
const maxDepreciationPossible = cohort.totalOriginalCost - cohort.accumulatedDepreciation;
const depreciationThisYear = Math.min(cohort.totalOriginalCost * depreciationRate, maxDepreciationPossible);

cohort.accumulatedDepreciation += depreciationThisYear;
annualDepreciation += depreciationThisYear;
}
});
return annualDepreciation;
}

/**
* Central function to calculate all financial statements of the model.
* Process: Iterates year by year, calculating revenues, expenses, flows, and balances,
* integrating IFRS logic and validations.
* @returns {boolean} True if the calculation was successful, false if there was a critical error (e.g., unbalanced balance sheet).
*/
function calculateFinancials() {
log('🚀 calculateFinancials (v-STABLE) INICIANDO');
try {
    // --- This block ensures a clean start and correct initial capital ---
    hardResetEngine(); // Hard reset to prevent state leakage
    injectInitialEquity(); // Inject Seed + Serie A into CF Year 0

    const initialEquity = (modelData.seed || 0) + (modelData.seriesA || 0);
    let cash = initialEquity;
    let endOfYearEquity = initialEquity;
    let currentProvisionsBalance = 0;
    let insurancePassThroughBalance = 0;
    
    let loanCohorts = [], fixedAssetsCohorts = [], ventureDebtCohorts = [], commercialDebtCohorts = [], bridgeDebtCohorts = [], sinosureCohorts = [];
    let equityCashFlows = [-initialEquity], projectCashFlows = [-initialEquity], portfolioCashFlows = [];
    
    log(`💡 Initial Equity Correctly Set: ${formatCurrency(initialEquity)}`);

    heldForSaleAssets = [];
    debtOptimizationHistory = [];

    let ventureDebtBalance = 0;
    let commercialDebtBalance = 0;
    let bridgeDebtBalance = 0;

    const capitalContext = {
        ventureCapsRemaining: [...VENTURE_DEBT_CAPS],
        commercialCapsRemaining: [...COMMERCIAL_DEBT_CAPS],
        ventureLineRemaining: modelData.ventureDebtLineAvailable || 0,
        commercialLineRemaining: modelData.commercialDebtLineAvailable || 0,
        bridgeLineRemaining: modelData.bridgeDebtLineAvailable || 0,
        sinosureDrawnByYear: [0, 0, 0, 0, 0],
        bridgeDrawnByYear: [0, 0, 0, 0, 0],
        equityCalls: [0, 0, 0, 0, 0],
        dscrTarget: (modelData.targetDSCR && modelData.targetDSCR > 0) ? modelData.targetDSCR : 1.5,
        serviceMaxByYear: [0, 0, 0, 0, 0],
        serviceCommittedByYear: [0, 0, 0, 0, 0],
        serviceHeadroomAvailableByYear: [0, 0, 0, 0, 0],
        serviceHeadroomRemainingByYear: [0, 0, 0, 0, 0],
        currentServiceHeadroom: 0
    };
// --- Main annual loop (5 years) ---
for (let year = 0; year < 5; year++) {
const currentYear = year + 1;
log(`\n--- Calculating Year ${currentYear} ---`);
log(`💰 Comercial Params: Grace ${modelData.commercialGraceMonths}m | Term ${modelData.commercialLoanTermMonths}m | Balloon ${modelData.commercialBalloonPercent}%`);

const startOfYearCash = cash;
const startOfYearEquity = endOfYearEquity;
const startOfYearVentureDebt = ventureDebtBalance;
const startOfYearCommercialDebt = commercialDebtBalance;
const startOfYearBridgeDebt = bridgeDebtBalance;

loanCohorts.forEach(cohort => { cohort.startOfYearPrincipal = cohort.remainingPrincipal; });

const addedUnits = modelData.unitsPerYear[year];
        const capexThisYear = addedUnits * getTotalPackageCost();
        const ebitdaEstimate = calculateProjectedEBITDA(currentYear);

        // Auto-equity injection for DSCR maintenance
        if (addedUnits > 0) {
            const capitalOptimization = validateAndOptimizeCapitalStructure(currentYear, capexThisYear, ebitdaEstimate);
        }

        if (addedUnits > 0) {
            fixedAssetsCohorts.push({ yearAcquired: currentYear, units: addedUnits, totalOriginalCost: capexThisYear, accumulatedDepreciation: 0 });
        }

const niif5Results = manageNIIF5Assets(fixedAssetsCohorts, heldForSaleAssets, currentYear);
fixedAssetsCohorts = niif5Results.updatedFixedAssetsCohorts;
heldForSaleAssets = niif5Results.updatedHeldForSaleAssets;
const impairment = niif5Results.impairmentExpense;

const annualDepreciation = calculateAnnualDepreciation(fixedAssetsCohorts, currentYear);

let netLoanPrincipal = 0;
let insurancePassThroughOutflow = 0;
if (addedUnits > 0) {
    const corePackagePrice = getTotalPackagePrice();
    const insurancePackagePrice = getInsuranceTotalPrice();

    const totalCoreTicket = addedUnits * corePackagePrice;
    const totalInsuranceTicket = addedUnits * insurancePackagePrice;
    const totalGrossTicket = totalCoreTicket + totalInsuranceTicket;

    const downPaymentReceived = totalGrossTicket * (modelData.downPaymentPercentage / 100);
    const downPaymentShareCore = downPaymentReceived * safeRatio(totalCoreTicket, totalGrossTicket, 0);
    const downPaymentShareInsurance = downPaymentReceived - downPaymentShareCore;

    const financedCorePrincipal = Math.max(0, totalCoreTicket - downPaymentShareCore);
    const financedInsurancePrincipal = Math.max(0, totalInsuranceTicket - downPaymentShareInsurance);

    netLoanPrincipal = financedCorePrincipal + financedInsurancePrincipal;
    insurancePassThroughOutflow = totalInsuranceTicket;
    insurancePassThroughBalance += financedInsurancePrincipal;

    const monthlyInterestRateClient = (modelData.tasaInteres / 100) / 12;
    const totalPaymentsMonthsClient = modelData.clientLoanTermYears * 12;
    const monthlyPaymentClient = netLoanPrincipal > 0
        ? netLoanPrincipal * (monthlyInterestRateClient / (1 - Math.pow(1 + monthlyInterestRateClient, -totalPaymentsMonthsClient)))
        : 0;
    const originationCommissionForThisCohort = financedCorePrincipal * (modelData.margenVagoneta / 100);
    const upfrontCommissionReceived = totalGrossTicket * (modelData.upfrontCommissionPercentage / 100);
    loanCohorts.push({
        yearOriginated: currentYear,
        originalPrincipal: netLoanPrincipal,
        remainingPrincipal: netLoanPrincipal,
        startOfYearPrincipal: netLoanPrincipal,
        paymentsMadeMonths: 0,
        monthlyPayment: monthlyPaymentClient,
        monthlyInterestRate: monthlyInterestRateClient,
        totalLoanTermMonths: totalPaymentsMonthsClient,
        originationCommissionInitial: originationCommissionForThisCohort,
        remainingOriginationCommission: originationCommissionForThisCohort,
        originalUpfrontLiability: upfrontCommissionReceived,
        remainingUpfrontLiability: upfrontCommissionReceived,
        avgExposureDuringYear: 0,
        insuranceComponent: financedInsurancePrincipal,
        insuranceRemaining: financedInsurancePrincipal
    });
}

let annualInterestReceived = 0;
let annualPrincipalReceived = 0;
let currentYearEndReceivables = 0;
loanCohorts.forEach(cohort => {
let principal = cohort.startOfYearPrincipal;
cohort.avgExposureDuringYear = principal;
for (let m=0; m < 12; m++) {
if (cohort.paymentsMadeMonths >= cohort.totalLoanTermMonths) break;
const interest = principal * cohort.monthlyInterestRate;
const principalPayment = cohort.monthlyPayment - interest;
annualInterestReceived += interest;
annualPrincipalReceived += principalPayment;
const insuranceOutstanding = cohort.insuranceRemaining || 0;
const insuranceAllocation = insuranceOutstanding > 0 && principal > 0
    ? Math.min(insuranceOutstanding, principalPayment * safeRatio(insuranceOutstanding, principal, 0))
    : 0;
if (insuranceAllocation > 0) {
    cohort.insuranceRemaining = Math.max(0, insuranceOutstanding - insuranceAllocation);
    insurancePassThroughBalance = Math.max(0, insurancePassThroughBalance - insuranceAllocation);
}
principal -= principalPayment;
cohort.paymentsMadeMonths++;
}
cohort.remainingPrincipal = Math.max(0, principal);
currentYearEndReceivables += cohort.remainingPrincipal;
});

insurancePassThroughBalance = Math.max(0, insurancePassThroughBalance);

const niif9Results = calculateNIIF9ECL(loanCohorts, currentYear, currentProvisionsBalance, currentYearEndReceivables);
const provisions = niif9Results.annualProvisionExpense;
currentProvisionsBalance = niif9Results.newProvisionsBalance;

const niif15Results = calculateNIIF15Revenue(loanCohorts, fixedAssetsCohorts, addedUnits, currentYear);

const totalActiveUnits = fixedAssetsCohorts.reduce((sum, c) => sum + c.units, 0);
const gnvCommissions = totalActiveUnits * modelData.litrosPromedioMensualPorUnidad * 12 * modelData.precioLitroGNV * (modelData.comisionGNVPorcentaje / 100);
const sparePartsRevenue = addedUnits * modelData.refaccionesCostPerUnit * (1 + modelData.margenRefacciones / 100);
const sparePartsCOGS = addedUnits * modelData.refaccionesCostPerUnit;
const marketplaceRevenue = totalActiveUnits * modelData.gmvPromedioMensualPorUnidad * 12 * (modelData.takeRateMarketplace / 100);
const totalRevenue = annualInterestReceived + niif15Results.recognizedOriginationRevenue + gnvCommissions + sparePartsRevenue + marketplaceRevenue;
const opex = totalRevenue * (modelData.opexRates[year] / 100);

        const ventureDebtInterest = startOfYearVentureDebt * (modelData.ventureDebtRate / 100);
        // --- Comercial Debt Schedule (paramétrico) ---
        let commercialDebtInterest = 0;
        let scheduledCommercialPrincipalThisYear = 0;
        const grace = modelData.commercialGraceMonths || 0;
        const term = modelData.commercialLoanTermMonths || 60;
        const balloon = (modelData.commercialBalloonPercent || 0) / 100;
        const monthlyRateCommercial = (modelData.commercialDebtRate / 12) / 100;

        // Track balloon principal separately for financing classification
        let balloonPrincipalThisYear = 0;
        commercialDebtCohorts.forEach(cohort => {
            if (currentYear >= cohort.yearOriginated) {
                if (cohort.paymentsMadeMonths === undefined) cohort.paymentsMadeMonths = 0;
                if (cohort.remainingPrincipal === undefined) cohort.remainingPrincipal = cohort.originalAmount;

                const amortizationMonths = Math.max(0, term - grace - 1);
                const principalPerMonth = amortizationMonths > 0 ? cohort.originalAmount * (1 - balloon) / amortizationMonths : 0;

                for (let m = 1; m <= 12; m++) {
                    const monthIndex = cohort.paymentsMadeMonths + 1;
                    if (monthIndex > term) break;

                    // Interest for this month
                    commercialDebtInterest += cohort.remainingPrincipal * monthlyRateCommercial;

                    // Principal logic
                    if (monthIndex > grace && monthIndex < term) {
                        const principalPayment = Math.min(principalPerMonth, cohort.remainingPrincipal);
                        scheduledCommercialPrincipalThisYear += principalPayment;
                        cohort.remainingPrincipal -= principalPayment;
                    } else if (monthIndex === term) {
                        const balloonPayment = cohort.remainingPrincipal;
                        scheduledCommercialPrincipalThisYear += balloonPayment;
                        balloonPrincipalThisYear += balloonPayment; // capture balloon as financing outflow later
                        cohort.remainingPrincipal = 0;
                    }

                    cohort.paymentsMadeMonths++;
                }
            }
        });
        
        // Bridge Debt Schedule (cuando SINOSURE no esté disponible)
        let bridgeDebtInterest = 0;
        let scheduledBridgePrincipalThisYear = 0;
        let bridgeBalloonPrincipalThisYear = 0;
        const bridgeGrace = modelData.bridgeGraceMonths !== undefined ? modelData.bridgeGraceMonths : (modelData.commercialGraceMonths || 0);
        const bridgeTerm = modelData.bridgeLoanTermMonths !== undefined ? modelData.bridgeLoanTermMonths : (modelData.commercialLoanTermMonths || 60);
        const bridgeBalloon = (modelData.bridgeBalloonPercent !== undefined ? modelData.bridgeBalloonPercent : (modelData.commercialBalloonPercent || 0)) / 100;
        const monthlyRateBridge = (modelData.bridgeDebtRate || modelData.ventureDebtRate) / 1200;

        bridgeDebtCohorts.forEach(cohort => {
            if (currentYear >= cohort.yearOriginated) {
                if (cohort.paymentsMadeMonths === undefined) cohort.paymentsMadeMonths = 0;
                if (cohort.remainingPrincipal === undefined) cohort.remainingPrincipal = cohort.originalAmount;

                const amortizationMonths = Math.max(0, bridgeTerm - bridgeGrace - 1);
                const principalPerMonth = amortizationMonths > 0 ? cohort.originalAmount * (1 - bridgeBalloon) / amortizationMonths : 0;

                for (let m = 1; m <= 12; m++) {
                    const monthIndex = cohort.paymentsMadeMonths + 1;
                    if (monthIndex > bridgeTerm) break;

                    bridgeDebtInterest += cohort.remainingPrincipal * monthlyRateBridge;

                    if (monthIndex > bridgeGrace && monthIndex < bridgeTerm) {
                        const principalPayment = Math.min(principalPerMonth, cohort.remainingPrincipal);
                        scheduledBridgePrincipalThisYear += principalPayment;
                        cohort.remainingPrincipal -= principalPayment;
                    } else if (monthIndex === bridgeTerm) {
                        const balloonPayment = cohort.remainingPrincipal;
                        scheduledBridgePrincipalThisYear += balloonPayment;
                        bridgeBalloonPrincipalThisYear += balloonPayment;
                        cohort.remainingPrincipal = 0;
                    }

                    cohort.paymentsMadeMonths++;
                }
            }
        });

        // SINOSURE interest expense
        let sinosureInterest = 0;
        const startOfYearSinosureBalance = getSinosureBalance(currentYear - 1, sinosureCohorts);
        sinosureCohorts.forEach(cohort => {
            const yearsPassed = currentYear - cohort.yearOriginated;
            if (yearsPassed >= 0) {
                const remainingBalance = cohort.originalAmount - 
                                       (cohort.originalAmount / modelData.periodoAmortizacionDeuda * yearsPassed);
                sinosureInterest += Math.max(0, remainingBalance) * (cohort.rate / 100);
            }
        });
        
        const interestExpense = ventureDebtInterest + commercialDebtInterest + bridgeDebtInterest + sinosureInterest;

        if (sinosureInterest > 0 || bridgeDebtInterest > 0) {
            log(`💸 Interest Expense Year ${currentYear}: VD=${formatCurrency(ventureDebtInterest)}, Bridge=${formatCurrency(bridgeDebtInterest)}, CD=${formatCurrency(commercialDebtInterest)}, SINOSURE=${formatCurrency(sinosureInterest)}, Total=${formatCurrency(interestExpense)}`);
        }

let ventureDebtPrincipalRepayment = 0;
ventureDebtCohorts.forEach(cohort => {
if (currentYear >= cohort.yearOriginated) {
ventureDebtPrincipalRepayment += cohort.originalAmount / modelData.periodoAmortizacionDeuda;
}
});
        let commercialDebtPrincipalRepayment = scheduledCommercialPrincipalThisYear;
        let bridgeDebtPrincipalRepayment = scheduledBridgePrincipalThisYear;
        
        // SINOSURE principal repayment
        let sinosurePrincipalRepayment = 0;
        sinosureCohorts.forEach(cohort => {
            if (currentYear >= cohort.yearOriginated) {
                sinosurePrincipalRepayment += cohort.originalAmount / modelData.periodoAmortizacionDeuda;
            }
        });
        
        const totalDebtPrincipalRepayment = ventureDebtPrincipalRepayment + commercialDebtPrincipalRepayment + bridgeDebtPrincipalRepayment + sinosurePrincipalRepayment;

        const committedDebtService = ventureDebtInterest + commercialDebtInterest + bridgeDebtInterest + sinosureInterest + totalDebtPrincipalRepayment + bridgeBalloonPrincipalThisYear;
        const serviceMax = ebitdaEstimate > 0 ? ebitdaEstimate / (capitalContext.dscrTarget || 1.5) : 0;
        const serviceHeadroom = Math.max(0, serviceMax - committedDebtService);
        capitalContext.serviceMaxByYear[currentYear - 1] = serviceMax;
        capitalContext.serviceCommittedByYear[currentYear - 1] = committedDebtService;
        capitalContext.serviceHeadroomAvailableByYear[currentYear - 1] = serviceHeadroom;
        capitalContext.currentServiceHeadroom = serviceHeadroom;

const ebitda = totalRevenue - sparePartsCOGS - opex - provisions - impairment;
const ebit = ebitda - annualDepreciation;
const earningsBeforeTax = ebit - interestExpense;
const incomeTaxExpense = Math.max(0, earningsBeforeTax) * (modelData.corporateTaxRate / 100);
const netIncome = earningsBeforeTax - incomeTaxExpense;

// --- PRE-FINANCING CASH FLOW CALCULATION ---
let techInvestmentThisYear = 0;
if (currentYear === 1 || currentYear === 2) {
    techInvestmentThisYear = 6875000;
}
const deltaReceivables = currentYearEndReceivables - ((financialResults.bs[year-1]?.receivables) || 0);
const deltaProvisions = currentProvisionsBalance - ((financialResults.bs[year-1]?.provisions) || 0);
const deltaContractLiabilities = niif15Results.contractLiabilitiesBalance - ((financialResults.bs[year-1]?.contractLiabilities) || 0);
const priorInsuranceLiability = (financialResults.bs[year-1]?.insurancePassThroughLiability) || 0;
const deltaInsuranceLiability = insurancePassThroughBalance - priorInsuranceLiability;
let operatingCash = netIncome + annualDepreciation + impairment + deltaProvisions + deltaContractLiabilities + deltaInsuranceLiability - deltaReceivables;

        if (insurancePassThroughOutflow > 0) {
            log(`🛡️ Insurance pass-through Y${currentYear}: ${formatCurrency(insurancePassThroughOutflow)} (sin impacto neto en caja)`);
        }

        // --- CORRECTED: Capital Allocation draws are now the Single Source of Truth ---
        const draws = allocateCapital(currentYear, capexThisYear, capitalContext);
        log(`💰 Funding Mix Y${currentYear}: Eq=${formatCurrency(draws.equity)}, Snsr=${formatCurrency(draws.sinosure)}, Bridge=${formatCurrency(draws.bridge)}, Com=${formatCurrency(draws.commercial)}, Vent=${formatCurrency(draws.venture)}`);

        capitalContext.serviceHeadroomRemainingByYear[currentYear - 1] = capitalContext.currentServiceHeadroom;

        const finalNewEquityInjections = draws.equity;
        const finalNewVentureDebt = draws.venture;
        const finalNewBridgeDebt = draws.bridge;
        const finalNewCommercialDebt = draws.commercial;
        const sinosureDrawdowns = draws.sinosure;

        if (finalNewVentureDebt > 0) {
            ventureDebtCohorts.push({ yearOriginated: currentYear, originalAmount: finalNewVentureDebt });
            capitalContext.ventureLineRemaining = Math.max(0, capitalContext.ventureLineRemaining - finalNewVentureDebt);
            if (capitalContext.ventureCapsRemaining[currentYear - 1] !== undefined) {
                capitalContext.ventureCapsRemaining[currentYear - 1] = Math.max(0, capitalContext.ventureCapsRemaining[currentYear - 1] - finalNewVentureDebt);
            }
        }
        if (finalNewBridgeDebt > 0) {
            bridgeDebtCohorts.push({ yearOriginated: currentYear, originalAmount: finalNewBridgeDebt });
            capitalContext.bridgeLineRemaining = Math.max(0, capitalContext.bridgeLineRemaining - finalNewBridgeDebt);
            if (Array.isArray(capitalContext.bridgeDrawnByYear)) {
                capitalContext.bridgeDrawnByYear[currentYear - 1] += finalNewBridgeDebt;
            }
        }
        if (finalNewCommercialDebt > 0) {
            commercialDebtCohorts.push({ yearOriginated: currentYear, originalAmount: finalNewCommercialDebt });
            capitalContext.commercialLineRemaining = Math.max(0, capitalContext.commercialLineRemaining - finalNewCommercialDebt);
            if (capitalContext.commercialCapsRemaining[currentYear - 1] !== undefined) {
                capitalContext.commercialCapsRemaining[currentYear - 1] = Math.max(0, capitalContext.commercialCapsRemaining[currentYear - 1] - finalNewCommercialDebt);
            }
        }
        if (sinosureDrawdowns > 0) {
            const rate = (typeof sinosureConfig !== 'undefined' && sinosureConfig.rate) ? sinosureConfig.rate : 6.0;
            sinosureCohorts.push({ yearOriginated: currentYear, originalAmount: sinosureDrawdowns, rate: rate });
            capitalContext.sinosureDrawnByYear[currentYear - 1] += sinosureDrawdowns;
        }

        const investingCash = -capexThisYear - techInvestmentThisYear;
        
        // Classify balloon principal as financing outflow (do not alter NIIF/logic, only classification)
        const financingOutflows = Math.max(0, balloonPrincipalThisYear + bridgeBalloonPrincipalThisYear);
        let financingCash = finalNewEquityInjections + finalNewVentureDebt + finalNewBridgeDebt + finalNewCommercialDebt + sinosureDrawdowns - totalDebtPrincipalRepayment - financingOutflows;

        let netCash = operatingCash + investingCash + financingCash;
        cash += netCash;

        let equityTopUp = 0;
        if (cash < 0) {
            equityTopUp = Math.abs(cash);
            cash += equityTopUp;
            draws.equity += equityTopUp;
            capitalContext.equityCalls[currentYear - 1] += equityTopUp;
            financingCash += equityTopUp;
            netCash += equityTopUp;
            capitalContext.currentServiceHeadroom = Math.max(0, capitalContext.currentServiceHeadroom - equityTopUp); // equity doesn't consume service but ensure non-negative
            log(`📈 Equity call triggered in Y${currentYear}: ${formatCurrency(equityTopUp)} added to protect cash.`);
        }

        const totalEquityInjections = finalNewEquityInjections + equityTopUp;

        endOfYearEquity = startOfYearEquity + netIncome + totalEquityInjections;
        ventureDebtBalance = startOfYearVentureDebt + finalNewVentureDebt - ventureDebtPrincipalRepayment;
        bridgeDebtBalance = startOfYearBridgeDebt + finalNewBridgeDebt - bridgeDebtPrincipalRepayment;
        commercialDebtBalance = startOfYearCommercialDebt + finalNewCommercialDebt - commercialDebtPrincipalRepayment;
        const sinosureBalance = getSinosureBalance(currentYear, sinosureCohorts);
        const totalDebt = ventureDebtBalance + bridgeDebtBalance + commercialDebtBalance + sinosureBalance;

const fixedAssetsNet = fixedAssetsCohorts.reduce((sum, c) => sum + (c.totalOriginalCost - c.accumulatedDepreciation), 0);
const assetsHeldForSaleNet = heldForSaleAssets.reduce((sum, a) => sum + a.currentFairValueLessCosts, 0);
const totalAssets = cash + currentYearEndReceivables + fixedAssetsNet + assetsHeldForSaleNet;
        const totalLiabilities = totalDebt + currentProvisionsBalance + niif15Results.contractLiabilitiesBalance + insurancePassThroughBalance;
        let totalLiabilitiesEquity = totalLiabilities + endOfYearEquity;
const balanceDiff = totalAssets - totalLiabilitiesEquity;

if (Math.abs(balanceDiff) > BALANCE_TOLERANCE) {
log(`⚠️ Balance adjustment in Year ${currentYear}: ${formatCurrency(balanceDiff)}`);
endOfYearEquity += balanceDiff;
totalLiabilitiesEquity = totalLiabilities + endOfYearEquity;
if (Array.isArray(financialResults.balanceAdjustments)) {
    financialResults.balanceAdjustments.push({ year: currentYear, amount: balanceDiff });
}
}

financialResults.pl.push({ ...niif15Results, interestRevenue: annualInterestReceived, totalRevenue, ebitda, ebit, netIncome, interestExpense, depreciation: annualDepreciation, provisions, impairment, totalCOGS: sparePartsCOGS, grossProfit: totalRevenue - sparePartsCOGS, opex, earningsBeforeTax, incomeTaxExpense, addedUnits });
// Derive cashAfterFinancing (operating minus financing outflows) and store balloonPayment detail
const cashAfterFinancing = (operatingCash || 0) - (financingOutflows || 0);
financialResults.cf.push({ year: currentYear, operatingCash, investingCash, financingCash, netCash, deltaProvisions, deltaContractLiabilities, incomeTaxPaid: incomeTaxExpense, clientPrincipalPaymentsReceived: annualPrincipalReceived, clientInterestPaymentsReceived: annualInterestReceived, currentYearVentureDebtDraw: finalNewVentureDebt, bridgeFundingRaised: finalNewBridgeDebt, additionalFundingRaised: finalNewCommercialDebt, sinosureDrawn: sinosureDrawdowns, equityInjection: totalEquityInjections, equityCallTopUp: equityTopUp, debtPrincipalRepayment: totalDebtPrincipalRepayment, techInvestmentThisYear, financingOutflows, balloonPayment: balloonPrincipalThisYear + bridgeBalloonPrincipalThisYear, insurancePassThroughOutflow, cashAfterFinancing });
log(`💵 Cash After Financing Y${currentYear}: ${formatCurrency(cashAfterFinancing)}`);
        financialResults.bs.push({ cash, receivables: currentYearEndReceivables, receivablesNet: currentYearEndReceivables - currentProvisionsBalance, fixedAssets: fixedAssetsNet, assetsHeldForSale: assetsHeldForSaleNet, totalAssets: totalAssets, debt: totalDebt, equity: endOfYearEquity, totalLiabilitiesEquity: totalLiabilitiesEquity, provisions: currentProvisionsBalance, contractLiabilities: niif15Results.contractLiabilitiesBalance, insurancePassThroughLiability: insurancePassThroughBalance });
financialResults.niifDetails.push({ niif15: niif15Results, niif5: niif5Results.niif5Details, niif9: {...niif9Results, pdStage1: modelData.pdStage1, pdStage2: modelData.pdStage2, pdStage3: modelData.pdStage3, lgd: modelData.lgd, economicAdjustmentFactor: modelData.economicAdjustmentFactor, proteccionRodandoActiva: modelData.proteccionRodando, provisionesConProteccion: provisions, reduccionPorProteccion: niif9Results.totalECLBeforeAdjustment - provisions, saldoProvisionesAcumulado: currentProvisionsBalance } });

const equityEvents = [];
if (finalNewEquityInjections > 0) equityEvents.push({ month: 6, amount: finalNewEquityInjections });
const debtEvents = [];
if (finalNewVentureDebt > 0) debtEvents.push({ month: 3, amount: finalNewVentureDebt });
if (finalNewBridgeDebt > 0) debtEvents.push({ month: 6, amount: finalNewBridgeDebt });
if (finalNewCommercialDebt > 0) debtEvents.push({ month: 9, amount: finalNewCommercialDebt });
const avgEquity = calculateTimeWeightedAverage(startOfYearEquity, endOfYearEquity, equityEvents);
financialResults.roe.push(avgEquity > 0 ? (netIncome / avgEquity) * 100 : 0);
const nopat = ebit * (1 - modelData.corporateTaxRate / 100);
const avgDebt = calculateTimeWeightedAverage(startOfYearVentureDebt + startOfYearBridgeDebt + startOfYearCommercialDebt, totalDebt, debtEvents);
const avgInvestedCapital = avgEquity + avgDebt;
financialResults.roic.push(avgInvestedCapital > 0 ? (nopat / avgInvestedCapital) * 100 : 0);

projectCashFlows.push(ebit * (1 - modelData.corporateTaxRate/100) + annualDepreciation - capexThisYear);
const freeCashFlowToEquity = operatingCash + investingCash + (finalNewVentureDebt + finalNewBridgeDebt + finalNewCommercialDebt + sinosureDrawdowns - totalDebtPrincipalRepayment) - totalEquityInjections;
if (sinosureDrawdowns > 0 || finalNewBridgeDebt > 0) {
    log(`💰 Equity Cash Flow Year ${currentYear}: Operating=${formatCurrency(operatingCash)}, Investing=${formatCurrency(investingCash)}, VD=${formatCurrency(finalNewVentureDebt)}, Bridge=${formatCurrency(finalNewBridgeDebt)}, CD=${formatCurrency(finalNewCommercialDebt)}, SINOSURE=${formatCurrency(sinosureDrawdowns)}, Principal=${formatCurrency(totalDebtPrincipalRepayment)}, Total=${formatCurrency(freeCashFlowToEquity)}`);
}
equityCashFlows.push(freeCashFlowToEquity);
let portfolioCashFlowThisYear = -netLoanPrincipal + annualPrincipalReceived + annualInterestReceived;
if (year === 4) {
portfolioCashFlowThisYear += currentYearEndReceivables / Math.pow(1 + modelData.tasaInteres / 100, modelData.avgRemainingTermCartera);
}
portfolioCashFlows.push(portfolioCashFlowThisYear);
}

const terminalValueProject_final = financialResults.pl[4].ebitda * modelData.ebitdaMultipleProject;
const terminalValueEquity_final = financialResults.bs[4].equity * modelData.floorEquityMultiple;

projectCashFlows[projectCashFlows.length - 1] += terminalValueProject_final;
const finalTerminalValue = Math.max(terminalValueProject_final, terminalValueEquity_final);
equityCashFlows[equityCashFlows.length - 1] += finalTerminalValue;
financialResults.tirProyecto = calculateIRR(projectCashFlows) || 0;
financialResults.tirEquity = calculateIRR(equityCashFlows) || 0;
financialResults.tirCartera = calculateIRR(portfolioCashFlows) || 0;

log(`📊 FINAL TIR RESULTS:`);
log(`  • TIR Proyecto: ${financialResults.tirProyecto.toFixed(1)}%`);
log(`  • TIR Equity: ${financialResults.tirEquity.toFixed(1)}%`);
log(`  • TIR Cartera: ${financialResults.tirCartera.toFixed(1)}%`);
if (modelData.sinosureAvailable) {
    log(`  • SINOSURE Active: Should see HIGHER TIR due to lower interest costs`);
}

// Compute normalized metrics for Y5 (steady-state view)
try {
    const cfY5 = financialResults.cf[4] || {};
    const bsY5 = financialResults.bs[4] || {};
    const bsY4 = financialResults.bs[3] || {};
    const deltaAR_Y5 = (bsY5.receivables || 0) - (bsY4.receivables || 0);
    financialResults.normalizedCFO_Y5 = (cfY5.operatingCash || 0) + (deltaAR_Y5 || 0);
    const financingOutflows_Y5 = (cfY5.financingOutflows || 0);
    financialResults.normalizedCFAF_Y5 = (financialResults.normalizedCFO_Y5 || 0) - financingOutflows_Y5;
    log(`🧮 Normalized CFO Y5: ${formatCurrency(financialResults.normalizedCFO_Y5)}, Normalized CFAF Y5: ${formatCurrency(financialResults.normalizedCFAF_Y5)}`);
} catch (e) {
    log(`⚠️ Could not compute normalized metrics: ${e.message}`);
}

    financialResults.equityCalls = capitalContext.equityCalls.slice(0, 5);
    financialResults.totalEquityCall = capitalContext.equityCalls.reduce((sum, value) => sum + value, 0);
    financialResults.capitalCapsUsage = {
        ventureCapsRemaining: capitalContext.ventureCapsRemaining.slice(0, 5),
        commercialCapsRemaining: capitalContext.commercialCapsRemaining.slice(0, 5),
        serviceHeadroomAvailable: capitalContext.serviceHeadroomAvailableByYear.slice(0, 5),
        serviceHeadroomRemaining: capitalContext.serviceHeadroomRemainingByYear.slice(0, 5),
        bridgeDrawnByYear: capitalContext.bridgeDrawnByYear.slice(0, 5),
        sinosureDrawnByYear: capitalContext.sinosureDrawnByYear.slice(0, 5)
    };

    financialResults.finalDSCR = calculateFinalDSCR();
log('✅ FINANCIAL CALCULATIONS (v23) COMPLETED');
return true;
} catch (error) {
log(`❌ ERROR in calculateFinancials (v23): ${error.message}`);
document.getElementById('balance-validation').innerHTML = `<span class="text-red-600">❌ ${error.message}</span>`;
return false;
}
}

/**
* Calculates the Internal Rate of Return (IRR) using the Newton-Raphson method.
* Incorporates a robust method with error handling and a search range for convergence.
* @param {number[]} cashFlows - Array of cash flows. The first element is the initial investment (negative).
* @param {number} [maxIterations=500] - Maximum number of iterations.
* @param {number} [tolerance=1e-7] - Tolerance for convergence.
* @returns {number} The IRR in percentage, or 0 if it does not converge or is undefined.
*/
function calculateIRR(cashFlows, maxIterations = 500, tolerance = 1e-7) {
if (!cashFlows || cashFlows.length < 2) {
log('IRR: Insufficient flows. Returning 0%.');
return 0;
}
const hasPositive = cashFlows.some(cf => cf > 0);
const hasNegative = cashFlows.some(cf => cf < 0);
if (!hasPositive || !hasNegative) {
log('IRR: No positive and negative flows, IRR undefined. Returning 0%.');
return 0;
}

let guess = 0.10;
let low = -0.99;
let high = 5.0;
for (let i = 0; i < maxIterations; i++) {
let npv = 0;
let dNpv = 0;
for (let t = 0; t < cashFlows.length; t++) {
const discountFactor = Math.pow(1 + guess, t);
if (discountFactor === 0) {
guess += 0.01;
npv = 1;
break;
}
npv += cashFlows[t] / discountFactor;
if (t > 0) {
dNpv -= t * cashFlows[t] / Math.pow(1 + guess, t + 1);
}
}
if (Math.abs(npv) < tolerance) {
return Math.max(-99, Math.min(500, guess * 100));
}
if (dNpv === 0) {
break;
}
const newGuess = guess - npv / dNpv;

if (newGuess < low) {
guess = (guess + low) / 2;
} else if (newGuess > high) {
guess = (guess + high) / 2;
} else {
guess = newGuess;
}

if (npv > 0) low = guess; else high = guess;

if (high - low < tolerance) {
guess = (low + high) / 2;
return Math.max(-99, Math.min(500, guess * 100));
}
}
log(`IRR did not converge completely after ${maxIterations} iterations. Returning ${Math.max(-99, Math.min(500, guess * 100)).toFixed(2)}%.`);
return Math.max(-99, Math.min(500, guess * 100));
}

/**
* Performs a comprehensive validation of the financial model, covering inputs, outputs, and consistency.
* Process: Calls specific validation functions for each area and accumulates the results.
* @param {ModelData} modelData - Model input data.
* @param {Object} financialResults - Calculated model results.
* @returns {Object} Object with arrays of errors, warnings, info, and passed.
*/
function validateModelComprehensively(modelData, financialResults) {
const validations = {
errors: [],
warnings: [],
info: [],
passed: []
};

validateInputs(modelData, validations);

if (financialResults.pl.length > 0 && financialResults.cf.length > 0 && financialResults.bs.length > 0) {
validateOutputs(financialResults, validations);
validateConsistency(financialResults, validations);
validateTemporal(financialResults, validations);
if (financialResults.pl.length === 5) {
validateIndustryBenchmarks(financialResults, validations);
} else {
validations.info.push("No enough projection years to evaluate industry benchmarks.");
}
validateFinancingCapacity(modelData, financialResults, validations);
} else {
validations.errors.push("Financial results could not be calculated. Please review initial inputs.");
}

return validations;
}
/**
* Validates model inputs, including ranges and cross-validations.
* @param {ModelData} modelData - Model input data.
* @param {Object} validations - Object where validation results are accumulated.
*/
function validateInputs(modelData, validations) {
if (modelData.seriesA <= 0) {
validations.errors.push("🔴 Error: Series A Capital must be greater than 0. Adjust 'Capital Serie A' in Control.");
}
if (modelData.vanCost <= 0) {
validations.errors.push("🔴 Error: Van Cost must be greater than 0. Adjust 'Costo Vagoneta (Conductores)' in Control.");
}
if (getTotalPackagePrice() <= 0) {
validations.errors.push(`🔴 Error: Total Package Price (${formatCurrency(getTotalPackagePrice())}) must be greater than 0. Adjust component prices or van in Control.`);
}
if (getTotalPackageCost() <= 0) {
validations.errors.push(`🔴 Error: Total Package Cost (${formatCurrency(getTotalPackageCost())}) must be greater than 0. Adjust component costs or van in Control.`);
}
if (modelData.clientLoanTermYears <= 0 || !Number.isInteger(modelData.clientLoanTermYears)) {
validations.errors.push("🔴 Error: Client Loan Term must be a positive integer. Adjust 'Plazo Préstamo Cliente' in Control.");
}
if (modelData.depreciationYears <= 0 || !Number.isInteger(modelData.depreciationYears)) {
validations.errors.push("🔴 Error: Depreciation Years must be a positive integer. Adjust 'Años Depreciación' in Control.");
}

const percentageInputs = [
{ id: 'tasaInteres', label: 'Tasa de Interés (Clientes)' },
{ id: 'margenRefacciones', label: 'Margen Refacciones' },
{ id: 'margenVagoneta', label: 'Margen Originación Vagoneta' },
{ id: 'tasaReposicion', label: '% Unidades Reposición' },
{ id: 'fairValueVenta', label: '% Fair Value Venta' },
{ id: 'costosVenta', label: '% Costos Venta' },
{ id: 'corporateTaxRate', label: 'Tasa Impuesto Corporativo (%)' },
{ id: 'comisionGNVPorcentaje', label: 'Comisión GNV (%)' },
{ id: 'takeRateMarketplace', label: 'Take Rate Marketplace (%)' },
{ id: 'downPaymentPercentage', label: 'Down Payment Cliente (%)' },
{ id: 'upfrontCommissionPercentage', label: 'Comisión Upfront (%)' }
];
percentageInputs.forEach(p => {
if (modelData[p.id] < 0 || modelData[p.id] > 100) {
validations.warnings.push(`🟡 Warning: '${p.label}' (${modelData[p.id].toFixed(1)}%) is outside typical range (0-100%). Review in Control.`);
}
});

const decimalPercentageInputs = [
{ id: 'pdStage1', label: 'PD Etapa 1 (12M)' },
{ id: 'pdStage2', label: 'PD Etapa 2 (Lifetime)' },
{ id: 'pdStage3', label: 'PD Etapa 3 (Lifetime)' },
{ id: 'lgd', label: 'LGD (Pérdida Incumplimiento)' },
{ id: 'portfolioAllocationStage1', label: 'Port. Etapa 1 (%)' },
{ id: 'portfolioAllocationStage2', label: 'Port. Etapa 2 (%)' },
{ id: 'portfolioAllocationStage3', label: 'Port. Etapa 3 (%)' }
];
decimalPercentageInputs.forEach(p => {
if (modelData[p.id] < 0 || modelData[p.id] > 1) {
validations.warnings.push(`🟡 Warning: '${p.label}' (${(modelData[p.id]*100).toFixed(1)}%) is outside valid range (0-100%). Review in Control.`);
}
});

const totalAllocation = modelData.portfolioAllocationStage1 + modelData.portfolioAllocationStage2 + modelData.portfolioAllocationStage3;
if (Math.abs(totalAllocation - 1.0) > 0.001) {
validations.errors.push(`🔴 Error: Sum of IFRS 9 Portfolio Allocation (${(totalAllocation*100).toFixed(1)}%) is not equal to 100%. Please adjust in Control.`);
} else {
validations.passed.push(`✅ Inputs: IFRS 9 Portfolio Allocation sums to 100%.`);
}

if (getTotalPackagePrice() <= getTotalPackageCost()) {
validations.errors.push(`🔴 Input Error: 'Total Package Price' (${formatCurrency(getTotalPackagePrice())}) must be greater than 'Total Package Cost for Conductores' (${formatCurrency(getTotalPackageCost())}).`);
} else {
validations.passed.push(`✅ Inputs: 'Total Package Price' is greater than 'Total Package Cost for Conductores'.`);
}

validations.passed.push("✅ Inputs: Basic input parameters validated correctly.");
}
/**
* Validates model outputs for financial sanity (e.g., cash balances, margins).
* @param {Object} financialResults - Calculated model results.
* @param {Object} validations - Object where validation results are accumulated.
*/
function validateOutputs(financialResults, validations) {
const lastYear = financialResults.pl.length - 1;
if (lastYear < 0) return;
financialResults.bs.forEach((bsYear, index) => {
if (bsYear.cash < -BALANCE_TOLERANCE) {
validations.errors.push(`🔴 Error: Cash Balance at Year ${index + 1} end is significantly negative (${formatCurrency(bsYear.cash)}). The model requires more financing. Adjust Capital Series or units.`);
} else if (bsYear.cash < 0) {
validations.warnings.push(`🟡 Warning: Cash Balance at Year ${index + 1} end is slightly negative (${formatCurrency(bsYear.cash)}). Consider adjusting financing.`);
}
});
if (!validations.errors.some(e => e.includes("Negative cash")) && !validations.warnings.some(e => e.includes("Slightly negative cash"))) {
validations.passed.push("✅ Outputs: Cash balance is adequate in all years.");
}
const year5PL = financialResults.pl[lastYear];
const year5BS = financialResults.bs[lastYear];

if (year5PL.totalRevenue !== 0) {
const ebitdaMargin = safeRatio(year5PL.ebitda, year5PL.totalRevenue, 0) * 100;
if (ebitdaMargin < 10 || ebitdaMargin > 40) {
validations.info.push(`🔵 Info: EBITDA Margin for Year ${lastYear + 1} (${ebitdaMargin.toFixed(1)}%) is outside typical fintech benchmark (10-40%).`);
} else {
validations.passed.push(`✅ Outputs: EBITDA Margin for Year ${lastYear + 1} is realistic (${ebitdaMargin.toFixed(1)}%).`);
}
} else {
validations.info.push(`🔵 Info: Total Revenue for Year ${lastYear + 1} is zero, cannot calculate EBITDA Margin.`);
}

if (financialResults.roe && financialResults.roe.length > lastYear && year5BS.equity !== 0) {
const roe = financialResults.roe[lastYear];
if (roe < 20 || roe > 30) {
validations.info.push(`🔵 Info: ROE for Year ${lastYear + 1} (${roe.toFixed(1)}%) is outside typical financial services benchmark (20-30%).`);
} else {
validations.passed.push(`✅ Outputs: ROE for Year ${lastYear + 1} is realistic (${roe.toFixed(1)}%).`);
}
} else if (financialResults.roe && financialResults.roe.length > lastYear) {
validations.info.push(`🔵 Info: Equity for Year ${lastYear + 1} is zero or negative, cannot calculate significant ROE.`);
}

if (year5PL.totalRevenue !== 0) {
const cxcToRevenueRatio = year5BS.receivables / year5PL.totalRevenue;
if (cxcToRevenueRatio < 0.5 || cxcToRevenueRatio > 3) {
validations.info.push(`🔵 Info: A/R/Revenue Ratio for Year ${lastYear + 1} (${cxcToRevenueRatio.toFixed(1)}x) is outside typical financing benchmark (0.5-3x).`);
} else {
validations.passed.push(`✅ Outputs: A/R/Revenue Ratio for Year ${lastYear + 1} is realistic (${cxcToRevenueRatio.toFixed(1)}x).`);
}
} else {
validations.info.push(`🔵 Info: Total Revenue for Year ${lastYear + 1} is zero, cannot compare A/R/Revenue Ratio.`);
}

if (year5BS.equity !== 0) {
const debtToEquityRatio = year5BS.debt / year5BS.equity;
if (debtToEquityRatio < 0 || debtToEquityRatio > 3) {
validations.warnings.push(`🟡 Warning: Debt/Equity Ratio for Year ${lastYear + 1} (${debtToEquityRatio.toFixed(1)}x) is unusual. Review assumptions.`);
} else {
validations.passed.push(`✅ Outputs: Debt/Equity Ratio for Year ${lastYear + 1} is realistic (${debtToEquityRatio.toFixed(1)}x).`);
}
} else {
validations.info.push(`🔵 Info: Equity for Year ${lastYear + 1} is zero or negative, cannot calculate significant Debt/Equity Ratio.`);
}
}
/**
* Validates consistency between different financial statements (P&L, CF, BS).
* @param {Object} financialResults - Calculated model results.
* @param {Object} validations - Object where validation results are accumulated.
*/
function validateConsistency(financialResults, validations) {
const tolerance = BALANCE_TOLERANCE;
const largeTolerance = 50000;
for (let i = 0; i < financialResults.pl.length; i++) {
const pl = financialResults.pl[i];
const cf = financialResults.cf[i];
const bs = financialResults.bs[i];

const prevBsCash = (i === 0) ? ((modelData.seed || 0) + (modelData.seriesA || 0)) : financialResults.bs[i-1].cash;

const balanceDiff = Math.abs(bs.totalAssets - bs.totalLiabilitiesEquity);
if (balanceDiff > tolerance) {
validations.errors.push(`🔴 Consistency Error: Balance Sheet for Year ${i + 1} does not balance. Difference: ${formatCurrency(balanceDiff)}. Assets (${formatCurrency(bs.totalAssets)}) vs. Liabilities+Equity (${formatCurrency(bs.totalLiabilitiesEquity)}).`);
} else {
validations.passed.push(`✅ Consistency: Balance Sheet for Year ${i + 1} balances.`);
}

const cashChangeCF = cf.netCash;
const cashChangeBS = bs.cash - prevBsCash;
if (Math.abs(cashChangeCF - cashChangeBS) > tolerance) {
validations.errors.push(`🔴 Consistency Error: Net Flow for Year ${i + 1} (${formatCurrency(cashChangeCF)}) differs from Cash change in Balance Sheet (${formatCurrency(cashChangeBS)}).`);
} else {
validations.passed.push(`✅ Consistency: Net Flow and Cash change for Year ${i + 1} match.`);
}
}
}
/**
* Validates the temporal evolution of key metrics (e.g., revenue growth, ratio changes).
* @param {Object} financialResults - Calculated model results.
* @param {Object} validations - Object where validation results are accumulated.
*/
function validateTemporal(financialResults, validations) {
for (let i = 1; i < financialResults.pl.length; i++) {
const prevPl = financialResults.pl[i-1];
const currentPl = financialResults.pl[i];

if (prevPl.totalRevenue !== 0) {
const revenueGrowth = (currentPl.totalRevenue / prevPl.totalRevenue - 1) * 100;
if (revenueGrowth > 1000) {
validations.warnings.push(`🟡 Temporal Warning: Revenue Growth for Year ${i + 1} (${revenueGrowth.toFixed(1)}%) is extremely high. Review units or pricing assumptions.`);
}
} else if (currentPl.totalRevenue > 0) {
validations.info.push(`🔵 Temporal Info: Year ${i + 1} Revenue starts ramp-up from zero/low. Percentage growth not significant.`);
}

if (prevPl.totalRevenue !== 0 && currentPl.totalRevenue !== 0) {
const prevEbitdaMargin = (prevPl.ebitda / prevPl.totalRevenue) * 100;
const currentEbitdaMargin = (currentPl.ebitda / currentPl.totalRevenue) * 100;
if (Math.abs(currentEbitdaMargin - prevEbitdaMargin) > 500) {
validations.warnings.push(`🟡 Temporal Warning: EBITDA Margin changes drastically (${prevEbitdaMargin.toFixed(1)}% to ${currentEbitdaMargin.toFixed(1)}%) from Year ${i} to Year ${i + 1}. Review cost/revenue dynamics.`);
}
}
}
validations.passed.push("✅ Temporal Evolution: Annual growth trends and ratios seem reasonable.");
}
/**
* Compares model metrics with industry benchmarks for Year 5.
* @param {Object} financialResults - Calculated model results.
* @param {Object} validations - Object where validation results are accumulated.
*/
function validateIndustryBenchmarks(financialResults, validations) {
const lastYear = financialResults.pl.length - 1;
if (lastYear < 4) return;
const year5PL = financialResults.pl[lastYear];
const year5BS = financialResults.bs[lastYear];
const year5ROE = financialResults.roe && financialResults.roe.length > lastYear ? financialResults.roe[lastYear] : 0;

if (year5PL.totalRevenue !== 0) {
const ebitdaMargin = (year5PL.ebitda / year5PL.totalRevenue) * 100;
if (ebitdaMargin < 10 || ebitdaMargin > 40) {
validations.info.push(`🔵 Info: EBITDA Margin for Year ${lastYear + 1} (${ebitdaMargin.toFixed(1)}%) is outside typical fintech benchmark (10-40%).`);
} else {
validations.passed.push(`✅ Outputs: EBITDA Margin for Year ${lastYear + 1} is realistic (${ebitdaMargin.toFixed(1)}%).`);
}
} else {
validations.info.push(`🔵 Info: Total Revenue for Year ${lastYear + 1} is zero, cannot calculate EBITDA Margin.`);
}

if (year5BS.equity !== 0) {
if (year5ROE < 20 || year5ROE > 30) {
validations.info.push(`🔵 Info: ROE for Year ${lastYear + 1} (${year5ROE.toFixed(1)}%) is outside typical financial services benchmark (20-30%).`);
} else {
validations.passed.push(`✅ Outputs: ROE for Year ${lastYear + 1} is realistic (${year5ROE.toFixed(1)}%).`);
}
} else {
validations.info.push(`🔵 Info: Equity for Year ${lastYear + 1} is zero or negative, cannot compare ROE with benchmark.`);
}

if (year5PL.totalRevenue !== 0) {
const cxcToRevenueRatio = year5BS.receivables / year5PL.totalRevenue;
if (cxcToRevenueRatio < 0.5 || cxcToRevenueRatio > 3) {
validations.info.push(`🔵 Info: A/R/Revenue Ratio for Year ${lastYear + 1} (${cxcToRevenueRatio.toFixed(1)}x) is outside typical financing benchmark (0.5-3x).`);
} else {
validations.passed.push(`✅ Outputs: A/R/Revenue Ratio for Year ${lastYear + 1} is realistic (${cxcToRevenueRatio.toFixed(1)}x).`);
}
} else {
validations.info.push(`🔵 Info: Total Revenue for Year ${lastYear + 1} is zero, cannot compare A/R/Revenue Ratio.`);
}

if (financialResults.tirEquity !== 0) {
if (financialResults.tirEquity < 22) {
validations.warnings.push(`🟡 Benchmarks: Equity IRR (${financialResults.tirEquity.toFixed(1)}%) is below the target of 22%.`);
} else {
validations.passed.push(`✅ Benchmarks: Equity IRR (${financialResults.tirEquity.toFixed(1)}%) meets the target of >22%.`);
}
}

if (financialResults.tirCartera !== 0) {
if (financialResults.tirCartera < 20 || financialResults.tirCartera > 30) {
validations.info.push(`🔵 Info: Portfolio IRR (${(financialResults.tirCartera || 0).toFixed(1)}%) is outside target range (20-30%).`);
} else {
validations.passed.push(`✅ Benchmarks: Portfolio IRR (${(financialResults.tirCartera || 0).toFixed(1)}%) is within target range.`);
}
}

const roic = financialResults.roic && financialResults.roic.length > lastYear ? financialResults.roic[lastYear] : 0;
if (roic !== 0) {
if (roic < 15 || roic > 25) {
validations.info.push(`🔵 Info: ROIC for Year ${lastYear + 1} (${roic.toFixed(1)}%) is outside target range (15-25%).`);
} else {
validations.passed.push(`✅ Benchmarks: ROIC for Year ${lastYear + 1} (${roic.toFixed(1)}%) is within target range.`);
}
} else if (financialResults.roic && financialResults.roic.length > lastYear) {
validations.info.push(`🔵 Info: Average Invested Capital for Year ${lastYear + 1} is zero or negative, cannot compare ROIC with benchmark.`);
}
}

function validateFinancingCapacity(modelData, financialResults, validations) {
let totalCapex = 0;
for (let i = 0; i < financialResults.pl.length; i++) {
totalCapex += (financialResults.pl[i].addedUnits || 0) * getTotalPackageCost();
}

const totalFunding = totalFundingFromCF();
if (totalFunding < totalCapex) {
validations.errors.push(`🔴 Validación Financiamiento: El financiamiento total (${formatCurrency(totalFunding)}) es INSUFICIENTE para cubrir el CAPEX total (${formatCurrency(totalCapex)}).`);
} else {
validations.passed.push(`✅ Validación Financiamiento: El financiamiento total (${formatCurrency(totalFunding)}) es SUFICIENTE para cubrir el CAPEX total.`);
}
}

// ===================================================================
// ===== FASE 3: LÓGICA DE INTERFAZ DE USUARIO (UI - EL CÓMO SE VE) ==
// ===================================================================
// (Aquí se encuentran todas las funciones que manipulan el DOM y actualizan la página)
// ===== DEBUG FUNCTIONS =====
/**
* Logs messages to the UI debug panel.
* @param {string} message - The message to log.
*/
function log(message) {
const timestamp = new Date().toLocaleTimeString();
const logEntry = `[${timestamp}] ${message}`;
debugLogs.unshift(logEntry); // Add to the beginning
if (debugLogs.length > 20) debugLogs.pop(); // Keep only the last 20 logs

updateDebugPanel();
}

/**
* Updates the content of the debug panel in the UI.
*/
function updateDebugPanel() {
const panel = document.getElementById('debug-content');
if (panel) {
panel.innerHTML = debugLogs.map(log => `<div style="margin-bottom: 2px; font-size: 10px; border-bottom: 1px dotted #4b5563; padding-bottom: 2px;">${log}</div>`).join('');
}
}

/**
* Shows/hides the debug panel.
*/
function toggleDebug() {
const panel = document.getElementById('debug-info');
panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}
/**
* Shows a temporary warning in the UI.
* @param {string} message - Warning message.
*/
function showWarning(message) {
const existingWarning = document.getElementById('dynamic-warning');
if (existingWarning) existingWarning.remove();

const warning = document.createElement('div');
warning.id = 'dynamic-warning';
warning.className = 'fixed top-20 right-4 bg-amber-900 border border-amber-600 text-amber-200 px-4 py-2 rounded-lg z-50 shadow-lg animate-pulse';
warning.innerHTML = `<span class="text-sm font-medium">${message}</span>`;
document.body.appendChild(warning);

setTimeout(() => {
if (warning && warning.parentNode) {
warning.parentNode.removeChild(warning);
}
}, 5000);
}

/**
* Runs global checks for critical metrics and shows warnings if thresholds are breached.
*/
function runGlobalChecks() {
// Check Equity IRR
if (financialResults.tirEquity < 15) {
showWarning(`⚠️ Alerta de Rentabilidad: La TIR del Equity (${financialResults.tirEquity.toFixed(1)}%) está por debajo del umbral crítico del 15%.`);
}
// Check DSCR
const debtMetrics = calculateDebtMetricsBreakdown();
if (debtMetrics.finalDSCR !== null && debtMetrics.finalDSCR < 1.2) {
showWarning(`🚨 Alerta de Riesgo de Deuda: El DSCR (${debtMetrics.finalDSCR.toFixed(1)}x) está por debajo de 1.2x. Riesgo de incumplimiento de covenants.`);
}
}
// ===== USER INTERFACE (UI) UPDATE =====
/**
* Updates the key metrics in the summary cards and then the tables and charts.
* Process: Collects data from `financialResults` and injects it into the DOM.
*/
function updateUI() {
log('🔄 Updating User Interface...');
try {
if (!financialResults.pl || financialResults.pl.length === 0) {
log('❌ No financial data to update UI.');
return;
}

const year5PL = financialResults.pl[4];
const year5BS = financialResults.bs[4];
const cashHealth = analyzeCashFlowHealth();
const corePrice = getTotalPackagePrice();
const coreCost = getTotalPackageCost();
const coreMargin = corePrice - coreCost;
const coreMarginPercent = corePrice > 0 ? (coreMargin / corePrice) * 100 : 0;

// Update new investor dashboard
if (year5PL && year5BS) {
// Row 1: Retorno y Escala
document.getElementById('ebitda-year5').textContent = formatCurrency(year5PL.ebitda);
document.getElementById('tir-equity').textContent = financialResults.tirEquity.toFixed(1) + '%';
document.getElementById('aum-value').textContent = formatCurrency(year5BS.totalAssets);
const totalVansFinanced = financialResults.pl.reduce((a, b) => a + (b.addedUnits || 0), 0);
document.getElementById('total-vans-financed').textContent = totalVansFinanced.toLocaleString();
// Row 2: La Maquinaria de Crecimiento (SSOT)
const cfAgg = (financialResults.cf || []).reduce((acc, cf) => {
    acc.equity += Math.max(0, (cf.equityInjection || 0) + (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0));
    acc.bridge += Math.max(0, cf.bridgeFundingRaised || 0);
    acc.commercial += Math.max(0, cf.additionalFundingRaised || 0);
    acc.venture += Math.max(0, cf.currentYearVentureDebtDraw || 0);
    acc.sinosure += Math.max(0, cf.sinosureDrawn || 0);
    return acc;
}, { equity: 0, sinosure: 0, bridge: 0, commercial: 0, venture: 0 });
const totalEquityDisplayed = (modelData.seed || 0) + (modelData.seriesA || 0) + cfAgg.equity;
document.getElementById('equity-raised').textContent = formatCurrency(totalEquityDisplayed);
const totalDebtDisplayed = cfAgg.sinosure + cfAgg.bridge + cfAgg.commercial + cfAgg.venture;
document.getElementById('total-debt-raised').textContent = formatCurrency(totalDebtDisplayed);
renderCapitalAnalysisCF(totalEquityDisplayed, cfAgg);
const seriesAMetrics = calculateSeriesAMetrics();
document.getElementById('funding-efficiency').textContent = seriesAMetrics.fundingEfficiency ? seriesAMetrics.fundingEfficiency.toFixed(1) + 'x' : '0.0x';
document.getElementById('capital-per-unit').textContent = seriesAMetrics.capitalPerUnit ? '$' + seriesAMetrics.capitalPerUnit.toFixed(0) + 'K' : '$0K';
// Row 3: Resiliencia y Sostenibilidad
const vagonetasOperativas = totalVansFinanced - (financialResults.niifDetails && financialResults.niifDetails[4]?.niif5?.totalUnitsAccumulatedHeldForSale || 0);
document.getElementById('vagonetas-operativas').textContent = Math.round(vagonetasOperativas).toLocaleString();
const debtMetrics = calculateDebtMetricsBreakdown();
const dscrEl = document.getElementById('dscr-final');
if (dscrEl) {
    if (debtMetrics.finalDSCR !== null) {
        dscrEl.textContent = debtMetrics.finalDSCR.toFixed(1) + 'x';
        dscrEl.className = 'text-2xl font-bold ' + (debtMetrics.isHealthyDSCR ? 'text-emerald-400' : 'text-amber-400');
    } else {
        dscrEl.textContent = 'N/A';
        dscrEl.className = 'text-2xl font-bold text-slate-400';
    }
}
document.getElementById('nim-y5').textContent = seriesAMetrics.netInterestMargin ? seriesAMetrics.netInterestMargin.toFixed(1) + '%' : '0.0%';
const totalFundingCF = totalFundingFromCF();
const totalCapex = calculateTotalCapex();
const coverageRatio = safeRatio(totalFundingCF, totalCapex, 0);
const worstCashCard = document.getElementById('worst-cash-card');
if (worstCashCard) {
    const worstBalance = cashHealth.worstBalance || 0;
    const worstYearLabel = cashHealth.worstYear ? `Año ${cashHealth.worstYear}` : 'Sin stress';
    const worstCashAmountEl = document.getElementById('worst-cash-amount');
    const worstCashYearEl = document.getElementById('worst-cash-year-label');
    if (worstCashAmountEl) worstCashAmountEl.textContent = formatCurrency(worstBalance);
    if (worstCashYearEl) worstCashYearEl.textContent = worstYearLabel;
    worstCashCard.classList.remove('negative', 'positive');
    worstCashCard.classList.add(worstBalance < 0 ? 'negative' : 'positive');
}
        // Update Cash Flow After Financing (Y5)
        const cashAfterFinancing = financialResults.cf?.[4]?.cashAfterFinancing || 0;
        const cafEl = document.getElementById('cash-after-financing-display');
        if (cafEl) cafEl.textContent = formatCurrency(cashAfterFinancing);
        const sanityMarginEl = document.getElementById('sanity-core-margin');
        if (sanityMarginEl) sanityMarginEl.textContent = `${formatCurrency(coreMargin, true)} (${coreMarginPercent.toFixed(1)}%)`;
        const sanityCoverageEl = document.getElementById('sanity-coverage');
        if (sanityCoverageEl) sanityCoverageEl.textContent = `${(coverageRatio * 100).toFixed(1)}%`;
        const sanityDscrEl = document.getElementById('sanity-dscr');
        if (sanityDscrEl) sanityDscrEl.textContent = debtMetrics.finalDSCR !== null ? `${debtMetrics.finalDSCR.toFixed(2)}x` : 'N/A';
        const sanityTirEl = document.getElementById('sanity-tir');
        if (sanityTirEl) sanityTirEl.textContent = `${financialResults.tirEquity.toFixed(1)}%`;
        const sanityCafEl = document.getElementById('sanity-caf');
        if (sanityCafEl) sanityCafEl.textContent = formatCurrency(cashAfterFinancing);
        // Update steady-state normalized metrics
        const normCFOEl = document.getElementById('normalized-cfo-y5');
        const normCFAFEl = document.getElementById('normalized-cfaf-y5');
        if (normCFOEl) normCFOEl.textContent = formatCurrency(financialResults.normalizedCFO_Y5 || 0);
        if (normCFAFEl) normCFAFEl.textContent = formatCurrency(financialResults.normalizedCFAF_Y5 || 0);
let actualAutosufficiencyYear = 0;
if(financialResults.pl){
for(let i = 0; i < financialResults.pl.length; i++) {
const plYear = financialResults.pl[i];
if (plYear.totalRevenue > (plYear.opex + plYear.provisions + plYear.impairment)) {
actualAutosufficiencyYear = i + 1;
break;
}
}
}
document.getElementById('autosuficiency-year').textContent = actualAutosufficiencyYear > 0 ? `Año ${actualAutosufficiencyYear}` : 'No alcanzado';
    // Apply current mode visibility after values update
    updateFinancialModeUI();

    const scenarioDef = SCENARIO_DEFS[currentScenario] || { name: 'Personalizado', units: modelData.unitsPerYear.slice() };
    const plannedUnitsTotal = Array.isArray(scenarioDef.units) ? scenarioDef.units.reduce((sum, val) => sum + (Number(val) || 0), 0) : modelData.unitsPerYear.reduce((sum, val) => sum + (val || 0), 0);
    const modeledUnitsTotal = modelData.unitsPerYear.reduce((sum, val) => sum + (val || 0), 0);
    storeScenarioSnapshot({
        scenarioKey: currentScenario,
        scenarioName: scenarioDef.name || 'Personalizado',
        plannedUnits: plannedUnitsTotal,
        totalUnits: modeledUnitsTotal,
        tirEquity: financialResults.tirEquity || 0,
        tirProyecto: financialResults.tirProyecto || 0,
        dscr: debtMetrics.finalDSCR,
        coverage: coverageRatio,
        equityDeployed: totalEquityDisplayed,
        debtDeployed: totalDebtDisplayed,
        cashFinal: year5BS.cash || 0,
        cashAfterFinancingY5: cashAfterFinancing,
        worstCash: { year: cashHealth.worstYear, balance: cashHealth.worstBalance },
        nimY5: seriesAMetrics.netInterestMargin || 0,
        totalFunding: totalFundingCF,
        totalCapex: totalCapex,
        updatedAt: new Date().toISOString(),
        displayOrder: Number(currentScenario) || 999
    });
}

renderInvestorSnapshot();

updateTables();
updateNIIFTables();
updateCharts();
updateFinancingMatrixWithOptimized(); // NEW

const validations = validateModelComprehensively(modelData, financialResults);
updateValidationPanel(validations);
updateOptimizationStatus();
updateInvestorScore();
renderAuditPanel();
updateFundingCoverageCard();
updateMetricExplanations();
if (dataRoomActive) {
    renderDataRoomOverlay();
}

log(`✅ UI Update sequence completed.`);
} catch (error) {
log(`❌ Error in updateUI: ${error.message}`);
}
}
/**
* Coordinates the update of all financial tables (P&L, CF, BS).
*/
function updateTables() {
updatePLTable();
updateCashFlowTable();
updateBalanceSheetTable();
}
/**
* Updates the Profit & Loss (P&L) table.
* Process: Iterates over predefined rows and annual data to populate the table.
*/
function updatePLTable() {
const tbody = document.getElementById('pl-table-body');
if (!tbody || !financialResults.pl.length) return;

tbody.innerHTML = '';

const rows = [
{ label: 'Ingresos por Intereses', key: 'interestRevenue' },
{ label: 'Margen por Originación (NIIF 15)', key: 'recognizedOriginationRevenue' },
{ label: 'Comisiones GNV (NIIF 15)', key: 'gnvCommissions' },
{ label: 'Ingresos Refacciones (NIIF 15)', key: 'sparePartsRevenue' },
{ label: 'Ingresos Marketplace (NIIF 15)', key: 'marketplaceRevenue' },
{ label: 'Total Ingresos Operativos', key: 'totalRevenue', total: true },

{ label: 'COGS Refacciones', key: 'totalCOGS', negative: true, fromPL: true },
{ label: 'Utilidad Bruta', key: 'grossProfit', total: true },

{ label: 'Gastos Operativos (OPEX)', key: 'opex', negative: true },
{ label: 'Provisiones NIIF 9', key: 'provisions', negative: true },
{ label: 'Pérdida por Deterioro NIIF 5', key: 'impairment', negative: true },
{ label: 'EBITDA', key: 'ebitda', total: true, emphasize: true },
{ label: 'Depreciación', key: 'depreciation', negative: true },
{ label: 'EBIT', key: 'ebit', total: true },
{ label: 'Gastos por Intereses (Deuda)', key: 'interestExpense', negative: true },
{ label: 'Ganancia Antes de Impuestos (EBT)', key: 'earningsBeforeTax', total: true },
{ label: 'Impuesto sobre la Renta', key: 'incomeTaxExpense', negative: true },
{ label: 'Utilidad Neta', key: 'netIncome', total: true, emphasize: true }
];
rows.forEach(row => {
const tr = document.createElement('tr');
if (row.total) tr.classList.add('bg-gray-50');
if (row.emphasize) tr.classList.add('font-bold', 'text-gray-900');

const labelCell = document.createElement('td');
labelCell.textContent = row.label;
if (row.total) labelCell.classList.add('font-bold');
tr.appendChild(labelCell);

financialResults.pl.forEach(yearData => {
const cell = document.createElement('td');
let value = yearData[row.key] || 0;

if (row.negative && value > 0) {
cell.textContent = '(' + formatCurrency(value) + ')';
cell.classList.add('negative');
} else {
cell.textContent = formatCurrency(value);
if (value > 0 && !row.negative) cell.classList.add('positive');
if (value < 0) cell.classList.add('negative');
}

if (value === 0) {
cell.style.color = '#94a3b8';
}
if (row.total) cell.classList.add('font-bold');
tr.appendChild(cell);
});

tbody.appendChild(tr);
});
log('✅ Profit & Loss Table updated.');
}
/**
* Updates the Cash Flow (CF) table.
* Process: Iterates over predefined rows and annual data to populate the table.
*/
function updateCashFlowTable() {
const tbody = document.getElementById('cf-table-body');
if (!tbody || !financialResults.cf.length) return;

tbody.innerHTML = '';

const rows = [
{ label: 'FLUJO DE EFECTIVO OPERATIVO', total: true, emphasize: true, isHeader: true },
{ label: '  Utilidad Neta', key: 'netIncome', fromPL: true },
{ label: '  + Depreciación', key: 'depreciation', fromPL: true },
{ label: '  + Pérdida por Deterioro NIIF 5', key: 'impairment', fromPL: true },
{ label: '  + Δ Provisiones (NIIF 9)', key: 'deltaProvisions', fromCF: true, positive: true },
{ label: '  - Δ Cuentas por Cobrar', key: 'receivables', deltaFromBS: true, negative: true },
{ label: '  + Δ Pasivos Contractuales (NIIF 15)', key: 'deltaContractLiabilities', fromCF: true, positive: true },
{ label: '  - Impuestos Pagados', key: 'incomeTaxPaid', fromCF: true, negative: true },
{ label: 'TOTAL FLUJO DE EFECTIVO OPERATIVO', key: 'operatingCash', total: true, emphasize: true },
{ label: '  + Pagos Principal Clientes', key: 'clientPrincipalPaymentsReceived', fromCF: true, isInfo: true },
{ label: '  + Pagos Interés Clientes', key: 'clientInterestPaymentsReceived', fromCF: true, isInfo: true },

{ label: 'FLUJO DE EFECTIVO DE INVERSIÓN', total: true, separator: true, emphasize: true, isHeader: true },
{ label: '  - CAPEX Vagonetas (Activos Fijos)', key: 'investingCash', fromCF: true, negative: true, specialHandling: 'capexOnly' },
{ label: '  - Inversión en Tecnología', key: 'techInvestmentThisYear', fromCF: true, negative: true },
{ label: 'TOTAL FLUJO DE EFECTIVO DE INVERSIÓN', key: 'investingCash', total: true, emphasize: true, duplicate: true },

{ label: 'FLUJO DE EFECTIVO DE FINANCIACIÓN', total: true, separator: true, emphasize: true, isHeader: true },
{ label: '  Capital Recibido', fromModelData: true, yearSpecific: true, key: 'partnerCapitalization' },
{ label: '  Venture Debt Recibido', key: 'currentYearVentureDebtDraw', fromCF: true, positive: true },
{ label: '  Deuda Comercial Recibida', key: 'additionalFundingRaised', fromCF: true, positive: true },
{ label: '  SINOSURE Recibido', key: 'sinosureDrawn', fromCF: true, positive: true },
{ label: '  - Pago seguro pass-through', key: 'insurancePassThroughOutflow', fromCF: true, negative: true },
{ label: '  - Amortización Deuda', key: 'debtPrincipalRepayment', fromCF: true, negative: true },
{ label: 'TOTAL FLUJO DE EFECTIVO DE FINANCIACIÓN', key: 'financingCash', total: true, emphasize: true, duplicate: true },

{ label: 'INCREMENTO NETO DE EFECTIVO', key: 'netCash', total: true, separator: true, emphasize: true },
{ label: 'SALDO DE EFECTIVO AL FINAL DEL PERIODO', key: 'cash', fromBS: true, total: true, emphasize: true }
];
rows.forEach(row => {
const tr = document.createElement('tr');
if (row.total) tr.classList.add('bg-gray-50');
if (row.emphasize) tr.classList.add('font-bold', 'text-gray-900');
if (row.separator) tr.classList.add('border-t-2', 'border-gray-200');
if (row.isInfo) tr.style.fontStyle = 'italic';
const labelCell = document.createElement('td');
labelCell.textContent = row.label;
if (row.total) labelCell.classList.add('font-bold');
tr.appendChild(labelCell);

// Handle Año 0 cell
const cell0 = document.createElement('td');
if (row.isHeader) {
cell0.textContent = '-';
} else if (row.label === '  Capital Recibido') {
cell0.textContent = formatCurrency(modelData.seriesA);
cell0.classList.add('positive', 'font-bold');
} else if (row.key === 'netCash' || row.key === 'cash') {
cell0.textContent = formatCurrency(modelData.seriesA);
cell0.classList.add('positive', 'font-bold');
} else {
cell0.textContent = '-';
}
tr.appendChild(cell0);

// Handle Año 1-5 cells
for (let i = 0; i < 5; i++) {
const cell = document.createElement('td');
if(row.isHeader) {
cell.textContent = '-';
tr.appendChild(cell);
continue;
}
let value;
if (row.fromPL) {
value = financialResults.pl[i][row.key] || 0;
} else if (row.fromBS) {
value = financialResults.bs[i][row.key] || 0;
} else if (row.fromCF) {
value = financialResults.cf[i][row.key] || 0;
} else if (row.deltaFromBS) {
const prevValue = (i === 0) ? 0 : financialResults.bs[i-1][row.key];
const currentValue = financialResults.bs[i][row.key];
value = currentValue - prevValue;
} else if (row.fromModelData && row.yearSpecific) {
const currentYear = i + 1;
if (row.key === 'partnerCapitalization') {
value = (modelData[`seriesB_newInvestors_year${currentYear}`] || 0) + (modelData[`partnerCapitalizationYear${currentYear}`] || 0);
} else {
value = 0;
}
} else {
value = financialResults.cf[i][row.key] || 0;
}

if (row.specialHandling === 'capexOnly') {
value = value + (financialResults.cf[i]['techInvestmentThisYear'] || 0);
}
if (row.deltaFromBS && row.key === 'receivables') {
if (value > 0) { // Increase in A/R is a cash USE
cell.textContent = '(' + formatCurrency(value) + ')';
cell.classList.add('negative');
} else { // Decrease in A/R is a cash SOURCE
cell.textContent = formatCurrency(Math.abs(value));
cell.classList.add('positive');
}
} else if (row.negative && value > 0) {
cell.textContent = '(' + formatCurrency(value) + ')';
cell.classList.add('negative');
} else if (row.positive && value > 0) {
cell.textContent = formatCurrency(value);
cell.classList.add('positive');
}
else {
cell.textContent = formatCurrency(value);
if (value > 0 && !row.negative) cell.classList.add('positive');
if (value < 0) cell.classList.add('negative');
}

if (value === 0) {
cell.style.color = '#94a3b8';
}
if (row.total) cell.classList.add('font-bold');
tr.appendChild(cell);
}

tbody.appendChild(tr);
});
log('✅ Cash Flow Table updated.');
}
/**
* Updates the Balance Sheet (BS) table.
* Process: Iterates over predefined rows and annual data to populate the table.
* Performs balance sheet validation and displays the result.
*/
function updateBalanceSheetTable() {
const tbody = document.getElementById('bs-table-body');
if (!tbody || !financialResults.bs.length) return;

tbody.innerHTML = '';

const rows = [
{ label: 'ACTIVOS', total: true, emphasize: true },
{ label: '  Efectivo y Equivalentes', key: 'cash' },
{ label: '  Cuentas por Cobrar (Brutas)', key: 'receivables', isInfo: true },
{ label: '  (-) Provisiones NIIF 9', key: 'provisions', negative: true, isContraAsset: true },
{ label: '  Cuentas por Cobrar, Netas', key: 'receivablesNet', bold: true },
{ label: '  Activos Fijos Netos (Vagonetas)', key: 'fixedAssets' },
{ label: '  Activos Mantenidos para Venta (NIIF 5)', key: 'assetsHeldForSale' },
{ label: 'TOTAL ACTIVOS', key: 'totalAssets', total: true, emphasize: true },
{ label: 'PASIVOS Y PATRIMONIO', total: true, separator: true, emphasize: true },
{ label: '  Deuda Financiera', key: 'debt' },
{ label: '  Pasivos por Contrato (NIIF 15)', key: 'contractLiabilities' },
{ label: '  Pasivo seguro pass-through', key: 'insurancePassThroughLiability' },
{ label: 'TOTAL PASIVOS', key: 'totalLiabilities', total: true },
{ label: '  Patrimonio', key: 'equity' },
{ label: 'TOTAL PASIVOS + PATRIMONIO', key: 'totalLiabilitiesEquity', total: true, emphasize: true }
];
rows.forEach(row => {
const tr = document.createElement('tr');
if (row.total) tr.classList.add('bg-gray-50');
if (row.emphasize) tr.classList.add('font-bold', 'text-gray-900');
if (row.separator) tr.classList.add('border-t-2', 'border-gray-200');

const labelCell = document.createElement('td');
labelCell.textContent = row.label;
if (row.total || row.bold) labelCell.classList.add('font-bold');
if (row.isInfo || row.isContraAsset) labelCell.style.paddingLeft = '2.5rem';
tr.appendChild(labelCell);

financialResults.bs.forEach(yearData => {
const cell = document.createElement('td');
let value = yearData[row.key] || 0;
if (row.negative && value > 0) {
cell.textContent = '(' + formatCurrency(value) + ')';
cell.classList.add('negative');
} else {
cell.textContent = formatCurrency(value);
if (value > 0 && !row.negative) cell.classList.add('positive');
if (value < 0) cell.classList.add('negative');
}

if (value === 0) {
cell.style.color = '#94a3b8';
}
if (row.total) cell.classList.add('font-bold');
tr.appendChild(cell);
});

tbody.appendChild(tr);
});

const validationDiv = document.getElementById('balance-validation');
let balanceValid = true;
let maxDifference = 0;

financialResults.bs.forEach((bsYear, index) => {
const difference = Math.abs(bsYear.totalAssets - bsYear.totalLiabilitiesEquity);
maxDifference = Math.max(maxDifference, difference);
if (difference > BALANCE_TOLERANCE) balanceValid = false;
});
if (balanceValid) {
validationDiv.innerHTML = '<span class="text-green-600">✅ Balance validated: Total Assets = Total Liabilities + Equity.</span>';
validationDiv.classList.remove('bg-red-100', 'text-red-800');
validationDiv.classList.add('bg-green-100', 'text-green-800');
} else {
validationDiv.innerHTML = `<span class="text-red-600">❌ Balance error: Difference of ${formatCurrency(maxDifference)}. Review calculations.</span>`;
validationDiv.classList.remove('bg-green-100', 'text-red-800');
validationDiv.classList.add('bg-red-100', 'text-red-800');
}
log('✅ Balance Sheet Table updated and validated.');
}
// ===== IFRS DETAIL TABLES =====
/**
* Updates the IFRS 15, IFRS 9, and IFRS 5 sections with detailed data.
* Process: Injects dynamic HTML with specific tables and explanations for each standard.
*/
function updateNIIFTables() {
log('Updating IFRS detail tables...');
if (!financialResults.niifDetails || financialResults.niifDetails.length === 0) {
log('❌ No IFRS data to display.');
return;
}

const container15 = document.getElementById('niif15-container');
if (container15) {
container15.innerHTML = `
<div class="overflow-x-auto">
<table class="financial-table">
<thead>
<tr>
<th>Concepto</th>
<th>Año 1</th>
<th>Año 2</th>
<th>Año 3</th>
<th>Año 4</th>
<th>Año 5</th>
</tr>
</thead>
<tbody>
<tr>
<td>Margen Originación (Inicial por Cohorte Nueva)</td>
${financialResults.niifDetails.map(d => `<td>${formatCurrency(d.niif15.originationContractValueInitial || 0)}</td>`).join('')}
</tr>
<tr>
<td>Comisión Upfront (Inicial por Cohorte Nueva)</td>
${financialResults.niifDetails.map(d => `<td>${formatCurrency(d.niif15.upfrontCommissionInitial || 0)}</td>`).join('')}
</tr>
<tr>
<td>Margen Originación + Upfront (Reconocido P&L)</td>
${financialResults.niifDetails.map(d => `<td class="positive">${formatCurrency(d.niif15.recognizedOriginationRevenue || 0)}</td>`).join('')}
</tr>
<tr>
<td>Pasivos por Contrato (Acumulado)</td>
${financialResults.niifDetails.map(d => `<td>${formatCurrency(d.niif15.contractLiabilitiesBalance || 0)}</td>`).join('')}
</tr>
<tr>
<td>Ingresos GNV (Reconocido P&L)</td>
${financialResults.niifDetails.map(d => `<td>${formatCurrency(d.niif15.gnvCommissions || 0)}</td>`).join('')}
</tr>
<tr>
<td>Ingresos Refacciones (Reconocido P&L)</td>
${financialResults.niifDetails.map(d => `<td>${formatCurrency(d.niif15.sparePartsRevenue || 0)}</td>`).join('')}
</tr>
<tr>
<td>COGS Refacciones (NIIF 15)</td>
${financialResults.niifDetails.map(d => `<td>${formatCurrency(d.niif15.sparePartsCOGS || 0)}</td>`).join('')}
</tr>
<tr>
<td>Ingresos Marketplace (Reconocido P&L)</td>
${financialResults.niifDetails.map(d => `<td>${formatCurrency(d.niif15.marketplaceRevenue || 0)}</td>`).join('')}
</tr>
</tbody>
</table>
</div>
<div class="mt-4 p-4 bg-slate-800 rounded-lg text-sm text-slate-300">
<h5 class="font-semibold text-base mb-1 text-white">Explicación NIIF 15 (Ingresos de Contratos con Clientes)</h5>
<p class="mb-1">• NIIF 15 establece un modelo de 5 pasos para reconocer ingresos. Se reconocen cuando (o a medida que) se satisfacen las <strong>obligaciones de desempeño</strong>.</p>
<ul class="list-disc list-inside ml-4">
<li><strong>Comisiones de Originación (Margen + Upfront):</strong> Se difieren como "Pasivos por Contrato" y se reconocen <strong>a lo largo del tiempo</strong> a medida que se amortiza el principal del préstamo o linealmente sobre la vida del préstamo (para upfront).</li>
<li><strong>Servicios GNV y Marketplace:</strong> Se reconocen <strong>al devengo</strong> (a lo largo del tiempo) a medida que los servicios se proveen por las unidades activas.</li>
<li><strong>Servicios de Refacciones:</strong> Se reconocen <strong>en un punto en el tiempo</strong> (al momento de la entrega, asumido en el año de adición de la unidad).</li>
</ul>
<p class="mb-1">• Los ingresos por intereses se rigen por NIIF 9, no por NIIF 15.</p>
<p class="mb-1">• El Balance General ahora refleja los <strong>Pasivos por Contrato</strong> para los ingresos diferidos.</p>
</div>
`;
log('✅ IFRS 15 updated.');
}

const container9 = document.getElementById('niif9-container');
if (container9) {
const year5NIIF9 = financialResults.niifDetails[4]?.niif9;
if (year5NIIF9) {
container9.innerHTML = `
<div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
<div class="p-4 bg-sky-950 rounded-lg text-center text-sky-200">
<h5 class="font-semibold text-sky-400">ECL Etapa 1 (Año 5)</h5>
<p class="text-xl font-bold">${formatCurrency(year5NIIF9.eclByStage.stage1)}</p>
<p class="text-sm">PD: ${(year5NIIF9.pdStage1 * 100).toFixed(1)}%</p>
</div>
<div class="p-4 bg-amber-950 rounded-lg text-center text-amber-200">
<h5 class="font-semibold text-amber-400">ECL Etapa 2 (Año 5)</h5>
<p class="text-xl font-bold">${formatCurrency(year5NIIF9.eclByStage.stage2)}</p>
<p class="text-sm">PD: ${(year5NIIF9.pdStage2 * 100).toFixed(1)}%</p>
</div>
<div class="p-4 bg-rose-950 rounded-lg text-center text-rose-200">
<h5 class="font-semibold text-rose-400">ECL Etapa 3 (Año 5)</h5>
<p class="text-xl font-bold">${formatCurrency(year5NIIF9.eclByStage.stage3)}</p>
<p class="text-sm">PD: ${(year5NIIF9.pdStage3 * 100).toFixed(1)}% (+50% si >2 años)</p>
</div>
</div>
<div class="text-center p-4 bg-indigo-950 rounded-lg mb-4 text-indigo-200">
<h5 class="font-semibold text-indigo-400">Total Provisiones ECL Antes de Ajustes</h5>
<p class="text-2xl font-bold">${formatCurrency(year5NIIF9.totalECLBeforeAdjustment)}</p>
<p class="text-sm">LGD: ${(year5NIIF9.lgd * 100).toFixed(1)}%. Ajuste Económico: ${(year5NIIF9.economicAdjustmentFactor || 0).toFixed(2)}x</p>
</div>
<div class="text-center p-4 ${year5NIIF9.proteccionRodandoActiva ? 'bg-emerald-950 text-emerald-200' : 'bg-slate-800 text-slate-200'} rounded-lg">
<h5 class="font-semibold ${year5NIIF9.proteccionRodandoActiva ? 'text-emerald-400' : 'text-slate-400'}">Gasto por Provisiones NIIF 9 (P&L del Año 5)</h5>
<p class="text-2xl font-bold">${formatCurrency(year5NIIF9.provisionesConProteccion)}</p>
${year5NIIF9.proteccionRodandoActiva ?
`<p class="text-sm text-emerald-300"> <strong>✅ Reducción por Protección: ${formatCurrency(year5NIIF9.reduccionPorProteccion)}</strong></p>` :
'<p class="text-sm text-slate-400">Protección Rodando inactiva</p>'}
</div>
<div class="mt-4 text-center p-4 bg-slate-900 rounded-lg text-slate-200">
<h5 class="font-semibold text-slate-400">Saldo Acumulado de Provisiones NIIF 9 (Balance Año 5)</h5>
<p class="text-2xl font-bold">${formatCurrency(year5NIIF9.saldoProvisionesAcumulado)}</p>
<p class="text-sm">Este es el saldo que aparece en el Balance General.</p>
</div>
<div class="mt-4 p-4 bg-slate-800 rounded-lg text-sm text-slate-300">
<h5 class="font-semibold text-base mb-1 text-white">Explicación NIIF 9 (Instrumentos Financieros)</h5>
<p class="mb-1">• NIIF 9 requires the recognition of expected credit loss (ECL) provisions on financial instruments (loan portfolio).</p>
<p class="mb-1">• <strong>Three-Stage Model:</strong> The portfolio is segmented by risk.</p>
<ul class="list-disc list-inside ml-4">
<li><strong>Stage 1:</strong> Loans with low credit risk (12-month PD).</li>
<li><strong>Stage 2:</strong> Loans with significant increase in risk (lifetime PD).</li>
<li><strong>Stage 3:</strong> Loans with credit impairment (lifetime PD).</li>
</ul>
<p class="mb-1">• <strong>ECL Calculation:</strong> ECL = Average Exposure × Probability of Default (PD) × Loss Given Default (LGD).</p>
<p class="mb-1">• <strong>Dynamic PD:</strong> PD is adjusted according to loan age (increases 50% if > 2 years) to reflect increasing risk.</p>
<p class="mb-1">• <strong>Prospective Information:</strong> The economic adjustment factor allows incorporating future expectations about credit risk.</p>
<p class="mb-1">• "Protección Rodando" simula un mecanismo que reduce el gasto de provisiones finales.</p>
</div>
`;
log('✅ IFRS 9 updated.');
} else {
log('⚠️ IFRS 9 data for Year 5 incomplete.');
}
}

const container5 = document.getElementById('niif5-container');
if (container5) {
const year5NIIF5 = financialResults.niifDetails[4]?.niif5;
if (year5NIIF5) {
container5.innerHTML = `
<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
<div class="p-4 bg-purple-950 rounded-lg text-center text-purple-200">
<h5 class="font-semibold text-purple-400">Unidades Reposadas (Año 5)</h5>
<p class="text-xl font-bold">${formatCurrency(year5NIIF5.unidadesClasificadasAnuales.toFixed(0))}</p>
<p class="text-sm">Unidades reclasificadas como mantenidas para venta este año.</p>
</div>
<div class="p-4 bg-indigo-950 rounded-lg text-center text-indigo-200">
<h5 class="font-semibold text-indigo-400">Valor en Libros Original (Activos Reposedos Año 5)</h5>
<p class="text-xl font-bold">${formatCurrency(year5NIIF5.valorEnLibrosClasificado)}</p>
<p class="text-sm">Valor contable de las unidades clasificadas para venta en el Año 5.</p>
</div>
<div class="p-4 bg-blue-950 rounded-lg text-center text-blue-200">
<h5 class="font-semibold text-blue-400">Valor Razonable Neto (Año 5)</h5>
<p class="text-xl font-bold">${formatCurrency(year5NIIF5.valorRazonableMenosCostos)}</p>
<p class="text-sm">Valor de venta esperado menos costos de venta.</p>
</div>
<div class="p-4 ${year5NIIF5.perdidaPorDeterioro > 0 ? 'bg-rose-950 text-rose-200' : 'bg-emerald-950 text-emerald-200'} rounded-lg">
<h5 class="font-semibold ${year5NIIF5.perdidaPorDeterioro > 0 ? 'text-rose-400' : 'text-emerald-400'}">Pérdida por Deterioro (Año 5)</h5>
<p class="text-xl font-bold">${formatCurrency(year5NIIF5.perdidaPorDeterioro > 0 ? year5NIIF5.perdidaPorDeterioro : 0)}</p>
<p class="text-sm">Impacto en el Estado de Resultados por la reclasificación.</p>
</div>
</div>
<div class="mt-4 text-center p-4 bg-slate-900 rounded-lg text-slate-200">
<h5 class="font-semibold text-slate-400">Saldo Acumulado de Activos NIIF 5 (Año 5)</h5>
<p class="text-2xl font-bold">${formatCurrency(year5NIIF5.saldoActivosParaVentaAcumulado)}</p>
<p class="text-sm">Este es el saldo que aparece en el Balance General.</p>
</div>
<div class="mt-4 p-4 bg-slate-800 rounded-lg text-sm text-slate-300">
<h5 class="font-semibold text-base mb-1 text-white">Explicación NIIF 5 (Activos No Corrientes Mantenidos para la Venta)</h5>
<p class="mb-1">• Non-current assets (vans) expected to be sold in the short term are classified as "Held for Sale".</p>
<p class="mb-1">• These assets are measured at the lower of their carrying amount and fair value less costs to sell. Their depreciation is suspended.</p>
<p class="mb-1">• An impairment loss is recognized if the carrying amount exceeds the net fair value less costs to sell. Gains on reversal of impairment are limited to the original loss.</p>
</div>
`;
log('✅ IFRS 5 updated.');
} else {
log('⚠️ IFRS 5 data for Year 5 incomplete.');
}
}
}

// ===== CHARTS (Chart.js) =====
/**
* Initializes Chart.js instances for the charts.
*/
function initializeCharts() {
try {
Object.keys(charts).forEach(key => {
if (charts[key]) {
charts[key].destroy();
}
});
charts = {};
if (typeof Chart !== 'undefined') {
    Chart.defaults.animation = false;
    Chart.defaults.responsiveAnimationDuration = 0;
}
// Funding Cascade Chart
const ctx1 = document.getElementById('fundingCascadeChart');
if (ctx1) {
charts.fundingCascade = new Chart(ctx1, {
type: 'bar',
data: {
labels: ['Año 0', 'Año 1', 'Año 2', 'Año 3', 'Año 4', 'Año 5'],
datasets: [
    { label: 'Equity', data: [0, 0, 0, 0, 0, 0], backgroundColor: '#22d3ee', stack: 'funding' },
    { label: 'SINOSURE', data: [0, 0, 0, 0, 0, 0], backgroundColor: '#facc15', stack: 'funding' },
    { label: 'Bridge / Warehousing', data: [0, 0, 0, 0, 0, 0], backgroundColor: '#c084fc', stack: 'funding' },
    { label: 'Deuda Comercial', data: [0, 0, 0, 0, 0, 0], backgroundColor: '#fb923c', stack: 'funding' },
    { label: 'Venture Debt', data: [0, 0, 0, 0, 0, 0], backgroundColor: '#f87171', stack: 'funding' }
]
},
options: {
responsive: true,
maintainAspectRatio: false,
interaction: { mode: 'index', intersect: false },
plugins: {
    legend: { position: 'bottom', labels: { color: '#94a3b8' } },
    tooltip: {
        callbacks: {
            label: ctx => `${ctx.dataset.label}: ${formatCurrency((ctx.parsed.y || 0) * 1000000)}`
        }
    }
},
scales: {
    x: { stacked: true, ticks: { color: '#94a3b8' } },
    y: {
        stacked: true,
        ticks: {
            color: '#94a3b8',
            callback: value => `$${value.toFixed(0)}M`
        }
    }
}
}
});
}
// Revenue Mix Chart
const ctx2 = document.getElementById('revenueMixChart');
if (ctx2) {
charts.revenueMix = new Chart(ctx2, {
type: 'line',
data: {
labels: ['Año 1', 'Año 2', 'Año 3', 'Año 4', 'Año 5'],
datasets: [
    { label: 'Intereses', data: [0, 0, 0, 0, 0], borderColor: '#38bdf8', backgroundColor: 'rgba(56, 189, 248, 0.25)', fill: true, stack: 'revenues' },
    { label: 'Comisiones GNV', data: [0, 0, 0, 0, 0], borderColor: '#34d399', backgroundColor: 'rgba(52, 211, 153, 0.25)', fill: true, stack: 'revenues' },
    { label: 'Marketplace', data: [0, 0, 0, 0, 0], borderColor: '#a855f7', backgroundColor: 'rgba(168, 85, 247, 0.25)', fill: true, stack: 'revenues' },
    { label: 'Origination', data: [0, 0, 0, 0, 0], borderColor: '#f97316', backgroundColor: 'rgba(249, 115, 22, 0.25)', fill: true, stack: 'revenues' },
    { label: 'Refacciones', data: [0, 0, 0, 0, 0], borderColor: '#fbbf24', backgroundColor: 'rgba(251, 191, 36, 0.25)', fill: true, stack: 'revenues' }
]
},
options: {
responsive: true,
maintainAspectRatio: false,
interaction: { mode: 'index', intersect: false },
plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8' } } },
scales: {
    x: { stacked: true, ticks: { color: '#94a3b8' } },
    y: {
        stacked: true,
        ticks: {
            color: '#94a3b8',
            callback: value => `$${value.toFixed(0)}M`
        }
    }
}
}
});
}
// Units vs Cash Chart
const ctxUnits = document.getElementById('unitsCashChart');
if (ctxUnits) {
charts.unitsCash = new Chart(ctxUnits, {
type: 'bar',
data: {
labels: ['Año 1', 'Año 2', 'Año 3', 'Año 4', 'Año 5'],
datasets: [
    { type: 'bar', label: 'Unidades Colocadas', data: [0,0,0,0,0], backgroundColor: '#38bdf8', yAxisID: 'yUnits' },
    { type: 'line', label: 'Cash After Financing (M)', data: [0,0,0,0,0], borderColor: '#f97316', backgroundColor: 'rgba(249, 115, 22, 0.15)', fill: true, tension: 0.3, yAxisID: 'yCash' }
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8' } } },
scales: {
    yUnits: {
        position: 'left',
        ticks: { color: '#94a3b8', callback: value => `${value}` },
        title: { display: true, text: 'Unidades', color: '#94a3b8' }
    },
    yCash: {
        position: 'right',
        grid: { drawOnChartArea: false },
        ticks: { color: '#94a3b8', callback: value => `$${value.toFixed(0)}M` },
        title: { display: true, text: 'Cash After Financing (MXN millones)', color: '#94a3b8' }
    },
    x: { ticks: { color: '#94a3b8' } }
}
}
});
}
// Capital Spread Chart
const ctxSpread = document.getElementById('capitalSpreadChart');
if (ctxSpread) {
charts.capitalSpread = new Chart(ctxSpread, {
type: 'line',
data: {
labels: ['Año 1', 'Año 2', 'Año 3', 'Año 4', 'Año 5'],
datasets: [
    { label: 'WACC', data: [0,0,0,0,0], borderColor: '#22d3ee', backgroundColor: 'rgba(34, 211, 238, 0.15)', fill: true, tension: 0.3 },
    { label: 'ROE', data: [0,0,0,0,0], borderColor: '#10b981', tension: 0.3, fill: false },
    { label: 'ROIC', data: [0,0,0,0,0], borderColor: '#f97316', tension: 0.3, fill: false }
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8' } } },
scales: {
    y: {
        ticks: { color: '#94a3b8', callback: value => `${value.toFixed(1)}%` },
        title: { display: true, text: 'Porcentaje', color: '#94a3b8' }
    },
    x: { ticks: { color: '#94a3b8' } }
}
}
});
}
// Risk Ratios Chart
const ctxRisk = document.getElementById('riskRatiosChart');
if (ctxRisk) {
charts.riskRatios = new Chart(ctxRisk, {
type: 'bar',
data: {
labels: ['Año 1', 'Año 2', 'Año 3', 'Año 4', 'Año 5'],
datasets: [
    { type: 'line', label: 'DSCR', data: [0,0,0,0,0], borderColor: '#34d399', tension: 0.3, fill: false, yAxisID: 'yRatios' },
    { type: 'line', label: 'Debt / Equity', data: [0,0,0,0,0], borderColor: '#f87171', tension: 0.3, fill: false, yAxisID: 'yRatios' },
    { label: 'Cash Balance (M)', data: [0,0,0,0,0], backgroundColor: '#3b82f6', yAxisID: 'yCash' }
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8' } } },
scales: {
    yRatios: {
        position: 'left',
        ticks: { color: '#94a3b8', callback: value => value.toFixed(1) + 'x' },
        title: { display: true, text: 'Ratios', color: '#94a3b8' },
        min: 0
    },
    yCash: {
        position: 'right',
        grid: { drawOnChartArea: false },
        ticks: { color: '#94a3b8', callback: value => `$${value.toFixed(0)}M` },
        title: { display: true, text: 'Cash (MXN millones)', color: '#94a3b8' }
    },
    x: { ticks: { color: '#94a3b8' } }
}
}
});
}
// Cash Coverage Chart
const ctxCoverage = document.getElementById('cashCoverageChart');
if (ctxCoverage) {
charts.cashCoverage = new Chart(ctxCoverage, {
type: 'bar',
data: {
labels: ['Año 1', 'Año 2', 'Año 3', 'Año 4', 'Año 5'],
datasets: [
    { label: 'CAPEX (M)', data: [0,0,0,0,0], backgroundColor: '#f97316', stack: 'capex' },
    { label: 'Fondeo Total (M)', data: [0,0,0,0,0], backgroundColor: '#34d399', stack: 'capex' },
    { type: 'line', label: 'Cobertura %', data: [0,0,0,0,0], borderColor: '#22d3ee', backgroundColor: 'rgba(34, 211, 238, 0.2)', fill: false, yAxisID: 'yPct', tension: 0.3 },
    { type: 'line', label: 'Cash After Financing (M)', data: [0,0,0,0,0], borderColor: '#a855f7', backgroundColor: 'rgba(168,85,247,0.15)', fill: true, yAxisID: 'y', tension: 0.3 }
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8' } } },
scales: {
    y: {
        stacked: true,
        ticks: { color: '#94a3b8', callback: value => `$${value.toFixed(0)}M` },
        title: { display: true, text: 'MXN millones', color: '#94a3b8' }
    },
    yPct: {
        position: 'right',
        grid: { drawOnChartArea: false },
        ticks: { color: '#94a3b8', callback: value => `${value.toFixed(0)}%` },
        title: { display: true, text: 'Cobertura / Liquidez', color: '#94a3b8' }
    },
    x: { ticks: { color: '#94a3b8' } }
}
}
});
}
// Cash Flow Resilience Chart
const ctx3 = document.getElementById('cashFlowResilienceChart');
if (ctx3) {
charts.cashFlowResilienceChart = new Chart(ctx3, {
type: 'bar',
data: {
labels: ['Año 1', 'Año 2', 'Año 3', 'Año 4', 'Año 5'],
datasets: [
{ label: 'Operativo', data: [0,0,0,0,0], backgroundColor: '#10b981' },
{ label: 'Inversión', data: [0,0,0,0,0], backgroundColor: '#ef4444' },
{ label: 'Financiamiento', data: [0,0,0,0,0], backgroundColor: '#3b82f6' }
]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: { legend: { position: 'bottom', labels: { color: '#94a3b8' } } },
scales: {
x: { ticks: { color: '#94a3b8' } },
y: { ticks: { color: '#94a3b8' } }
}
}
});
}
// Capital Efficiency Chart
const ctx7 = document.getElementById('capitalEfficiencyChart');
if (ctx7) {
charts.capitalEfficiencyChart = new Chart(ctx7, {
type: 'doughnut',
data: {
labels: ['Conductores Actual', 'Target Serie A', 'Industria Promedio'],
datasets: [{
data: [750, 750, 900],
backgroundColor: ['#10b981', '#3b82f6', '#94a3b8']
}]
},
options: {
responsive: true,
maintainAspectRatio: false,
plugins: {
legend: {
position: 'bottom',
labels: { color: '#94a3b8', font: { size: 10 } }
}
}
}
});
}
log('✅ New Rodando charts initialized');
} catch (error) {
log(`❌ Error: ${error.message}`);
}
}

/**
* Updates the chart data with current financial results.
*/
function updateCharts() {
try {
if (!financialResults.pl.length) return;
// Update Funding Cascade Chart
if (charts.fundingCascade && financialResults.cf.length) {
    const fundingLabels = [];
    const equityData = [];
    const sinosureData = [];
    const bridgeData = [];
    const commercialData = [];
    const ventureData = [];

    financialResults.cf.forEach(cf => {
        const label = cf.year === 0 ? 'Año 0' : `Año ${cf.year}`;
        fundingLabels.push(label);
        const equityDraw = Math.max(0, (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0) + (cf.equityInjection || 0));
        equityData.push(equityDraw / 1000000);
        sinosureData.push(Math.max(0, cf.sinosureDrawn || 0) / 1000000);
        bridgeData.push(Math.max(0, cf.bridgeFundingRaised || 0) / 1000000);
        commercialData.push(Math.max(0, cf.additionalFundingRaised || 0) / 1000000);
        ventureData.push(Math.max(0, cf.currentYearVentureDebtDraw || 0) / 1000000);
    });

    charts.fundingCascade.data.labels = fundingLabels;
    if (charts.fundingCascade.data.datasets.length >= 5) {
        charts.fundingCascade.data.datasets[0].data = equityData;
        charts.fundingCascade.data.datasets[1].data = sinosureData;
        charts.fundingCascade.data.datasets[2].data = bridgeData;
        charts.fundingCascade.data.datasets[3].data = commercialData;
        charts.fundingCascade.data.datasets[4].data = ventureData;
    }
    charts.fundingCascade.update();
}

// Update Revenue Mix Chart
if (charts.revenueMix) {
    const revenueLabels = financialResults.pl.map((_, idx) => `Año ${idx + 1}`);
    const interestData = [];
    const gnvData = [];
    const marketplaceData = [];
    const originationData = [];
    const sparePartsData = [];

    financialResults.pl.forEach(plYear => {
        interestData.push(Math.max(0, plYear.interestRevenue || 0) / 1000000);
        gnvData.push(Math.max(0, plYear.gnvCommissions || 0) / 1000000);
        marketplaceData.push(Math.max(0, plYear.marketplaceRevenue || 0) / 1000000);
        originationData.push(Math.max(0, plYear.recognizedOriginationRevenue || 0) / 1000000);
        sparePartsData.push(Math.max(0, plYear.sparePartsRevenue || 0) / 1000000);
    });

    charts.revenueMix.data.labels = revenueLabels;
    if (charts.revenueMix.data.datasets.length >= 5) {
        charts.revenueMix.data.datasets[0].data = interestData;
        charts.revenueMix.data.datasets[1].data = gnvData;
        charts.revenueMix.data.datasets[2].data = marketplaceData;
        charts.revenueMix.data.datasets[3].data = originationData;
        charts.revenueMix.data.datasets[4].data = sparePartsData;
    }
    charts.revenueMix.update();
}

// Update Units vs Cash Chart
if (charts.unitsCash) {
    const labels = financialResults.pl.map((_, idx) => `Año ${idx + 1}`);
    const unitsData = financialResults.pl.map(plYear => Math.max(0, plYear.addedUnits || 0));
    const cfByYear = financialResults.cf.reduce((acc, cf) => {
        if (typeof cf.year === 'number') acc[cf.year] = cf;
        return acc;
    }, {});
    const cashData = labels.map((label, idx) => {
        const year = idx + 1;
        const cf = cfByYear[year] || {};
        return ((cf.cashAfterFinancing !== undefined ? cf.cashAfterFinancing : cf.netCash) || 0) / 1000000;
    });

    charts.unitsCash.data.labels = labels;
    if (charts.unitsCash.data.datasets.length >= 2) {
        charts.unitsCash.data.datasets[0].data = unitsData;
        charts.unitsCash.data.datasets[1].data = cashData;
    }
    charts.unitsCash.update();
}

// Update Capital Spread Chart
if (charts.capitalSpread) {
    const labels = financialResults.pl.map((_, idx) => `Año ${idx + 1}`);
    const cfByYear = financialResults.cf.reduce((acc, cf) => {
        if (typeof cf.year === 'number') acc[cf.year] = cf;
        return acc;
    }, {});

    const manualCostEquity = (typeof modelData.costOfEquityManual === 'number' && modelData.costOfEquityManual > 0)
        ? modelData.costOfEquityManual / 100
        : 0.25;
    const costEquity = ((typeof financialResults.tirEquity === 'number' && isFinite(financialResults.tirEquity) && financialResults.tirEquity > 0)
        ? financialResults.tirEquity / 100
        : manualCostEquity);
    const sinosureRate = (typeof sinosureConfig !== 'undefined' && typeof sinosureConfig.rate === 'number' && sinosureConfig.rate > 0 ? sinosureConfig.rate : 6) / 100;
    const commercialRate = (modelData.commercialDebtRate || 0) / 100;
    const ventureRate = (modelData.ventureDebtRate || 0) / 100;

    let cumulativeEquity = (modelData.seed || 0) + (modelData.seriesA || 0);
    let cumulativeSinosure = 0;
    let cumulativeCommercial = 0;
    let cumulativeVenture = 0;

    const waccData = [];
    const roeData = [];
    const roicData = [];

    financialResults.pl.forEach((_, idx) => {
        const year = idx + 1;
        const cf = cfByYear[year] || {};
        const equityDraw = Math.max(0, (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0) + (cf.equityInjection || 0));
        const sinosureDraw = Math.max(0, cf.sinosureDrawn || 0);
        const commercialDraw = Math.max(0, cf.additionalFundingRaised || 0);
        const ventureDraw = Math.max(0, cf.currentYearVentureDebtDraw || 0);

        cumulativeEquity += equityDraw;
        cumulativeSinosure += sinosureDraw;
        cumulativeCommercial += commercialDraw;
        cumulativeVenture += ventureDraw;

        const totalCapital = cumulativeEquity + cumulativeSinosure + cumulativeCommercial + cumulativeVenture;
        const wacc = totalCapital > 0 ? (
            (cumulativeEquity * costEquity) +
            (cumulativeSinosure * sinosureRate) +
            (cumulativeCommercial * commercialRate) +
            (cumulativeVenture * ventureRate)
        ) / totalCapital : 0;

        waccData.push(wacc * 100);
        roeData.push(typeof financialResults.roe?.[idx] === 'number' ? financialResults.roe[idx] : 0);
        roicData.push(typeof financialResults.roic?.[idx] === 'number' ? financialResults.roic[idx] : 0);
    });

    charts.capitalSpread.data.labels = labels;
    if (charts.capitalSpread.data.datasets.length >= 3) {
        charts.capitalSpread.data.datasets[0].data = waccData;
        charts.capitalSpread.data.datasets[1].data = roeData;
        charts.capitalSpread.data.datasets[2].data = roicData;
    }
    charts.capitalSpread.update();
}

// Update Risk Ratios Chart
if (charts.riskRatios) {
    const labels = financialResults.pl.map((_, idx) => `Año ${idx + 1}`);
    const cfByYear = financialResults.cf.reduce((acc, cf) => {
        if (typeof cf.year === 'number') acc[cf.year] = cf;
        return acc;
    }, {});
    const bsByYear = financialResults.bs.reduce((acc, bsEntry, idx) => {
        acc[idx + 1] = bsEntry;
        return acc;
    }, {});

    const dscrData = [];
    const leverageData = [];
    const cashBalanceData = [];

    financialResults.pl.forEach((plYear, idx) => {
        const year = idx + 1;
        const cf = cfByYear[year] || {};
        const bs = bsByYear[year] || {};

        const debtService = (plYear.interestExpense || 0) + Math.max(0, cf.debtPrincipalRepayment || 0) + Math.max(0, cf.balloonPayment || 0);
        const dscr = safeRatio(plYear.ebitda || 0, debtService, null);
        dscrData.push(dscr !== null && isFinite(dscr) ? Number(dscr.toFixed(2)) : null);

        const leverage = bs.equity ? (bs.debt || 0) / bs.equity : null;
        leverageData.push(leverage !== null && isFinite(leverage) ? Number(leverage.toFixed(2)) : null);

        cashBalanceData.push(((bs.cash || 0) / 1000000));
    });

    charts.riskRatios.data.labels = labels;
    if (charts.riskRatios.data.datasets.length >= 3) {
        charts.riskRatios.data.datasets[0].data = dscrData;
        charts.riskRatios.data.datasets[1].data = leverageData;
        charts.riskRatios.data.datasets[2].data = cashBalanceData;
    }
    charts.riskRatios.update();
}

// Update Cash Coverage Chart
if (charts.cashCoverage) {
    const labels = financialResults.pl.map((_, idx) => `Año ${idx + 1}`);
    const cfByYear = financialResults.cf.reduce((acc, cf) => {
        if (typeof cf.year === 'number') acc[cf.year] = cf;
        return acc;
    }, {});

    const capexData = [];
    const fundingData = [];
    const coverageData = [];
    const cashAfterData = [];

    const unitCost = getTotalPackageCost();

    financialResults.pl.forEach((plYear, idx) => {
        const year = idx + 1;
        const cf = cfByYear[year] || {};
        const capex = Math.max(0, (plYear.addedUnits || 0) * unitCost) / 1000000;
        const equityDraw = Math.max(0, (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0) + (cf.equityInjection || 0));
        const sinosureDraw = Math.max(0, cf.sinosureDrawn || 0);
        const commercialDraw = Math.max(0, cf.additionalFundingRaised || 0);
        const ventureDraw = Math.max(0, cf.currentYearVentureDebtDraw || 0);
        const totalFunding = (equityDraw + sinosureDraw + commercialDraw + ventureDraw) / 1000000;
        const coverage = capex > 0 ? (totalFunding / capex) * 100 : 0;
        const cashAfter = ((cf.cashAfterFinancing !== undefined ? cf.cashAfterFinancing : cf.netCash) || 0) / 1000000;

        capexData.push(capex);
        fundingData.push(totalFunding);
        coverageData.push(coverage);
        cashAfterData.push(cashAfter);
    });

    charts.cashCoverage.data.labels = labels;
    if (charts.cashCoverage.data.datasets.length >= 4) {
        charts.cashCoverage.data.datasets[0].data = capexData;
        charts.cashCoverage.data.datasets[1].data = fundingData;
        charts.cashCoverage.data.datasets[2].data = coverageData;
        charts.cashCoverage.data.datasets[3].data = cashAfterData;
    }
    charts.cashCoverage.update();
}

// Update Capital Efficiency Chart
if (charts.capitalEfficiencyChart) {
const totalUnits = financialResults.pl.reduce((sum, pl) => sum + (pl.addedUnits || 0), 0);
const totalCapex = totalUnits * getTotalPackageCost();
const capexPerUnit = totalUnits > 0 ? totalCapex / totalUnits / 1000 : 0;
charts.capitalEfficiencyChart.data.labels = ['Conductores Actual', 'Target A', 'Industria'];
charts.capitalEfficiencyChart.data.datasets = [{
data: [capexPerUnit, 750, 900],
backgroundColor: ['#10b981', '#3b82f6', '#94a3b8']
}];
charts.capitalEfficiencyChart.update();
}
// Update Cash Flow Resilience Chart
if (charts.cashFlowResilienceChart && financialResults.cf.length >= 2) {
const cfYears = financialResults.cf.filter(cf => (cf.year || 0) > 0);
const labels = cfYears.map(cf => `Año ${cf.year}`);
const operatingCF = cfYears.map(cf => (cf.operatingCash || 0) / 1000000);
const investingCF = cfYears.map(cf => (cf.investingCash || 0) / 1000000);
const financingCF = cfYears.map(cf => (cf.financingCash || 0) / 1000000);
charts.cashFlowResilienceChart.data.labels = labels;
charts.cashFlowResilienceChart.data.datasets = [
{ label: 'Operativo', data: operatingCF, backgroundColor: '#10b981' },
{ label: 'Inversión', data: investingCF, backgroundColor: '#ef4444' },
{ label: 'Financiamiento', data: financingCF, backgroundColor: '#3b82f6' }
];
charts.cashFlowResilienceChart.update();
}
log('✅ Rodando charts updated');
} catch (error) {
log(`Error updating charts: ${error.message}`);
}
}

/**
 * NUEVO: Valida y ajusta automáticamente las unidades si el financiamiento es insuficiente
 */
function validateCapexConstraints() {
    let availableFunding = (modelData.seed || 0) + (modelData.seriesA || 0);
    let cumulativeCapex = 0;

    for (let year = 0; year < 5; year++) {
        const currentYear = year + 1;
        const yearCapex = modelData.unitsPerYear[year] * getTotalPackageCost();
        cumulativeCapex += yearCapex;

        availableFunding += (plannedFinancingData[`partnerCapitalizationYear${currentYear}`] || 0) +
                              (plannedFinancingData[`seriesB_newInvestors_year${currentYear}`] || 0) +
                              (plannedFinancingData[`ventureDebtYear${currentYear}`] || 0) +
                              (plannedFinancingData[`commercialDebtYear${currentYear}`] || 0);

        if (cumulativeCapex > availableFunding * 1.1) {
            const maxAffordableUnits = Math.floor((availableFunding * 0.9) / getTotalPackageCost());
            const unitsUsedSoFar = modelData.unitsPerYear.slice(0, year).reduce((a, b) => a + b, 0);
            const adjustedUnits = Math.max(0, maxAffordableUnits - unitsUsedSoFar);

            log(`⚠️ Auto-ajustando Año ${currentYear} unidades de ${modelData.unitsPerYear[year]} a ${adjustedUnits}`);
            modelData.unitsPerYear[year] = adjustedUnits;

            const unitInput = document.getElementById(`unitsPerYear-${currentYear}`);
            if (unitInput) {
                unitInput.value = adjustedUnits;
                unitInput.style.borderColor = '#f59e0b';
            }
        }
    }
}

/**
 * NEW: Captures the user's financing plan before calculations overwrite modelData.
 */
function capturePlannedFinancing() {
    plannedFinancingData = {};
    const keysToCapture = [
        'ventureDebtYear1', 'ventureDebtYear2', 'ventureDebtYear3', 'ventureDebtYear4', 'ventureDebtYear5',
        'commercialDebtYear1', 'commercialDebtYear2', 'commercialDebtYear3', 'commercialDebtYear4', 'commercialDebtYear5',
        'partnerCapitalizationYear1', 'partnerCapitalizationYear2', 'partnerCapitalizationYear3', 'partnerCapitalizationYear4', 'partnerCapitalizationYear5',
        'seriesB_newInvestors_year2', 'seriesB_newInvestors_year3'
    ];
    keysToCapture.forEach(key => {
        plannedFinancingData[key] = modelData[key] || 0;
    });
}




/**
* Forces a manual recalculation of the model.
*/
// INTELLIGENT CAPITAL ALLOCATION FUNCTIONS
function optimizeCapitalAllocation(scenarioUnits) {
    const totalUnits = scenarioUnits.reduce((sum, units) => sum + units, 0);
    const unitCost = getTotalPackageCost();
    const totalCapex = totalUnits * unitCost;
    
    log(`🧠 Optimizing capital for ${totalUnits} units, $${(totalCapex/1000000).toFixed(0)}M CAPEX needed`);
    
    // INTELLIGENT FUNDING CASCADA
    let remainingNeed = totalCapex;
    const allocation = {
        seed: modelData.seed,                                           // $10M fixed
        seriesA: Math.min(modelData.seriesA, remainingNeed),           // Up to $50M
        sinosure: 0,
        bridgeDebt: 0,
        ventureDebt: 0,
        commercialDebt: 0,
        seriesB: 0
    };
    
    remainingNeed -= (allocation.seed + allocation.seriesA);
    
    // SINOSURE FIRST (if available, year 2+, 6% vs 18% VD)
    if (modelData.sinosureAvailable && remainingNeed > 0) {
        const sinosureMax = totalUnits * 365000; // $365K per unit coverage
        allocation.sinosure = Math.min(sinosureMax, remainingNeed);
        remainingNeed -= allocation.sinosure;
        log(`🇨🇳 SINOSURE: $${(allocation.sinosure/1000000).toFixed(0)}M at 6% (vs 18% VD savings)`);
    }
    
    // VENTURE DEBT (up to $100M line, 18%)
    if (remainingNeed > 0) {
        allocation.ventureDebt = Math.min(100000000, remainingNeed);
        remainingNeed -= allocation.ventureDebt;
    }
    
    // BRIDGE / WAREHOUSING (cuando SINOSURE no está disponible)
    if (!modelData.sinosureAvailable && remainingNeed > 0) {
        const bridgeLine = modelData.bridgeDebtLineAvailable || 0;
        if (bridgeLine > 0) {
            allocation.bridgeDebt = Math.min(bridgeLine, remainingNeed);
            remainingNeed -= allocation.bridgeDebt;
        }
    }
    
    // COMMERCIAL DEBT (up to $300M line, 14%)
    if (remainingNeed > 0) {
        allocation.commercialDebt = Math.min(300000000, remainingNeed);
        remainingNeed -= allocation.commercialDebt;
    }
    
    // SERIES B (if still needed, year 3)
    if (remainingNeed > 0) {
        allocation.seriesB = Math.max(70000000, remainingNeed); // At least planned $70M
        remainingNeed -= allocation.seriesB;
    }
    
    const deficit = Math.max(0, remainingNeed);
    
    log(`💰 Allocation: Seed=$${(allocation.seed/1000000).toFixed(0)}M, SeriesA=$${(allocation.seriesA/1000000).toFixed(0)}M, SINOSURE=$${(allocation.sinosure/1000000).toFixed(0)}M, Bridge=$${(allocation.bridgeDebt/1000000).toFixed(0)}M, CD=$${(allocation.commercialDebt/1000000).toFixed(0)}M, VD=$${(allocation.ventureDebt/1000000).toFixed(0)}M`);
    
    if (deficit > 0) {
        log(`🚨 FUNDING DEFICIT: $${(deficit/1000000).toFixed(0)}M additional capital needed`);
    }
    
    return { allocation, deficit, totalCapex };
}

function buildCapitalPlan(unitsPerYear) {
    const plan = [];
    const unitCost = getTotalPackageCost();
    let totalCapex = 0;
    unitsPerYear.forEach((units, index) => {
        const safeUnits = units || 0;
        const capex = safeUnits * unitCost;
        plan.push({ year: index + 1, units: safeUnits, capex });
        totalCapex += capex;
    });

    const result = optimizeCapitalAllocation(unitsPerYear);
    const allocation = result.allocation || result;
    const totals = {
        seed: allocation.seed || 0,
        seriesA: allocation.seriesA || 0,
        sinosure: allocation.sinosure || 0,
        bridge: allocation.bridgeDebt || 0,
        venture: allocation.ventureDebt || 0,
        commercial: allocation.commercialDebt || 0,
        seriesB: allocation.seriesB || 0
    };
    const funded = totals.seed + totals.seriesA + totals.sinosure + totals.bridge + totals.commercial + totals.venture + totals.seriesB;
    const computedCapex = result.totalCapex !== undefined ? result.totalCapex : totalCapex;
    const deficit = result.deficit !== undefined ? result.deficit : Math.max(0, computedCapex - funded);

    return {
        plan,
        totals,
        allocation: {
            seed: totals.seed,
            seriesA: totals.seriesA,
            sinosure: totals.sinosure,
            bridgeDebt: allocation.bridgeDebt || 0,
            ventureDebt: totals.venture,
            commercialDebt: totals.commercial,
            seriesB: totals.seriesB
        },
        deficit,
        totalCapex: computedCapex,
        unitsKey: JSON.stringify(unitsPerYear)
    };
}

function ensureCapitalPlan() {
    const unitsKey = JSON.stringify(modelData.unitsPerYear);
    if (!capitalPlanOutput || capitalPlanOutput.unitsKey !== unitsKey) {
        capitalPlanOutput = buildCapitalPlan(modelData.unitsPerYear);
    }
    return capitalPlanOutput;
}

function updateCapitalStructure(capitalPlan) {
    const { allocation } = capitalPlan;
    
    // RESET all planned financing to 0 first
    for (let i = 1; i <= 5; i++) {
        modelData[`ventureDebtYear${i}`] = 0;
        modelData[`commercialDebtYear${i}`] = 0;
        modelData[`partnerCapitalizationYear${i}`] = 0;
        modelData[`seriesB_newInvestors_year${i}`] = 0;
    }
    
    // INTELLIGENT ALLOCATION OVER TIME
    if (allocation.ventureDebt > 0) {
        modelData.ventureDebtYear1 = Math.min(50000000, allocation.ventureDebt);
        if (allocation.ventureDebt > 50000000) {
            modelData.ventureDebtYear2 = allocation.ventureDebt - 50000000;
        }
    }
    
    if (allocation.commercialDebt > 0) {
        const yearlyCommercial = allocation.commercialDebt / 3; // Spread over years 3-5
        modelData.commercialDebtYear3 = yearlyCommercial;
        modelData.commercialDebtYear4 = yearlyCommercial;
        if (allocation.commercialDebt > (yearlyCommercial * 2)) {
            modelData.commercialDebtYear5 = allocation.commercialDebt - (yearlyCommercial * 2);
        }
    }
    
    if (allocation.seriesB > 0) {
        modelData.seriesB_newInvestors_year3 = allocation.seriesB;
    }
    
    log(`✅ Capital structure updated for ${currentScenario} scenario`);
}

function forceCalculate() {
    log('🔄 Manual recalculation requested.');
    capturePlannedFinancing();
    hardResetEngine();
    capitalPlanOutput = buildCapitalPlan(modelData.unitsPerYear);
    updateCapitalStructure(capitalPlanOutput);
    // MEJORA: Es necesario redibujar los controles de unidades para actualizar los máximos dinámicos.
    setupControlGroup('planCrecimiento', 'plan-crecimiento-controls');
    if (!calculateFinancials()) {
        log('❌ Manual recalculation failed.');
    } else {
        updateUI();
        // Validation logs to confirm funding ≈ capex after cohorts are created
        try {
            const capexCheck = calculateTotalCapex();
            const fundingCheck = totalFundingFromCF();
            console.log('CAPEX:', capexCheck);
            console.log('FUNDING (CF):', fundingCheck);
            console.log('Coverage (% via CF):', capexCheck > 0 ? (fundingCheck / capexCheck) * 100 : 0);
        } catch (e) { /* ignore validation log errors */ }
        runGlobalChecks(); // Run global checks after manual recalculation
        
        // ===== STEP 5: INTEGRATE CONSTRAINT SYSTEM SAFELY =====
        try {
            // Update constraint dashboard
            updateConstraintDashboard();
            
            // Update protected capital motor
            updateProtectedCapitalMotor();
            
            // Apply smart constraints to inputs
            enhanceUnitInputsWithConstraints();
            
            log('✅ Constraint system updated successfully');
        } catch (error) {
            log(`⚠️ Constraint system error (non-critical): ${error.message}`);
            // Don't break the main calculation if constraints fail
        }
        
        log('✅ Manual recalculation completed.');
    }
}

function handleManualRecalc(buttonEl) {
    if (buttonEl && !buttonEl.disabled) {
        buttonEl.disabled = true;
        buttonEl.classList.add('opacity-70', 'cursor-not-allowed');
        setTimeout(() => {
            buttonEl.disabled = false;
            buttonEl.classList.remove('opacity-70', 'cursor-not-allowed');
        }, 1000);
    }
    forceCalculate();
}



// ===== USER CONTROL CONFIGURATION =====

/**
* Helper function to create and append a slider control.
* @param {Object} config - Configuration object for the slider.
* @param {HTMLElement} container - The DOM element to append the control to.
*/
function createSliderControl(config, container) {
const div = document.createElement('div');
div.className = 'control-grid gap-2';
const label = document.createElement('label');
label.className = "text-sm font-semibold text-slate-200 flex items-center gap-2";
if (config.tooltip) {
label.setAttribute('data-tooltip', config.tooltip);
}
const labelText = document.createElement('span');
labelText.textContent = config.label;
label.appendChild(labelText);

if (config.tooltip) {
    const infoIcon = document.createElement('i');
    infoIcon.setAttribute('data-lucide', 'help-circle');
    infoIcon.className = 'w-4 h-4 text-sky-300 shrink-0';
    infoIcon.setAttribute('aria-hidden', 'true');
    label.appendChild(infoIcon);
}

const sliderContainer = document.createElement('div');
sliderContainer.className = 'slider-container';

const slider = document.createElement('input');
slider.type = 'range';
slider.id = `${config.id}-input`;
slider.min = config.min;
slider.max = config.max;
slider.step = config.step;
slider.value = modelData[config.id];
slider.className = 'input-slider';
sliderContainer.appendChild(slider);
label.htmlFor = slider.id;

const display = document.createElement('span');
display.id = `${config.id}-valor`;
display.className = "font-bold text-teal-400 numeric-display";
display.textContent = (config.format && typeof config.format === 'function') ? config.format(modelData[config.id]) : modelData[config.id].toString();
sliderContainer.appendChild(display);
div.appendChild(label);
div.appendChild(sliderContainer);

if (config.tooltip) {
    const helper = document.createElement('p');
    helper.className = 'text-xs text-slate-400 leading-relaxed bg-slate-900/60 border border-slate-800 rounded-lg px-3 py-2';
    helper.textContent = config.tooltip;
    div.appendChild(helper);
}
container.appendChild(div);

slider.addEventListener('input', function() {
let value = parseFloat(this.value);
modelData[config.id] = value;
display.textContent = config.format(value);

this.classList.remove('validation-error', 'validation-warning', 'validation-success');

if (['vanPrice', 'vanCost'].includes(config.id)) {
const unitEcon = evaluateUnitEconomics();
if (unitEcon.marginPercent < 10) {
this.classList.add('validation-error');
showWarning(`🚨 Unit economics críticos: ${unitEcon.marginPercent.toFixed(1)}% margin. Mínimo Serie A: 15%`);
} else if (unitEcon.marginPercent < 15) {
this.classList.add('validation-warning');
showWarning(`⚠️ Unit economics bajos: ${unitEcon.marginPercent.toFixed(1)}% margin. Target Serie A: 20%+`);
} else {
this.classList.add('validation-success');
}
}

if (config.id === 'tasaInteres') {
if (value < 22) {
this.classList.add('validation-error');
showWarning(`🚨 Tasa insostenible: ${value}%. Unit economics requieren mínimo 22% para Serie A viability`);
} else if (value < 25) {
this.classList.add('validation-warning');
showWarning(`⚠️ Tasa baja: ${value}%. Sweet spot Serie A: 25-30% para margins defendibles`);
} else {
this.classList.add('validation-success');
}
}

if (['ventureDebtRate', 'commercialDebtRate'].includes(config.id)) {
const debtService = calculateDebtServiceCoverage();
if (debtService.dscr !== null && debtService.dscr < 1.2) {
this.classList.add('validation-error');
showWarning(`🚨 DSCR crítico: ${debtService.dscr.toFixed(1)}x. Debt service: ${formatCurrency(debtService.totalDebtService)}, EBITDA est: ${formatCurrency(debtService.estimatedEBITDA)}`);
} else if (debtService.dscr !== null && debtService.dscr < 1.5) {
this.classList.add('validation-warning');
showWarning(`⚠️ DSCR bajo: ${debtService.dscr.toFixed(1)}x. Target Serie A: >1.5x para debt comfort`);
} else {
this.classList.add('validation-success');
}
}

if (['pdStage1', 'pdStage2'].includes(config.id)) {
const configItem = controlsConfig.riesgoYSalida.find(c => c.id === config.id);
if (configItem && configItem.investorRange) {
const range = configItem.investorRange;
const valuePercent = value * 100;
if (valuePercent < range.green[0] || valuePercent > range.red[1]) {
this.classList.add('validation-warning');
showWarning(`📊 Assumption fuera de benchmark: ${valuePercent.toFixed(1)}%. Range realista: ${range.green[0]}-${range.green[1]}%`);
} else if (valuePercent >= range.green[0] && valuePercent <= range.green[1]) {
this.classList.add('validation-success');
} else {
this.classList.add('validation-warning');
}
}
}

log(`${config.label} changed to: ${value}`);
forceCalculate();
});
}
/**
* Helper function to create and append a number input control.
* @param {Object} config - Configuration object for the number input.
* @param {HTMLElement} container - The DOM element to append the control to.
*/
function createNumberControl(config, container) {
const div = document.createElement('div');
div.className = 'control-grid gap-2';

const label = document.createElement('label');
label.htmlFor = `${config.id}-input`;
label.className = "text-sm font-semibold text-slate-200 flex items-center gap-2";
if (config.tooltip) {
label.setAttribute('data-tooltip', config.tooltip);
}

const labelText = document.createElement('span');
labelText.textContent = config.label;
label.appendChild(labelText);

if (config.tooltip) {
    const infoIcon = document.createElement('i');
    infoIcon.setAttribute('data-lucide', 'help-circle');
    infoIcon.className = 'w-4 h-4 text-sky-300 shrink-0';
    infoIcon.setAttribute('aria-hidden', 'true');
    label.appendChild(infoIcon);
}

div.appendChild(label);

const input = document.createElement('input');
input.type = 'number';
input.id = `${config.id}-input`;
input.min = config.min;
input.max = config.max;
input.step = config.step;
input.value = modelData[config.id];
input.className = "p-2 border border-slate-700 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500 bg-slate-800 text-white w-full numeric-input font-mono";
div.appendChild(input);

if (config.tooltip) {
    const helper = document.createElement('p');
    helper.className = 'text-xs text-slate-400 leading-relaxed bg-slate-900/60 border border-slate-800 rounded-lg px-3 py-2';
    helper.textContent = config.tooltip;
    div.appendChild(helper);
}
container.appendChild(div);

input.addEventListener('input', function() {
let value = parseFloat(this.value);
if (isNaN(value)) value = config.min;

value = Math.max(config.min, Math.min(config.max, value));
if (config.label.includes('Año') || config.label.includes('Años')) {
value = Math.round(value);
}
this.value = value; // Correct the input value if it's out of bounds
modelData[config.id] = value;

log(`${config.label} changed to: ${value}`);
forceCalculate();
});
}

/**
* Sets up controls for a specific group/card.
* @param {string} groupKey - The key for the control group in controlsConfig.
* @param {string} containerId - The ID of the DOM element to append the controls to.
*/
function setupControlGroup(groupKey, containerId) {
const container = document.getElementById(containerId);
if (!container) {
log(`❌ Container with ID '${containerId}' not found for control group '${groupKey}'.`);
return;
}
container.innerHTML = ''; // Clear previous controls

const groupConfig = controlsConfig[groupKey] || [];

groupConfig.forEach(config => {
if (config.id === 'unitsPerYear' || (config.id === 'opexRates' && config.type === 'array')) {
const arrayContainer = document.createElement('div');

const label = document.createElement('h5');
label.className = 'text-sm font-semibold text-slate-200 mb-1 flex items-center gap-2';
label.textContent = config.label;
if(config.tooltip) {
    label.setAttribute('data-tooltip', config.tooltip);
    const infoIcon = document.createElement('i');
    infoIcon.setAttribute('data-lucide', 'help-circle');
    infoIcon.className = 'w-4 h-4 text-sky-300';
    infoIcon.setAttribute('aria-hidden', 'true');
    label.appendChild(infoIcon);
}
arrayContainer.appendChild(label);
if(config.tooltip) {
    const helper = document.createElement('p');
    helper.className = 'text-xs text-slate-400 leading-relaxed bg-slate-900/60 border border-slate-800 rounded-lg px-3 py-2 mb-2';
    helper.textContent = config.tooltip;
    arrayContainer.appendChild(helper);
}
const grid = document.createElement('div');
grid.className = 'units-grid';

modelData[config.id].forEach((itemValue, index) => {
const div = document.createElement('div');
div.className = 'flex flex-col';
div.innerHTML = `
<label for="${config.id}-${index+1}" class="text-xs font-medium text-slate-400 mb-1">Año ${index+1}</label>
<input type="number" id="${config.id}-${index+1}" min="${config.min}" max="${config.max}" step="${config.step}" value="${itemValue}"
class="p-2 border border-slate-700 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500 bg-slate-800 text-white">
`;
grid.appendChild(div);

                const input = div.querySelector(`input[type="number"]`);
                
                // Add dynamic limits for unitsPerYear
                if (config.id === 'unitsPerYear') {
                    input.addEventListener('change', function() {
                        const year = index + 1;
                        const value = parseFloat(this.value);
                        const maxUnits = calculateDynamicUnitLimit(year);
                        
                        let newValue = Math.max(config.min, Math.min(maxUnits, isNaN(value) ? config.min : value));
                        
                        // Visual feedback
                        this.classList.remove('validation-error', 'validation-warning', 'validation-success');
                        
                        if (value > maxUnits) {
                            this.classList.add('validation-error');
                            showWarning(`⚠️ Año ${year}: Máximo ${maxUnits} unidades por constraints de capital disponible`);
                        } else if (newValue >= maxUnits * 0.8) {
                            this.classList.add('validation-warning');
                        } else {
                            this.classList.add('validation-success');
                        }
                        
                        this.value = newValue;
                        this.max = maxUnits; // Dynamic max attribute
                        modelData[config.id][index] = newValue;
                        
                        log(`${config.label} Año ${year} changed to: ${newValue} (max available: ${maxUnits})`);
                        forceCalculate();
                    });
                } else {
                    input.addEventListener('change', function() {
                        const value = parseFloat(this.value);
                        let newValue = Math.max(config.min, Math.min(config.max, isNaN(value) ? config.min : value));
                        this.value = newValue;
                        modelData[config.id][index] = newValue;

                        log(`${config.label} Año ${index+1} changed to: ${newValue}`);
                        forceCalculate();
                    });
                }
});
arrayContainer.appendChild(grid);
container.appendChild(arrayContainer);
} else if (config.type === 'range') {
createSliderControl(config, container);
} else if (config.type === 'number') {
createNumberControl(config, container);
} else if (config.type === 'checkbox') {
const checkboxDiv = document.createElement('div');
checkboxDiv.className = 'flex items-center mt-4 p-3 bg-slate-800/50 rounded-lg';
checkboxDiv.innerHTML = `
<input id="${config.id}-input" type="checkbox" class="h-4 w-4 rounded border-slate-600 text-sky-500 focus:ring-sky-500 bg-slate-700">
<label for="${config.id}-input" class="ml-3 block text-sm font-medium text-slate-200" data-tooltip="${config.tooltip}">${config.label}</label>
`;
container.appendChild(checkboxDiv);
const checkbox = document.getElementById(`${config.id}-input`);
checkbox.checked = modelData[config.id];
checkbox.addEventListener('change', function() {
modelData[config.id] = this.checked;
log(`${config.label}: ${this.checked ? 'ACTIVATED' : 'DEACTIVATED'}`);
forceCalculate();
        });
    }
});

log(`✅ '${groupKey}' controls configured.`);
}

/**
 * Sets up the financing matrix with available lines and planned drawdowns.
 */
function setupFinancingMatrix() {
    const container = document.getElementById('matriz-financiamiento-controls');
    if (!container) return;
    container.innerHTML = '';

    const intro = document.createElement('div');
    intro.className = 'p-4 rounded-lg bg-slate-800/70 border border-slate-700 text-sm text-slate-200';
    intro.innerHTML = `<strong>Cómo funciona:</strong> Ajusta la disponibilidad de líneas y tasas. La cascada inferior refleja los drawdowns reales del modelo; no necesitas alimentar tablas manualmente.`;
    container.appendChild(intro);

    const linesGrid = document.createElement('div');
    linesGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
    createNumberControl({ id: 'ventureDebtLineAvailable', label: 'Línea Venture Debt Disponible', min: 0, step: 1000000, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Monto máximo comprometido por la línea de Venture Debt.' }, linesGrid);
    createNumberControl({ id: 'commercialDebtLineAvailable', label: 'Línea Deuda Comercial Disponible', min: 0, step: 1000000, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Capacidad total de la línea bancaria comercial.' }, linesGrid);
    createNumberControl({ id: 'bridgeDebtLineAvailable', label: 'Línea Bridge / Warehousing Disponible', min: 0, step: 1000000, type: 'number', format: val => formatCurrency(val, true), tooltip: 'Facilidad puente que sustituye SINOSURE cuando no está disponible.' }, linesGrid);
    container.appendChild(linesGrid);

    const equityGrid = document.createElement('div');
    equityGrid.className = 'grid grid-cols-1 md:grid-cols-2 gap-4';
    equityGrid.innerHTML = `
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">Seed Capital (Año -1)</div>
            <div class="mt-1 flex items-baseline gap-2">
                <div class="text-lg font-semibold text-white">${formatCurrency(modelData.seed)}</div>
                <span class="text-xs text-slate-400">Fijo · validación tecnológica</span>
            </div>
        </div>
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <label for="seriesA-input" class="block text-xs text-slate-400 uppercase mb-1" data-tooltip="Capital de crecimiento para llegar a escala Serie A.">Serie A (Año 0)</label>
            <input type="number" id="seriesA-input" min="0" step="1000000" value="${modelData.seriesA}" class="w-full p-2 bg-slate-900/70 border border-slate-600 rounded-md text-white">
            <p class="mt-1 text-xs text-slate-400">Actualiza el tamaño de la ronda para modelar escenarios de equity.</p>
        </div>
    `;
    container.appendChild(equityGrid);
    const seriesAInput = document.getElementById('seriesA-input');
    seriesAInput.addEventListener('change', (e) => {
        modelData.seriesA = parseFloat(e.target.value) || 0;
        log(`💰 Serie A updated to: ${formatCurrency(modelData.seriesA)}`);
        forceCalculate();
    });

    const sinosureCard = document.createElement('div');
    sinosureCard.className = 'p-4 bg-gradient-to-r from-yellow-900/30 to-red-900/30 border border-yellow-600/70 rounded-lg space-y-3';
    sinosureCard.innerHTML = `
        <div class="flex items-center justify-between">
            <h5 class="font-semibold text-yellow-300 flex items-center gap-2">🇨🇳 SINOSURE Export Credit Insurance</h5>
            <label class="flex items-center gap-2 text-sm">
                <input type="checkbox" id="sinosure-available" class="h-4 w-4 rounded border-yellow-400 text-yellow-400 focus:ring-yellow-400" ${modelData.sinosureAvailable ? 'checked' : ''}>
                <span class="text-yellow-200">Activar cobertura (6% vs 18% VD)</span>
            </label>
        </div>
        <ul class="text-xs text-yellow-100 leading-5">
            <li><strong>Cobertura:</strong> 100% de costos productivos (${formatCurrency(sinosureConfig.productionCostUSD * sinosureConfig.exchangeRate)} por unidad)</li>
            <li><strong>Disponibilidad:</strong> Desde Año 2 · siempre determinístico</li>
            <li><strong>Impacto:</strong> Reemplaza Venture Debt cuando está activo</li>
        </ul>
    `;
    container.appendChild(sinosureCard);
    sinosureCard.querySelector('#sinosure-available').addEventListener('change', (e) => {
        modelData.sinosureAvailable = e.target.checked;
        log(`🇨🇳 SINOSURE ${e.target.checked ? 'ENABLED' : 'DISABLED'} - Auto-optimizing for ${currentScenario} scenario`);
        const scenarioUnits = (SCENARIO_DEFS[currentScenario] && SCENARIO_DEFS[currentScenario].units) ? SCENARIO_DEFS[currentScenario].units : modelData.unitsPerYear;
        const capitalPlan = optimizeCapitalAllocation(scenarioUnits);
        updateCapitalStructure(capitalPlan);
        updateCapitalStatus(capitalPlan);
        forceCalculate();
    });

    const snapshot = document.createElement('div');
    snapshot.id = 'capital-snapshot';
    snapshot.className = 'grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4 text-sm';
    snapshot.innerHTML = `
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">Total Funding</div>
            <div class="text-lg font-semibold text-white">${formatCurrency((modelData.seed || 0) + (modelData.seriesA || 0))}</div>
            <div class="text-xs text-slate-400">Incluye Seed + Serie A</div>
        </div>
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">Cobertura CAPEX</div>
            <div class="text-lg font-semibold text-white">--</div>
            <div class="text-xs text-slate-400">Se actualizará tras recalcular</div>
        </div>
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">DSCR</div>
            <div class="text-lg font-semibold text-white">--</div>
            <div class="text-xs text-slate-400">Impacto sobre covenants</div>
        </div>
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">Uso de Líneas</div>
            <div class="text-lg font-semibold text-white">--</div>
            <div class="text-xs text-slate-400">Venture + Bridge + Comercial</div>
        </div>
    `;
    container.appendChild(snapshot);

    const drawSection = document.createElement('div');
    drawSection.className = 'border border-slate-700 rounded-lg overflow-hidden';
    drawSection.innerHTML = `
        <div class="px-4 py-3 bg-slate-800/60 border-b border-slate-700 flex items-center justify-between text-sm text-slate-200">
            <span>Funding Mix por Año</span>
            <span class="text-xs text-slate-400">Fuente: Cash Flow real</span>
        </div>
        <div id="capital-draw-summary" class="overflow-x-auto"></div>
    `;
    container.appendChild(drawSection);

    const summaryCard = document.createElement('div');
    summaryCard.id = 'financing-summary-card';
    summaryCard.className = 'p-4 bg-slate-800/60 border border-slate-700 rounded-lg text-sm text-slate-200';
    summaryCard.innerHTML = '<p>Calcula un escenario para ver la foto completa del fondeo.</p>';
    container.appendChild(summaryCard);

    const mixCard = document.createElement('div');
    mixCard.id = 'capital-analysis-card';
    mixCard.className = 'p-4 bg-slate-800/60 border border-slate-700 rounded-lg text-sm text-slate-200';
    mixCard.innerHTML = '<p class="text-sm text-slate-400">Recalcula el modelo para ver el mix Equity/Deuda.</p>';
    container.appendChild(mixCard);

    const ratesDiv = document.createElement('div');
    ratesDiv.className = 'space-y-4';
    createSliderControl({ id: 'ventureDebtRate', label: 'Tasa Venture Debt', min: 12, max: 20, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: 'Costo anual del Venture Debt (impacta WACC y spread).' }, ratesDiv);
    createSliderControl({ id: 'bridgeDebtRate', label: 'Tasa Bridge / Warehousing', min: 12, max: 20, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: 'Costo anual de la facilidad puente (se usa cuando SINOSURE no está activo).' }, ratesDiv);
    createSliderControl({ id: 'commercialDebtRate', label: 'Tasa Deuda Comercial', min: 10, max: 18, step: 0.5, type: 'range', format: val => val.toFixed(1) + '%', tooltip: 'Costo anual de la línea bancaria comercial.' }, ratesDiv);
    createNumberControl({ id: 'bridgeGraceMonths', label: 'Gracia Bridge (meses)', min: 0, max: 24, step: 1, type: 'number', tooltip: 'Meses de gracia para la facilidad bridge.' }, ratesDiv);
    createNumberControl({ id: 'bridgeLoanTermMonths', label: 'Plazo Bridge (meses)', min: 36, max: 84, step: 6, type: 'number', tooltip: 'Duración total de la facilidad bridge.' }, ratesDiv);
    createNumberControl({ id: 'bridgeBalloonPercent', label: 'Balloon Bridge (%)', min: 0, max: 40, step: 5, type: 'number', tooltip: 'Porcentaje del principal bridge que se paga como balloon.' }, ratesDiv);
    createNumberControl({ id: 'commercialGraceMonths', label: 'Meses de gracia (solo intereses)', min: 0, max: 24, step: 1, type: 'number', tooltip: 'Periodo de gracia antes de amortizar principal de la deuda comercial.' }, ratesDiv);
    createNumberControl({ id: 'commercialLoanTermMonths', label: 'Plazo total (meses)', min: 36, max: 84, step: 6, type: 'number', tooltip: 'Duración total del crédito comercial.' }, ratesDiv);
    createNumberControl({ id: 'commercialBalloonPercent', label: 'Balloon Payment (%)', min: 0, max: 40, step: 5, type: 'number', tooltip: 'Porcentaje del principal que se paga al final como balloon.' }, ratesDiv);
    createSliderControl({ id: 'targetDSCR', label: 'Objetivo DSCR', min: 1.05, max: 1.4, step: 0.05, type: 'range', format: val => val.toFixed(2) + 'x', tooltip: 'Covenant objetivo de cobertura de servicio de deuda utilizado por el motor protegido.' }, ratesDiv);
    container.appendChild(ratesDiv);
}

/**
 * NEW: Updates the financing matrix with optimized values and color coding.
 */
function updateFinancingMatrixWithOptimized() {
    const drawContainer = document.getElementById('capital-draw-summary');
    const summaryCard = document.getElementById('financing-summary-card');
    const snapshot = document.getElementById('capital-snapshot');

    if (!drawContainer || !summaryCard || !snapshot) return;

    if (!financialResults || !Array.isArray(financialResults.cf) || financialResults.cf.length === 0) {
        drawContainer.innerHTML = '<div class="p-4 text-sm text-slate-400">Ejecuta un escenario para ver la cascada de fondeo.</div>';
        summaryCard.innerHTML = '<p class="text-sm text-slate-400">Los totales de equity y deuda se mostrarán tras recalcular.</p>';
        return;
    }

    const rows = [];
    let equityFromDraws = 0;
    let sinosureTotal = 0;
    let bridgeTotal = 0;
    let commercialTotal = 0;
    let ventureTotal = 0;

    financialResults.cf.forEach(cf => {
        const equity = Math.max(0, (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0) + (cf.equityInjection || 0));
        const sinosure = Math.max(0, cf.sinosureDrawn || 0);
        const bridge = Math.max(0, cf.bridgeFundingRaised || 0);
        const commercial = Math.max(0, cf.additionalFundingRaised || 0);
        const venture = Math.max(0, cf.currentYearVentureDebtDraw || 0);
        const total = equity + sinosure + bridge + commercial + venture;

        if ((cf.year || 0) > 0) {
            equityFromDraws += equity;
            sinosureTotal += sinosure;
            bridgeTotal += bridge;
            commercialTotal += commercial;
            ventureTotal += venture;
        }

        rows.push({
            year: cf.year,
            equity,
            sinosure,
            bridge,
            commercial,
            venture,
            total,
            cash: cf.cashAfterFinancing !== undefined ? cf.cashAfterFinancing : (cf.netCash || 0)
        });
    });

    const initialEquity = (modelData.seed || 0) + (modelData.seriesA || 0);
    const capexRequired = calculateTotalCapex();
    const totalFunding = initialEquity + equityFromDraws + sinosureTotal + bridgeTotal + commercialTotal + ventureTotal;
    const coverage = capexRequired > 0 ? (totalFunding / capexRequired) * 100 : 0;
    const dscrValue = typeof financialResults.finalDSCR === 'number' ? financialResults.finalDSCR : calculateDebtMetricsBreakdown().finalDSCR;
    const ventureUtilization = modelData.ventureDebtLineAvailable > 0 ? (ventureTotal / modelData.ventureDebtLineAvailable) * 100 : 0;
    const bridgeUtilization = modelData.bridgeDebtLineAvailable > 0 ? (bridgeTotal / modelData.bridgeDebtLineAvailable) * 100 : 0;
    const commercialUtilization = modelData.commercialDebtLineAvailable > 0 ? (commercialTotal / modelData.commercialDebtLineAvailable) * 100 : 0;

    snapshot.innerHTML = `
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">Total Equity desplegado</div>
            <div class="text-lg font-semibold text-white">${formatCurrency(initialEquity + equityFromDraws)}</div>
            <div class="text-xs text-slate-400">Seed + Serie A + capital adicional</div>
        </div>
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">Total Deuda desplegada</div>
            <div class="text-lg font-semibold text-white">${formatCurrency(sinosureTotal + bridgeTotal + commercialTotal + ventureTotal)}</div>
            <div class="text-xs text-slate-400">Bridge + SINOSURE + Comercial + Venture</div>
        </div>
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">Cobertura CAPEX</div>
            <div class="text-lg font-semibold ${coverage >= 100 ? 'text-emerald-400' : 'text-amber-300'}">${coverage.toFixed(1)}%</div>
            <div class="text-xs text-slate-400">CAPEX requerido: ${formatCurrency(capexRequired)}</div>
        </div>
        <div class="p-3 bg-slate-800/60 border border-slate-700 rounded-lg">
            <div class="text-xs text-slate-400 uppercase">DSCR</div>
            <div class="text-lg font-semibold ${dscrValue !== null && dscrValue >= 1.5 ? 'text-emerald-400' : 'text-red-300'}">${dscrValue !== null ? dscrValue.toFixed(2) + 'x' : 'N/A'}</div>
            <div class="text-xs text-slate-400">Covenant objetivo ≥ 1.5x</div>
        </div>
    `;

    const rowsHtml = rows.map(row => {
        const label = row.year === 0 ? 'Año 0' : `Año ${row.year}`;
        return `
            <tr>
                <td class="text-left">${label}</td>
                <td>${formatCurrency(row.equity)}</td>
                <td>${formatCurrency(row.sinosure)}</td>
                <td>${formatCurrency(row.bridge)}</td>
                <td>${formatCurrency(row.commercial)}</td>
                <td>${formatCurrency(row.venture)}</td>
                <td>${formatCurrency(row.total)}</td>
                <td>${formatCurrency(row.cash)}</td>
            </tr>
        `;
    }).join('');

    drawContainer.innerHTML = `
        <table class="financial-table text-xs">
            <thead>
                <tr>
                    <th class="text-left">Año</th>
                    <th>Equity</th>
                    <th>SINOSURE</th>
                    <th>Bridge</th>
                    <th>Comercial</th>
                    <th>Venture</th>
                    <th>Total</th>
                    <th>Cash After Financing</th>
                </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
        </table>
    `;

    const vdStatus = ventureTotal > modelData.ventureDebtLineAvailable ? `🚨 Sobreutilizado por ${formatCurrency(ventureTotal - modelData.ventureDebtLineAvailable)}` : '✅ Dentro del límite';
    const bridgeStatus = modelData.bridgeDebtLineAvailable > 0 && bridgeTotal > modelData.bridgeDebtLineAvailable ? `🚨 Sobreutilizado por ${formatCurrency(bridgeTotal - modelData.bridgeDebtLineAvailable)}` : '✅ Dentro del límite';
    const cdStatus = commercialTotal > modelData.commercialDebtLineAvailable ? `🚨 Sobreutilizado por ${formatCurrency(commercialTotal - modelData.commercialDebtLineAvailable)}` : '✅ Dentro del límite';

    summaryCard.innerHTML = `
        <div class="grid gap-4 md:grid-cols-2 text-sm text-slate-200">
            <div>
                <h5 class="font-semibold text-sky-400 mb-2">Capital Desplegado</h5>
                <div class="flex justify-between"><span>Equity acumulado:</span><strong>${formatCurrency(initialEquity + equityFromDraws)}</strong></div>
                <div class="flex justify-between"><span>Deuda acumulada:</span><strong>${formatCurrency(sinosureTotal + bridgeTotal + commercialTotal + ventureTotal)}</strong></div>
                <div class="flex justify-between"><span>Fondeo total:</span><strong>${formatCurrency(totalFunding)}</strong></div>
            </div>
            <div>
                <h5 class="font-semibold text-sky-400 mb-2">Líneas de Crédito</h5>
                <div class="flex justify-between"><span>Venture Debt:</span><strong>${formatCurrency(ventureTotal)} / ${formatCurrency(modelData.ventureDebtLineAvailable)} (${ventureUtilization.toFixed(0)}%)</strong></div>
                <div class="text-xs ${ventureTotal > modelData.ventureDebtLineAvailable ? 'text-red-400' : 'text-emerald-400'}">${vdStatus}</div>
                <div class="mt-2 flex justify-between"><span>Bridge / Warehousing:</span><strong>${formatCurrency(bridgeTotal)} / ${formatCurrency(modelData.bridgeDebtLineAvailable)} (${bridgeUtilization.toFixed(0)}%)</strong></div>
                <div class="text-xs ${modelData.bridgeDebtLineAvailable > 0 && bridgeTotal > modelData.bridgeDebtLineAvailable ? 'text-red-400' : 'text-emerald-400'}">${bridgeStatus}</div>
                <div class="mt-2 flex justify-between"><span>Deuda Comercial:</span><strong>${formatCurrency(commercialTotal)} / ${formatCurrency(modelData.commercialDebtLineAvailable)} (${commercialUtilization.toFixed(0)}%)</strong></div>
                <div class="text-xs ${commercialTotal > modelData.commercialDebtLineAvailable ? 'text-red-400' : 'text-emerald-400'}">${cdStatus}</div>
            </div>
        </div>
    `;
}


function updateOptimizationStatus() {
const statusContainer = document.getElementById('riesgo-salida-controls');
if (statusContainer) {
let statusElement = document.getElementById('optimization-status');
if (!statusElement) {
statusElement = document.createElement('div');
statusElement.id = 'optimization-status';
statusElement.className = 'mt-4 p-3 rounded-lg bg-slate-800 text-sm';
statusContainer.appendChild(statusElement);
}
const vdRate = modelData.ventureDebtRate;
const commRate = modelData.commercialDebtRate;
const bridgeRate = modelData.bridgeDebtRate || modelData.commercialDebtRate;

let totalCapex = calculateTotalCapex();
let totalFunding = totalFundingFromCF();
const fundingRatio = safeRatio(totalFunding, totalCapex, 0);
const coveragePercent = (fundingRatio * 100).toFixed(0);
    const capexNote = `Cobertura ${coveragePercent}% = fondeo disponible ${fundingRatio >= 1 ? 'excede' : 'no cubre'} el CAPEX requerido (${formatCurrency(totalCapex)}).`;

statusElement.innerHTML = `
<div class="text-slate-300">
<strong>🎯 Status de Financiamiento:</strong><br>
• Tasa VD: ${vdRate.toFixed(1)}% ${vdRate >= 12 && vdRate <= 20 ? '✅' : '⚠️'}<br>
• Tasa Bridge: ${bridgeRate.toFixed(1)}% ${bridgeRate >= 12 && bridgeRate <= 20 ? '✅' : '⚠️'}<br>
• Tasa Comercial: ${commRate.toFixed(1)}% ${commRate >= 10 && commRate <= 18 ? '✅' : '⚠️'}<br>
• Cobertura CAPEX: ${coveragePercent}% ${fundingRatio >= 1.0 ? '✅' : '🚨'}<br>
<span class="text-xs text-slate-400">${capexNote}</span>
</div>
`;
}
}

/**
* Main function to set up all UI controls.
*/
function setupControls() {
setupControlGroup('paqueteFinanciado', 'paquete-financiado-controls');
setupControlGroup('condicionesCredito', 'condiciones-credito-controls');
setupControlGroup('ingresosAdicionales', 'ingresos-adicionales-controls');
setupControlGroup('planCrecimiento', 'plan-crecimiento-controls');
setupFinancingMatrix(); // New matrix setup
setupControlGroup('riesgoYSalida', 'riesgo-salida-controls');

updatePackageSummary();
if (window.lucide && typeof window.lucide.createIcons === 'function') {
    window.lucide.createIcons();
}
    
}
/**
* Updates the automatic summary for the "Package and Prices" section.
*/
function updatePackageSummary() {
const totalPrice = getTotalPackagePrice();
const totalCost = getTotalPackageCost();
const margin = totalPrice - totalCost;
const marginPercent = (totalPrice > 0) ? (margin / totalPrice) * 100 : 0;
const totalPriceFull = getTotalPackagePriceFull();
const insurancePassThrough = getInsuranceTotalPrice();

const summaryContainer = document.getElementById('package-summary');
if (summaryContainer) {
summaryContainer.innerHTML = `
<div class="text-sm space-y-1">
<div class="flex justify-between">
<span>Precio core (sin seguro):</span>
<span class="font-bold text-sky-400">${formatCurrency(totalPrice, true)}</span>
</div>
<div class="flex justify-between">
<span>Costo core Conductores:</span>
<span>${formatCurrency(totalCost, true)}</span>
</div>
<div class="flex justify-between border-t border-slate-600 pt-1">
<span>Margen core:</span>
<span class="font-bold text-emerald-400">${formatCurrency(margin, true)} (${marginPercent.toFixed(1)}%)</span>
</div>
<div class="flex justify-between text-xs text-slate-400">
<span>Seguro pass-through:</span>
<span>${formatCurrency(insurancePassThrough, true)} · sin margen</span>
</div>
<div class="flex justify-between text-xs text-slate-400">
<span>Ticket total (core + seguro):</span>
<span>${formatCurrency(totalPriceFull, true)}</span>
</div>
</div>
`;
}
log('✅ Package summary updated.');
}
/**
* Configures tab navigation.
* Forces UI update when switching to financial/charts/validation tabs.
*/
function setupTabs() {
const tabButtons = document.querySelectorAll('.tab-button');
const contentSections = document.querySelectorAll('.content-section');

tabButtons.forEach((button, index) => {
button.addEventListener('click', () => {
tabButtons.forEach(btn => btn.classList.remove('active'));
contentSections.forEach(section => section.classList.remove('active'));

button.classList.add('active');
contentSections[index].classList.add('active');

if (button.id === 'tab-investor') {
    renderInvestorSnapshot();
}

if (button.id === 'tab-financieros' || button.id === 'tab-niif' || button.id === 'tab-auditoria' || button.id === 'tab-graficos' || button.id === 'tab-validacion') {
setTimeout(() => {
forceCalculate();
}, 50);
}
});
});
log('✅ Tab navigation configured.');
}

/**
* Updates the validation panel in the UI with the results.
* @param {Object} validations - Object with validation results.
*/
function updateValidationPanel(validations) {
const container = document.getElementById('validation-results-container');
if (!container) return;
container.innerHTML = '';

const types = ['error', 'warning', 'info', 'passed'];
types.forEach(type => {
if (Array.isArray(validations[type])) {
validations[type].forEach(msg => {
const div = document.createElement('div');
div.className = `validation-item ${type}`;
let icon = '';
if (type === 'error') icon = '🔴';
else if (type === 'warning') icon = '🟡';
else if (type === 'info') icon = '🔵';
else if (type === 'passed') icon = '✅';
div.innerHTML = `<span class="validation-icon">${icon}</span><div class="validation-message">${msg}</div>`;
container.appendChild(div);
});
}
});

const summaryDiv = document.createElement('div');
summaryDiv.className = 'validation-summary mt-4 p-2 rounded-lg';
if (validations.errors.length > 0) {
summaryDiv.classList.add('bg-red-200', 'text-red-800');
summaryDiv.textContent = `🚨 ${validations.errors.length} CRITICAL ERRORS found. Please review and adjust inputs/logic.`;
} else if (validations.warnings.length > 0) {
summaryDiv.classList.add('bg-yellow-200', 'text-yellow-800');
summaryDiv.textContent = `⚠️ ${validations.warnings.length} WARNINGS found. Review results with caution.`;
} else {
summaryDiv.classList.add('bg-green-200', 'text-green-800');
summaryDiv.textContent = `✨ All critical validations passed. ${validations.info.length} informational notes.`;
}
container.appendChild(summaryDiv);
}
/**
* Updates funding coverage card.
*/
function updateFundingCoverageCard() {
const totalFunding = totalFundingFromCF();
const totalCapex = calculateTotalCapex();
const surplus = totalFunding - totalCapex;
// Coverage computed from updated totals after cohorts exist
const coverage = safeRatio(totalFunding, totalCapex, 0) * 100;
// The visual part will be added in the next step.
}

/**
* Updates investor score dashboard
*/
function updateInvestorScore() {
    const investorScore = calculateInvestorScore();
    let scoreContainer = document.getElementById('investor-score-card');
    if (!scoreContainer) {
        const header = document.querySelector('header');
        const scoreCard = document.createElement('div');
        scoreCard.id = 'investor-score-card';
        header.appendChild(scoreCard);
        scoreContainer = scoreCard;
    }
    const gradeColor = { 'A': 'bg-emerald-900', 'B': 'bg-blue-900', 'C': 'bg-amber-900', 'D': 'bg-red-900' }[investorScore.grade];
    const gradeGradients = {
        'A': 'linear-gradient(135deg, rgba(6,95,70,0.92) 0%, rgba(5,150,105,0.88) 100%)',
        'B': 'linear-gradient(135deg, rgba(23,63,95,0.92) 0%, rgba(37,99,235,0.85) 100%)',
        'C': 'linear-gradient(135deg, rgba(120,53,15,0.92) 0%, rgba(217,119,6,0.88) 100%)',
        'D': 'linear-gradient(135deg, rgba(127,29,29,0.92) 0%, rgba(220,38,38,0.9) 100%)'
    };
    scoreContainer.className = `mt-4 p-4 rounded-lg border border-slate-700 text-slate-100 shadow-lg ${gradeColor}`;
    scoreContainer.style.background = gradeGradients[investorScore.grade];
    scoreContainer.style.borderColor = 'rgba(148, 163, 184, 0.2)';
    scoreContainer.innerHTML = `
        <div class="flex justify-between items-center">
            <div>
                <h3 class="font-semibold">📊 Investor Health Score</h3>
                <p class="text-sm opacity-80">Serie A Investment Readiness</p>
            </div>
            <div class="text-right">
                <div class="text-2xl font-bold">${investorScore.score.toFixed(1)}/10</div>
                <div class="text-lg font-semibold">Grade ${investorScore.grade}</div>
            </div>
        </div>
        ${investorScore.issues.length > 0 ? `
        <div class="mt-3 pt-3 border-t border-white/20">
            <p class="text-sm font-medium mb-2">Key Issues:</p>
            <ul class="text-xs space-y-1">${investorScore.issues.map(issue => `<li>${issue}</li>`).join('')}</ul>
        </div>` : `<div class="mt-2 text-sm text-emerald-400">🎉 All key metrics look strong for Serie A!</div>`}
    `;
}

// ===== Investor Snapshot Module =====

function calculateTotalCapexForModelSnapshot(model) {
    if (!model || !Array.isArray(model.unitsPerYear)) return 0;
    const unitCost = (model.vanCost || 0) + (model.conversionCost || 0) + (model.bancasCost || 0) + (model.gpsCost || 0);
    return model.unitsPerYear.reduce((sum, units) => sum + (units || 0) * unitCost, 0);
}

function computeFundingBreakdownForSnapshot(cfArray, model) {
    const components = { bridge: 0, commercial: 0, venture: 0, sinosure: 0 };
    let equityFlowTotal = 0;
    let equityDraws = 0;

    (cfArray || []).forEach(cf => {
        const equityFlow = Math.max(0, (cf.equityInjection || 0) + (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0));
        equityFlowTotal += equityFlow;
        if (typeof cf.year === 'number' && cf.year > 0) {
            equityDraws += equityFlow;
        } else {
            equityDraws += Math.max(0, cf.equityInjection || 0);
        }
        components.bridge += Math.max(0, cf.bridgeFundingRaised || 0);
        components.commercial += Math.max(0, cf.additionalFundingRaised || 0);
        components.venture += Math.max(0, cf.currentYearVentureDebtDraw || 0);
        components.sinosure += Math.max(0, cf.sinosureDrawn || 0);
    });

    const equityInitial = (model?.seed || 0) + (model?.seriesA || 0);
    const equityDeployed = equityInitial + equityDraws;
    const debtDeployed = components.bridge + components.commercial + components.venture + components.sinosure;
    const totalFunding = equityFlowTotal + debtDeployed;
    const mix = safeRatio(equityDeployed, equityDeployed + debtDeployed, 0);

    return { components, equityDeployed, debtDeployed, totalFunding, mix };
}

function formatMillions(value) {
    if (!isFinite(value)) return '$0';
    if (Math.abs(value) >= 1000000) {
        return `$${(value / 1000000).toFixed(1)}M`;
    }
    return formatCurrency(value, true);
}

function buildStackComposition(components) {
    if (!components) return 'Sin datos';
    const parts = [];
    if (components.sinosure > 0) parts.push(`Sinosure ${formatMillions(components.sinosure)}`);
    if (components.bridge > 0) parts.push(`Bridge ${formatMillions(components.bridge)}`);
    if (components.commercial > 0) parts.push(`Commercial ${formatMillions(components.commercial)}`);
    if (components.venture > 0) parts.push(`Venture ${formatMillions(components.venture)}`);
    return parts.length ? parts.join(', ') : 'Sin deuda desplegada';
}

function buildCapitalStackBullets(primary, secondary) {
    const bullets = [];
    if (!primary) return bullets;

    const components = primary.components || {};
    const secondComponents = secondary?.components || {};
    const bridgeDelta = (secondComponents.bridge || 0) - (components.bridge || 0);
    const commercialDelta = (secondComponents.commercial || 0) - (components.commercial || 0);
    const ventureDelta = (secondComponents.venture || 0) - (components.venture || 0);

    if (components.sinosure > 0) {
        if (bridgeDelta > 0) {
            bullets.push(`Cobertura ECA (${formatMillions(components.sinosure)}) sustituye ${formatMillions(bridgeDelta)} de bridge.`);
        } else {
            bullets.push(`Cobertura ECA aporta ${formatMillions(components.sinosure)} con tasa preferencial.`);
        }
    } else if (components.bridge > 0) {
        bullets.push(`Requiere bridge ${formatMillions(components.bridge)} como financiamiento principal.`);
    }

    if (primary.cashAfterFinancing < 0) {
        bullets.push('Cash AF negativo: activar equity call o línea revolving.');
    } else if (secondary && secondary.cashAfterFinancing < 0 && primary.cashAfterFinancing >= 0) {
        bullets.push('Cobertura actual evita cash negativo en Año 5.');
    } else if (secondary && primary.mix < secondary.mix) {
        bullets.push(`Mix equity ${ (primary.mix * 100).toFixed(0)}% vs ${ (secondary.mix * 100).toFixed(0)}% sin cambio.`);
    }

    if (bullets.length === 0 && (components.commercial > 0 || commercialDelta !== 0 || ventureDelta !== 0)) {
        bullets.push(`Deuda comercial ${formatMillions(components.commercial)} · Venture ${formatMillions(components.venture)}.`);
    }

    return bullets.slice(0, 2);
}

function calculateWorstCashFromResults(results) {
    let worstBalance = 0;
    let worstYear = 0;
    if (results && Array.isArray(results.bs)) {
        results.bs.forEach((bs, index) => {
            if (bs && typeof bs.cash === 'number' && bs.cash < worstBalance) {
                worstBalance = bs.cash;
                worstYear = index + 1;
            }
        });
    }
    return { year: worstYear, balance: worstBalance };
}

function composeInvestorScenarioSnapshot(scenarioKey, scenarioDef, includeSinosure, simulation, metrics) {
    if (!simulation) return null;
    const snapshotMetrics = metrics || buildInvestorMetrics(simulation.modelData, simulation.financialResults);
    const plannedUnits = Array.isArray(scenarioDef?.units)
        ? scenarioDef.units.reduce((sum, val) => sum + (Number(val) || 0), 0)
        : 0;
    const totalUnitsModeled = Array.isArray(simulation.modelData?.unitsPerYear)
        ? simulation.modelData.unitsPerYear.reduce((sum, val) => sum + (Number(val) || 0), 0)
        : 0;
    const worstCash = calculateWorstCashFromResults(simulation.financialResults);
    const year5BS = simulation.financialResults?.bs?.[4] || {};

    return {
        scenarioKey,
        scenarioName: scenarioDef?.name || `${scenarioKey} unidades`,
        plannedUnits,
        totalUnits: totalUnitsModeled,
        tirEquity: simulation.financialResults?.tirEquity || 0,
        tirProyecto: simulation.financialResults?.tirProyecto || 0,
        dscr: snapshotMetrics && isFinite(snapshotMetrics.finalDSCR) ? snapshotMetrics.finalDSCR : null,
        coverage: snapshotMetrics ? snapshotMetrics.coverage : null,
        equityDeployed: snapshotMetrics ? snapshotMetrics.equityDeployed : 0,
        debtDeployed: snapshotMetrics ? snapshotMetrics.debtDeployed : 0,
        cashFinal: year5BS.cash || 0,
        cashAfterFinancingY5: snapshotMetrics ? snapshotMetrics.cashAfterFinancing : (year5BS.cash || 0),
        worstCash,
        nimY5: snapshotMetrics ? snapshotMetrics.nimY5 : null,
        totalFunding: snapshotMetrics ? snapshotMetrics.totalFunding : 0,
        totalCapex: snapshotMetrics ? snapshotMetrics.totalCapex : 0,
        includeSinosure: !!includeSinosure,
        updatedAt: new Date().toISOString(),
        displayOrder: Number(scenarioKey) || 999
    };
}

function getInvestorScenarioSnapshot(scenarioKey, includeSinosure, currentScenarioMetrics) {
    const cacheKey = `${scenarioKey}|${includeSinosure ? 'eca' : 'base'}`;
    if (investorScenarioCache[cacheKey]) return investorScenarioCache[cacheKey];

    const scenarioDef = SCENARIO_DEFS[scenarioKey];
    if (!scenarioDef) return null;

    let simulation = null;
    let metrics = null;

    if (Number(scenarioKey) === Number(currentScenario) && !!includeSinosure === !!investorToggleECA && currentScenarioMetrics) {
        simulation = {
            modelData: deepClone(modelData),
            financialResults: deepClone(financialResults)
        };
        metrics = currentScenarioMetrics;
    } else {
        const modelClone = deepClone(modelData);
        modelClone.unitsPerYear = deepClone(scenarioDef.units || modelClone.unitsPerYear);
        modelClone.sinosureAvailable = !!includeSinosure;
        const result = simulateFinancialsForInvestor(modelClone);
        if (!result) return null;
        simulation = result;
        metrics = buildInvestorMetrics(result.modelData, result.financialResults);
    }

    const snapshot = composeInvestorScenarioSnapshot(scenarioKey, scenarioDef, includeSinosure, simulation, metrics);
    if (snapshot) investorScenarioCache[cacheKey] = snapshot;
    return snapshot;
}

function buildInvestorMetrics(model, results) {
    if (!results || !Array.isArray(results.pl) || results.pl.length < 5) return null;

    const year5PL = results.pl[4] || {};
    const year5CF = (results.cf || [])[4] || {};
    const year5BS = (results.bs || [])[4] || {};
    const year4BS = (results.bs || [])[3] || {};

    const funding = computeFundingBreakdownForSnapshot(results.cf, model);
    const totalCapex = calculateTotalCapexForModelSnapshot(model);
    const coverage = safeRatio(funding.totalFunding, totalCapex, 0);
    const debtService = (year5PL.interestExpense || 0) + (year5CF.debtPrincipalRepayment || 0) + (year5CF.balloonPayment || 0);
    const finalDSCR = safeRatio(year5PL.ebitda || 0, debtService, null);

    let autosufficiencyYear = 0;
    (results.pl || []).some((plYear, index) => {
        const totalExpense = (plYear.opex || 0) + (plYear.provisions || 0) + (plYear.impairment || 0);
        if ((plYear.totalRevenue || 0) > totalExpense) {
            autosufficiencyYear = index + 1;
            return true;
        }
        return false;
    });

    const avgReceivables = ((year4BS?.receivables || 0) + (year5BS?.receivables || 0)) / 2;
    const netInterestIncome = (year5PL.interestRevenue || 0) - (year5PL.interestExpense || 0);
    const nimY5 = avgReceivables > 0 ? (netInterestIncome / avgReceivables) * 100 : 0;
    const cashAfterFinancing = (typeof year5CF.cashAfterFinancing === 'number')
        ? year5CF.cashAfterFinancing
        : (year5BS?.cash || 0);

    return {
        tirEquity: Number(results.tirEquity || 0),
        finalDSCR,
        coverage,
        revenueMix: {
            interest: year5PL.interestRevenue || 0,
            gnv: year5PL.gnvCommissions || 0,
            origination: year5PL.recognizedOriginationRevenue || 0,
            aftersales: (year5PL.sparePartsRevenue || 0) + (year5PL.marketplaceRevenue || 0)
        },
        equityDeployed: funding.equityDeployed,
        debtDeployed: funding.debtDeployed,
        mix: funding.mix,
        cashAfterFinancing,
        nimY5,
        autosufficiencyYear,
        compositionText: buildStackComposition(funding.components),
        components: funding.components,
        totalFunding: funding.totalFunding,
        totalCapex,
        sinosureAvailable: !!model?.sinosureAvailable
    };
}

function simulateFinancialsForInvestor(modelClone) {
    const originalModelRef = modelData;
    const originalFinancialResults = deepClone(financialResults);
    const originalHeldForSaleAssets = deepClone(heldForSaleAssets);
    const originalSinosureCohorts = deepClone(sinosureCohorts);
    const originalDebtOptimizationHistory = deepClone(debtOptimizationHistory);
    const originalCapitalPlanOutputRef = capitalPlanOutput;
    const originalPlannedFinancingData = deepClone(plannedFinancingData);

    let simulationOutcome = null;

    try {
        modelData = deepClone(modelClone);
        capitalPlanOutput = buildCapitalPlan(modelData.unitsPerYear);
        updateCapitalStructure(capitalPlanOutput);
        if (!calculateFinancials()) {
            return null;
        }
        simulationOutcome = {
            modelData: deepClone(modelData),
            financialResults: deepClone(financialResults)
        };
    } catch (error) {
        log(`⚠️ Investor snapshot simulation failed: ${error.message}`);
    } finally {
        modelData = originalModelRef;
        financialResults = originalFinancialResults;
        heldForSaleAssets = originalHeldForSaleAssets;
        sinosureCohorts = originalSinosureCohorts;
        debtOptimizationHistory = originalDebtOptimizationHistory;
        capitalPlanOutput = originalCapitalPlanOutputRef;
        plannedFinancingData = originalPlannedFinancingData;
    }

    return simulationOutcome;
}

function computeInvestorMetrics(includeSinosure) {
    if (!financialResults || !Array.isArray(financialResults.pl) || !financialResults.pl.length) return null;

    const targetState = !!includeSinosure;
    if (!!modelData.sinosureAvailable === targetState) {
        return buildInvestorMetrics(modelData, financialResults);
    }

    const modelClone = deepClone(modelData);
    modelClone.sinosureAvailable = targetState;
    const simulation = simulateFinancialsForInvestor(modelClone);
    if (!simulation) return null;
    return buildInvestorMetrics(simulation.modelData, simulation.financialResults);
}

function renderInvestorRevenueTable(revenueMix) {
    const table = document.getElementById('investor-revenue-table');
    const totalCell = document.getElementById('investor-revenue-total');
    if (!table || !totalCell) return;

    const rows = Array.from(table.querySelectorAll('tbody tr'));
    if (!revenueMix) {
        rows.forEach(row => {
            const amountCell = row.children[1];
            const mixCell = row.children[2];
            if (amountCell) amountCell.textContent = '$0';
            if (mixCell) mixCell.textContent = '0%';
        });
        totalCell.textContent = '$0';
        return;
    }

    const values = {
        Intereses: Math.max(0, revenueMix.interest || 0),
        'Comisión GNV': Math.max(0, revenueMix.gnv || 0),
        'Originación NIIF 15': Math.max(0, revenueMix.origination || 0),
        Aftersales: Math.max(0, revenueMix.aftersales || 0)
    };
    const total = Object.values(values).reduce((sum, val) => sum + val, 0);

    rows.forEach(row => {
        const label = row.children[0]?.textContent?.trim();
        const amountCell = row.children[1];
        const mixCell = row.children[2];
        if (!label || !Object.prototype.hasOwnProperty.call(values, label)) return;
        const amount = values[label];
        const mix = safeRatio(amount, total, 0) * 100;
        if (amountCell) amountCell.textContent = formatCurrency(amount, true);
        if (mixCell) mixCell.textContent = `${mix.toFixed(1)}%`;
    });

    totalCell.textContent = formatCurrency(total, true);
}

function renderInvestorScenarioTable(currentScenarioMetrics) {
    const tbody = document.getElementById('investor-scenarios-table');
    const footnoteEl = document.getElementById('investor-scenarios-footnote');
    if (!tbody) return;

    const scenarioKeys = [250, 500, 750, 1000];
    let hasNegative = false;
    const rows = scenarioKeys.map(key => {
        const snapshot = getInvestorScenarioSnapshot(key, investorToggleECA, key === Number(currentScenario) ? currentScenarioMetrics : null) || scenarioSnapshots[key];
        const tirText = snapshot && isFinite(snapshot.tirEquity) ? `${snapshot.tirEquity.toFixed(1)}%` : 'N/A';
        const dscrText = snapshot && isFinite(snapshot.dscr) ? `${snapshot.dscr.toFixed(2)}x` : 'N/A';
        const cashText = snapshot && isFinite(snapshot.cashAfterFinancingY5)
            ? formatCurrency(snapshot.cashAfterFinancingY5, true)
            : 'N/A';
        const cashClass = snapshot && isFinite(snapshot.cashAfterFinancingY5)
            ? (snapshot.cashAfterFinancingY5 < 0 ? 'text-rose-400 font-semibold' : 'text-emerald-300 font-semibold')
            : '';
        if (snapshot && snapshot.cashAfterFinancingY5 < 0) hasNegative = true;
        return `
            <tr>
                <td class="px-4 py-2">${key.toLocaleString('es-MX')} unidades</td>
                <td class="px-4 py-2">${tirText}</td>
                <td class="px-4 py-2">${dscrText}</td>
                <td class="px-4 py-2 ${cashClass}">${cashText}</td>
            </tr>
        `;
    }).join('');

    tbody.innerHTML = rows;
    if (footnoteEl) {
        footnoteEl.textContent = hasNegative
            ? '* Escenarios con cash negativo requieren reforzar equity calls o línea revolving.'
            : '';
    }
}

function renderInvestorSnapshot() {
    const container = document.getElementById('content-investor');
    if (!container) return;

    investorScenarioCache = {};
    investorToggleECA = !!modelData.sinosureAvailable;

    const toggleEl = document.getElementById('investor-eca-toggle');
    if (toggleEl) toggleEl.checked = investorToggleECA;

    const subtitleEl = document.getElementById('investor-eca-subtitle');
    if (subtitleEl) subtitleEl.textContent = investorToggleECA ? 'con cobertura ECA' : 'sin cobertura ECA';

    const titleEl = document.getElementById('investor-snapshot-title');
    if (titleEl) {
        const scenarioDef = SCENARIO_DEFS[currentScenario] || { name: 'Escenario Base' };
        titleEl.textContent = `Investor Snapshot · ${scenarioDef.name || 'Escenario Base'}`;
    }

    const setText = (id, value) => {
        const el = document.getElementById(id);
        if (el) el.textContent = value;
    };

    if (!financialResults || !Array.isArray(financialResults.pl) || !financialResults.pl.length) {
        setText('investor-tir', 'N/A');
        setText('investor-dscr', 'N/A');
        setText('investor-coverage', 'N/A');
        renderInvestorRevenueTable(null);
        renderInvestorScenarioTable(null);
        return;
    }

    const currentMetrics = computeInvestorMetrics(investorToggleECA);
    const alternateMetrics = computeInvestorMetrics(!investorToggleECA);

    setText('investor-tir', currentMetrics ? `${currentMetrics.tirEquity.toFixed(1)}%` : 'N/A');
    setText('investor-dscr', currentMetrics && isFinite(currentMetrics.finalDSCR)
        ? `${currentMetrics.finalDSCR.toFixed(2)}x`
        : 'N/A');
    setText('investor-coverage', currentMetrics && isFinite(currentMetrics.coverage)
        ? `${(currentMetrics.coverage * 100).toFixed(1)}%`
        : 'N/A');

    const unitEconomics = evaluateUnitEconomics();
    const marginPercent = unitEconomics && isFinite(unitEconomics.marginPercent) ? unitEconomics.marginPercent : 0;
    const nimText = currentMetrics && isFinite(currentMetrics.nimY5) ? `${currentMetrics.nimY5.toFixed(1)}%` : 'N/A';
    const autosuffText = currentMetrics && currentMetrics.autosufficiencyYear
        ? `Año ${currentMetrics.autosufficiencyYear}`
        : 'N/A';
    const footnoteEl = document.getElementById('investor-revenue-footnote');
    if (footnoteEl) {
        footnoteEl.textContent = `Margen core ${marginPercent.toFixed(1)}% · NIM Y5 ${nimText} · Autosuficiencia ${autosuffText}`;
    }

    renderInvestorRevenueTable(currentMetrics ? currentMetrics.revenueMix : null);

    const updateStack = (prefix, metrics, label, counterpart) => {
        setText(`investor-stack-title-${prefix}`, label);
        setText(`investor-stack-description-${prefix}`, metrics ? metrics.compositionText : 'Sin datos');
        setText(`investor-equity-${prefix}`, metrics ? formatCurrency(metrics.equityDeployed, true) : 'N/A');
        setText(`investor-debt-${prefix}`, metrics ? formatCurrency(metrics.debtDeployed, true) : 'N/A');
        setText(`investor-mix-${prefix}`, metrics && isFinite(metrics.mix)
            ? `${(metrics.mix * 100).toFixed(0)}%`
            : 'N/A');
        setText(`investor-caf-${prefix}`, metrics ? formatCurrency(metrics.cashAfterFinancing, true) : 'N/A');
        setText(`investor-nim-${prefix}`, metrics && isFinite(metrics.nimY5)
            ? `${metrics.nimY5.toFixed(1)}%`
            : 'N/A');
        setText(`investor-dscr-${prefix}`, metrics && isFinite(metrics.finalDSCR)
            ? `${metrics.finalDSCR.toFixed(2)}x`
            : 'N/A');
        const bulletsEl = document.getElementById(`investor-stack-bullets-${prefix}`);
        if (bulletsEl) {
            const bullets = buildCapitalStackBullets(metrics, counterpart);
            bulletsEl.innerHTML = bullets.length ? bullets.map(text => `<li>${text}</li>`).join('') : '';
        }
    };

    const currentLabel = investorToggleECA ? 'Plan actual · con cobertura ECA' : 'Plan base · sin cobertura ECA';
    const alternateLabel = investorToggleECA ? 'Plan base · sin cobertura ECA' : 'Upside opcional · con cobertura ECA';

    updateStack('left', currentMetrics, currentLabel, alternateMetrics);
    updateStack('right', alternateMetrics, alternateLabel, currentMetrics);

    renderInvestorScenarioTable(currentMetrics);
}

function setupInvestorTab() {
    const toggleEl = document.getElementById('investor-eca-toggle');
    const exportBtn = document.getElementById('investor-export-pack');

    investorToggleECA = !!modelData.sinosureAvailable;
    if (toggleEl) {
        toggleEl.checked = investorToggleECA;
        toggleEl.addEventListener('change', toggleInvestorSnapshotMode);
    }

    if (exportBtn) {
        exportBtn.addEventListener('click', exportInvestorPack);
    }

    renderInvestorSnapshot();
}

function toggleInvestorSnapshotMode() {
    const toggleEl = document.getElementById('investor-eca-toggle');
    if (!toggleEl) return;

    const desiredState = !!toggleEl.checked;
    if (desiredState === investorToggleECA && desiredState === !!modelData.sinosureAvailable) {
        return;
    }

    investorToggleECA = desiredState;
    modelData.sinosureAvailable = investorToggleECA;
    log(`🛰️ Investor snapshot toggle -> SINOSURE ${investorToggleECA ? 'activado' : 'desactivado'}`);
    investorScenarioCache = {};
    forceCalculate();
    renderInvestorSnapshot();
}

function exportInvestorPack() {
    log('📦 TODO: Exportar paquete completo (PDF + supuestos + snapshot).');
    pushActionLog('export', 'Investor pack solicitado (TODO)');
}

function renderAuditPanel() {
    const niifContainer = document.getElementById('audit-niif-status');
    const cashContainer = document.getElementById('audit-cash-summary');
    const assumptionsContainer = document.getElementById('audit-assumptions-table');
    const formulasContainer = document.getElementById('audit-formulas');
    const downloadAssumptionsBtn = document.getElementById('download-assumptions-btn');
    const downloadResultsBtn = document.getElementById('download-results-btn');

    if (!niifContainer || !cashContainer || !assumptionsContainer || !formulasContainer) {
        return;
    }

    if (!financialResults || !Array.isArray(financialResults.pl) || financialResults.pl.length === 0) {
        const emptyState = '<p class="text-sm text-slate-400">Recalcula el modelo para habilitar este resumen.</p>';
        niifContainer.innerHTML = emptyState;
        cashContainer.innerHTML = emptyState;
        assumptionsContainer.innerHTML = '';
        formulasContainer.innerHTML = '';
        if (downloadAssumptionsBtn) downloadAssumptionsBtn.disabled = true;
        if (downloadResultsBtn) downloadResultsBtn.disabled = true;
        return;
    }

    if (downloadAssumptionsBtn) downloadAssumptionsBtn.disabled = false;
    if (downloadResultsBtn) downloadResultsBtn.disabled = false;

    const niifDetails = Array.isArray(financialResults.niifDetails) ? financialResults.niifDetails : [];
    const latestNiif = niifDetails.length ? niifDetails[niifDetails.length - 1] : {};
    const latestBS = financialResults.bs?.[financialResults.bs.length - 1] || {};
    const year5PL = financialResults.pl?.[4] || {};
    const year5BS = financialResults.bs?.[4] || {};
    const year4BS = financialResults.bs?.[3] || {};
    const year5CF = financialResults.cf?.[4] || {};
    const seriesAMetrics = calculateSeriesAMetrics();
    const totalCapex = calculateTotalCapex();
    const totalFunding = totalFundingFromCF();
    const coverageRatio = safeRatio(totalFunding, totalCapex, 0);

    const niifStatuses = [
        {
            label: 'NIIF 9 · Provisiones crédito',
            ok: !!latestNiif?.niif9,
            detail: `Provisión acumulada: ${formatCurrency(latestBS.provisions || 0)} · <span class="text-amber-300 font-semibold">⚠️ PD estática</span> (limitación actual)`
        },
        {
            label: 'NIIF 15 · Pasivos por contrato',
            ok: !!latestNiif?.niif15,
            detail: `Ingreso diferido: ${formatCurrency(latestBS.contractLiabilities || 0)}`
        },
        {
            label: 'NIIF 5 · Activos en venta',
            ok: !!latestNiif?.niif5,
            detail: `Inventario NIIF 5: ${formatCurrency(latestBS.assetsHeldForSale || 0)}`
        }
    ];

    niifContainer.innerHTML = niifStatuses.map(status => {
        const badgeClass = status.ok ? 'bg-emerald-700 text-emerald-100' : 'bg-amber-700 text-amber-100';
        const cardClass = status.ok ? 'border-emerald-500/40 bg-emerald-500/10' : 'border-amber-500/40 bg-amber-500/10';
        return `
            <div class="flex items-start justify-between gap-3 p-3 border rounded-lg ${cardClass}">
                <div>
                    <p class="text-sm font-semibold text-white">${status.label}</p>
                    <p class="text-xs text-slate-200 mt-1">${status.detail}</p>
                </div>
                <span class="px-2 py-1 text-xs font-semibold rounded ${badgeClass}">${status.ok ? 'OK' : 'Revisar'}</span>
            </div>
        `;
    }).join('');

    const cashHealth = analyzeCashFlowHealth();
    const finalCash = latestBS.cash || 0;
    const debtMetrics = calculateDebtMetricsBreakdown();
    const leverage = safeRatio(latestBS.debt || 0, latestBS.equity || 0, null);

    const cashItems = [
        {
            label: 'Caja final (Año 5)',
            value: formatCurrency(finalCash),
            ok: finalCash >= 0,
            note: finalCash >= 0 ? 'Saldo positivo al cierre del plan.' : 'Requiere capital adicional para cerrar el periodo.'
        },
        {
            label: 'Peor saldo de caja',
            value: `${cashHealth.worstYear ? 'Año ' + cashHealth.worstYear : 'N/A'} · ${formatCurrency(cashHealth.worstBalance || 0)}`,
            ok: (cashHealth.worstBalance || 0) >= 0,
            note: 'Úsalo para programar equity calls o líneas bridge.'
        },
        {
            label: 'Seguro pass-through pagado',
            value: formatCurrency(year5CF.insurancePassThroughOutflow || 0),
            ok: true,
            note: 'Primas transferidas al asegurador (pass-through, sin impacto neto en caja).'
        },
        {
            label: 'Seguro pass-through pendiente',
            value: formatCurrency(latestBS.insurancePassThroughLiability || 0),
            ok: (latestBS.insurancePassThroughLiability || 0) === 0,
            note: 'Saldo contra clientes que compensa el aumento en cuentas por cobrar.'
        },
        {
            label: 'DSCR final',
            value: debtMetrics.finalDSCR !== null ? debtMetrics.finalDSCR.toFixed(2) + 'x' : 'N/A',
            ok: debtMetrics.finalDSCR !== null && debtMetrics.finalDSCR >= 1.5,
            note: 'Objetivo mínimo Serie A: ≥ 1.5x.'
        },
        {
            label: 'Debt / Equity',
            value: leverage !== null ? leverage.toFixed(1) + 'x' : 'N/A',
            ok: leverage !== null ? leverage <= 2.5 : false,
            note: 'Comfort lenders: ≤ 2.5x para mantener grado saludable.'
        }
    ];

    cashContainer.innerHTML = cashItems.map(item => {
        const badgeClass = item.ok ? 'bg-emerald-600/20 text-emerald-300 border border-emerald-600/40' : 'bg-amber-600/20 text-amber-200 border border-amber-600/40';
        return `
            <div class="p-3 rounded-lg ${badgeClass}">
                <p class="text-sm font-semibold text-white">${item.label}</p>
                <p class="text-base font-bold mt-1">${item.value}</p>
                <p class="text-xs mt-1 opacity-80">${item.note}</p>
            </div>
        `;
    }).join('');

    const adjustmentsContainer = document.getElementById('audit-balance-adjustments');
    if (adjustmentsContainer) {
        const adjustments = Array.isArray(financialResults.balanceAdjustments) ? financialResults.balanceAdjustments.filter(adj => Math.abs(adj.amount) > BALANCE_TOLERANCE) : [];
        if (adjustments.length) {
            adjustmentsContainer.innerHTML = `
                <div class="px-3 py-2 bg-amber-900/30 border border-amber-500/40 rounded-lg">
                    <p class="font-semibold text-amber-200 text-sm mb-1">Ajustes de balance aplicados</p>
                    <ul class="space-y-1">
                        ${adjustments.map(adj => {
                            const sign = adj.amount >= 0 ? '+' : '-';
                            const amount = formatCurrency(Math.abs(adj.amount), true);
                            return `<li class="flex justify-between gap-2"><span>Año ${adj.year}</span><span class="font-semibold text-amber-100">${sign}${amount}</span></li>`;
                        }).join('')}
                    </ul>
                    <p class="text-[11px] text-amber-200/80 mt-2">Se ajustó equity para mantener Assets = Liabilities + Equity dentro de la tolerancia.</p>
                </div>
            `;
        } else {
            adjustmentsContainer.innerHTML = '';
        }
    }

    const scenario = SCENARIO_DEFS[currentScenario] || { name: 'Personalizado', units: modelData.unitsPerYear.slice() };
    const assumptionsGroups = [
        {
            title: 'Crédito al cliente',
            items: [
                { label: 'Tasa cliente', value: `${modelData.tasaInteres.toFixed(1)}%` },
                { label: 'Enganche', value: `${modelData.downPaymentPercentage.toFixed(1)}%` },
                { label: 'Plazo', value: `${modelData.clientLoanTermYears} años` },
                { label: 'Comisión upfront', value: `${modelData.upfrontCommissionPercentage.toFixed(1)}%` },
                { label: 'Objetivo DSCR', value: `${(modelData.targetDSCR || 1.5).toFixed(2)}x` }
            ]
        },
        {
            title: 'Líneas de fondeo',
            items: [
                { label: 'Seed', value: formatCurrency(modelData.seed) },
                { label: 'Serie A', value: formatCurrency(modelData.seriesA) },
                { label: 'Venture disponible', value: formatCurrency(modelData.ventureDebtLineAvailable) },
                { label: 'Comercial disponible', value: formatCurrency(modelData.commercialDebtLineAvailable) },
                { label: 'Bridge disponible', value: formatCurrency(modelData.bridgeDebtLineAvailable) }
            ]
        },
        {
            title: 'Tasas deuda',
            items: [
                { label: 'Venture Debt', value: `${modelData.ventureDebtRate.toFixed(1)}%` },
                { label: 'Bridge', value: `${(modelData.bridgeDebtRate || 0).toFixed(1)}%` },
                { label: 'Comercial', value: `${modelData.commercialDebtRate.toFixed(1)}%` },
                { label: 'Costo equity (fallback)', value: `${modelData.costOfEquityManual.toFixed(1)}%` },
                { label: 'Gracia comercial', value: `${modelData.commercialGraceMonths} meses` },
                { label: 'Gracia bridge', value: `${modelData.bridgeGraceMonths} meses` }
            ]
        },
        {
            title: `Unidades plan ${scenario.name}`,
            items: scenario.units.map((units, idx) => ({ label: `Año ${idx + 1}`, value: `${units} unidades` }))
        }
    ];

    assumptionsContainer.innerHTML = assumptionsGroups.map(group => `
        <div class="p-4 bg-slate-900/70 border border-slate-800 rounded-xl">
            <h5 class="text-sm font-semibold text-white mb-3">${group.title}</h5>
            <dl class="space-y-1">
                ${group.items.map(item => `
                    <div class="flex justify-between gap-2 text-xs text-slate-300">
                        <dt>${item.label}</dt>
                        <dd class="font-semibold text-slate-100">${item.value}</dd>
                    </div>
                `).join('')}
            </dl>
        </div>
    `).join('');

    const totalUnits = financialResults.pl.reduce((sum, pl) => sum + (pl.addedUnits || 0), 0);
    const totalRevenue = financialResults.pl.reduce((sum, pl) => sum + (pl.totalRevenue || 0), 0);
    const fundingEfficiency = seriesAMetrics.fundingEfficiency || safeRatio(totalRevenue, totalFunding, 0);
    const capitalPerUnit = safeRatio(totalCapex, totalUnits, 0);
    const netInterestIncome = (year5PL.interestRevenue || 0) - (year5PL.interestExpense || 0);
    const avgEarningAssets = ((year4BS?.receivables || 0) + (year5BS?.receivables || 0)) / 2;
    const nimValue = safeRatio(netInterestIncome, avgEarningAssets, 0) * 100;
    const debtService = (year5PL.interestExpense || 0) + (year5CF.debtPrincipalRepayment || 0) + (year5CF.balloonPayment || 0);
    const dscrValue = safeRatio(year5PL.ebitda || 0, debtService, null);
    const terminalEV = (year5PL.ebitda || 0) * (modelData.ebitdaMultipleProject || 0);
    const netDebt = (year5BS.debt || 0) - (year5BS.cash || 0);
    const terminalEquity = terminalEV - netDebt;
    const bookFloor = (year5BS.equity || 0) * (modelData.floorEquityMultiple || 0);
    const terminalValue = Math.max(terminalEquity, bookFloor);

    const formulaCards = [
        {
            title: 'Cobertura CAPEX',
            formula: 'Total funding recibido / CAPEX requerido',
            result: `${(coverageRatio * 100).toFixed(1)}%`,
            detail: `Funding ${formatCurrency(totalFunding)} vs CAPEX ${formatCurrency(totalCapex)}.`
        },
        {
            title: 'Funding Efficiency',
            formula: 'Ingresos acumulados / Funding total',
            result: `${fundingEfficiency.toFixed(2)}x`,
            detail: `Ingresos ${formatCurrency(totalRevenue)} frente a funding ${formatCurrency(totalFunding)}.`
        },
        {
            title: 'Capital Efficiency',
            formula: 'CAPEX total / Unidades financiadas',
            result: capitalPerUnit > 0 ? `$${(capitalPerUnit/1000).toFixed(0)}K` : 'N/A',
            detail: `${totalUnits.toLocaleString()} unidades · CAPEX ${formatCurrency(totalCapex)}.`
        },
        {
            title: 'DSCR final',
            formula: 'EBITDA / (Intereses + Amortizaciones + Balloon)',
            result: dscrValue !== null ? `${dscrValue.toFixed(2)}x` : 'N/A',
            detail: `EBITDA ${formatCurrency(year5PL.ebitda || 0)} vs servicio ${formatCurrency(debtService)}.`
        },
        {
            title: 'NIM (Año 5)',
            formula: '(Ingresos por interés – costo fondeo) / Activos productivos promedio',
            result: `${nimValue.toFixed(1)}%`,
            detail: `NII ${formatCurrency(netInterestIncome)} sobre activos ${formatCurrency(avgEarningAssets)}.`
        },
        {
            title: 'TIR Equity',
            formula: 'Flujos de equity + valor terminal neto (EV – deuda neta)',
            result: `${financialResults.tirEquity.toFixed(1)}%`,
            detail: `Valor terminal ${formatCurrency(terminalValue)}.`
        }
    ];

    formulasContainer.innerHTML = formulaCards.map(card => `
        <div class="p-4 bg-slate-900/70 border border-slate-800 rounded-xl text-sm text-slate-200 space-y-2">
            <div class="flex items-center justify-between">
                <h5 class="font-semibold text-white">${card.title}</h5>
                <span class="text-lg font-bold text-sky-300">${card.result}</span>
            </div>
            <p class="text-xs text-slate-300">${card.formula}</p>
            <div class="text-xs text-slate-400">${card.detail}</div>
        </div>
    `).join('');

    if (downloadAssumptionsBtn) {
        downloadAssumptionsBtn.onclick = () => {
            const payload = {
                generatedAt: new Date().toISOString(),
                scenario: { key: currentScenario, name: scenario.name, units: scenario.units },
                credit: {
                    tasaInteres: modelData.tasaInteres,
                    downPaymentPercentage: modelData.downPaymentPercentage,
                    clientLoanTermYears: modelData.clientLoanTermYears,
                    upfrontCommissionPercentage: modelData.upfrontCommissionPercentage,
                    targetDSCR: modelData.targetDSCR
                },
                capital: {
                    seed: modelData.seed,
                    seriesA: modelData.seriesA,
                    ventureDebtLineAvailable: modelData.ventureDebtLineAvailable,
                    commercialDebtLineAvailable: modelData.commercialDebtLineAvailable,
                    bridgeDebtLineAvailable: modelData.bridgeDebtLineAvailable
                },
                debtRates: {
                    ventureDebtRate: modelData.ventureDebtRate,
                    bridgeDebtRate: modelData.bridgeDebtRate,
                    commercialDebtRate: modelData.commercialDebtRate,
                    commercialGraceMonths: modelData.commercialGraceMonths,
                    bridgeGraceMonths: modelData.bridgeGraceMonths,
                    costOfEquityFallback: modelData.costOfEquityManual
                },
                risk: {
                    pdStage1: modelData.pdStage1,
                    pdStage2: modelData.pdStage2,
                    pdStage3: modelData.pdStage3,
                    lgd: modelData.lgd
                }
            };
            downloadJSON(`supuestos_modelo_${scenario.name.toLowerCase()}_${currentScenario}.json`, payload);
        };
    }

    if (downloadResultsBtn) {
        downloadResultsBtn.onclick = () => {
            const cfAggregates = (financialResults.cf || []).reduce((acc, cf) => {
                acc.equity += Math.max(0, (cf.equityInjection || 0) + (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0));
                acc.bridge += Math.max(0, cf.bridgeFundingRaised || 0);
                acc.commercial += Math.max(0, cf.additionalFundingRaised || 0);
                acc.venture += Math.max(0, cf.currentYearVentureDebtDraw || 0);
                acc.sinosure += Math.max(0, cf.sinosureDrawn || 0);
                return acc;
            }, { equity: 0, bridge: 0, commercial: 0, venture: 0, sinosure: 0 });

            const snapshot = {
                generatedAt: new Date().toISOString(),
                scenario: { key: currentScenario, name: scenario.name, units: scenario.units },
                metrics: {
                    tirEquity: financialResults.tirEquity,
                    tirProyecto: financialResults.tirProyecto,
                    nimYear5: calculateSeriesAMetrics().netInterestMargin || 0,
                    dscrFinal: debtMetrics.finalDSCR,
                    leverage: leverage,
                    finalCash: finalCash,
                    worstCash: { year: cashHealth.worstYear, balance: cashHealth.worstBalance },
                    fundingMix: cfAggregates,
                    insurancePassThroughLiability: latestBS.insurancePassThroughLiability || 0
                }
            };

            downloadJSON(`snapshot_financiero_${scenario.name.toLowerCase()}_${currentScenario}.json`, snapshot);
        };
    }

    if (window.lucide && typeof window.lucide.createIcons === 'function') {
        window.lucide.createIcons();
    }
}

function downloadJSON(filename, data) {
    try {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        log(`📥 Archivo descargado: ${filename}`);
        pushActionLog('export', `JSON generado: ${filename}`);
    } catch (error) {
        log(`⚠️ Error al generar descarga: ${error.message}`);
    }
}

function storeScenarioSnapshot(snapshot) {
    if (!snapshot || snapshot.scenarioKey === undefined || snapshot.scenarioKey === null) return;
    scenarioSnapshots[snapshot.scenarioKey] = { ...snapshot };
    renderScenarioComparisonTable();
    if (Number(snapshot.scenarioKey) === Number(currentScenario)) {
        updateCovenantRadar(snapshot);
    }
    const tirText = isFinite(snapshot.tirEquity) ? `${snapshot.tirEquity.toFixed(1)}%` : 'N/A';
    const dscrText = isFinite(snapshot.dscr) ? `${snapshot.dscr.toFixed(2)}x` : 'N/A';
    const coverageText = isFinite(snapshot.coverage) ? `${(snapshot.coverage * 100).toFixed(1)}%` : 'N/A';
    pushActionLog('escenario', `${snapshot.scenarioName || 'Escenario'} · TIR ${tirText} · DSCR ${dscrText} · Cobertura ${coverageText}`);
}

function renderScenarioComparisonTable() {
    const container = document.getElementById('scenario-comparison-table');
    if (!container) return;
    const entries = Object.values(scenarioSnapshots);
    if (!entries.length) {
        container.innerHTML = '<div class="text-xs text-slate-400">Recalcula un escenario (Pesimista, Base, Optimista o Stress) para ver aquí la comparación.</div>';
        return;
    }

    entries.sort((a, b) => (a.displayOrder || 999) - (b.displayOrder || 999));

    const metrics = [
        { label: 'Unidades plan', format: s => s.plannedUnits !== undefined ? s.plannedUnits.toLocaleString('es-MX') : 'N/A' },
        { label: 'Unidades modeladas', format: s => s.totalUnits !== undefined ? s.totalUnits.toLocaleString('es-MX') : 'N/A' },
        { label: 'Cobertura CAPEX', format: s => isFinite(s.coverage) ? formatPercentage(s.coverage, 1) : 'N/A' },
        { label: 'TIR Equity', format: s => isFinite(s.tirEquity) ? `${s.tirEquity.toFixed(1)}%` : 'N/A' },
        { label: 'TIR Proyecto', format: s => isFinite(s.tirProyecto) ? `${s.tirProyecto.toFixed(1)}%` : 'N/A' },
        { label: 'DSCR final', format: s => isFinite(s.dscr) ? `${s.dscr.toFixed(2)}x` : 'N/A' },
        { label: 'Equity desplegado', format: s => formatCurrency(s.equityDeployed || 0) },
        { label: 'Deuda desplegada', format: s => formatCurrency(s.debtDeployed || 0) },
        { label: 'Cash final (Año 5)', format: s => formatCurrency(s.cashFinal || 0) },
        { label: 'Cash After Financing Y5', format: s => {
            const amount = s.cashAfterFinancingY5 || 0;
            const cls = amount < 0 ? 'text-rose-300 font-semibold' : 'text-emerald-300 font-semibold';
            return `<span class="${cls}">${formatCurrency(amount)}</span>`;
        } },
        { label: 'Worst Cash', format: s => {
            if (!s.worstCash) return 'N/A';
            const amount = s.worstCash.balance || 0;
            const yearText = s.worstCash.year ? `Año ${s.worstCash.year}` : 'Sin datos';
            const cls = amount < 0 ? 'text-rose-300 font-semibold' : 'text-emerald-300 font-semibold';
            return `<span class="${cls}">${yearText} · ${formatCurrency(amount)}</span>`;
        } },
        { label: 'NIM Y5', format: s => isFinite(s.nimY5) ? `${s.nimY5.toFixed(1)}%` : 'N/A' },
        { label: 'Último recálculo', format: s => s.updatedAt ? new Date(s.updatedAt).toLocaleString('es-MX', { hour12: false }) : 'N/A' }
    ];

    let tableHtml = '<table><thead><tr><th>Métrica</th>';
    entries.forEach(entry => {
        const isActive = Number(entry.scenarioKey) === Number(currentScenario);
        const subtitleParts = [];
        if (entry.totalUnits !== undefined) subtitleParts.push(`${entry.totalUnits.toLocaleString('es-MX')} u`);
        if (entry.plannedUnits !== undefined && entry.plannedUnits !== entry.totalUnits) {
            subtitleParts.push(`plan ${entry.plannedUnits.toLocaleString('es-MX')} u`);
        }
        const subtitle = subtitleParts.length ? `<div class="text-[10px] text-slate-400 font-normal">${subtitleParts.join(' · ')}</div>` : '';
        tableHtml += `<th class="${isActive ? 'active-scenario' : ''}">${entry.scenarioName}${subtitle}</th>`;
    });
    tableHtml += '</tr></thead><tbody>';

    metrics.forEach(row => {
        tableHtml += `<tr><td>${row.label}</td>`;
        entries.forEach(entry => {
            tableHtml += `<td>${row.format(entry)}</td>`;
        });
        tableHtml += '</tr>';
    });

    tableHtml += '</tbody></table>';
    container.innerHTML = tableHtml;
}

function updateCovenantRadar(snapshot) {
    const canvas = document.getElementById('covenantRadarChart');
    if (!canvas) return;

    const activeSnapshot = snapshot || scenarioSnapshots[currentScenario];
    if (!activeSnapshot) {
        if (charts.covenantRadar) {
            charts.covenantRadar.data.datasets[0].data = [0, 0, 0, 0, 0];
            charts.covenantRadar.update();
        }
        return;
    }

    const totalCapex = activeSnapshot.totalCapex !== undefined ? activeSnapshot.totalCapex : calculateTotalCapex();
    const totalFunding = activeSnapshot.totalFunding !== undefined ? activeSnapshot.totalFunding : totalFundingFromCF();
    const coverageRatio = safeRatio(totalFunding, totalCapex, 0);
    const dscrTarget = modelData.targetDSCR || 1.5;
    const dscrValue = isFinite(activeSnapshot.dscr) ? Math.max(0, Math.min((activeSnapshot.dscr / dscrTarget) * 100, 100)) : 0;
    const coverageValue = isFinite(activeSnapshot.coverage) ? Math.max(0, Math.min(activeSnapshot.coverage * 100, 100)) : Math.max(0, Math.min(coverageRatio * 100, 100));
    const leverageRaw = activeSnapshot.equityDeployed ? (activeSnapshot.debtDeployed || 0) / Math.max(activeSnapshot.equityDeployed, 1) : 0;
    const leverageTarget = 2.5;
    const leverageValue = leverageRaw > 0 ? Math.max(0, Math.min((leverageTarget / leverageRaw) * 100, 100)) : 100;
    const nimValue = isFinite(activeSnapshot.nimY5) ? Math.max(0, Math.min((activeSnapshot.nimY5 / 25) * 100, 100)) : 0;
    const liquidityValue = Math.max(0, Math.min(((activeSnapshot.cashFinal || 0) / Math.max(totalCapex * 0.05, 1)) * 100, 100));
    const data = [dscrValue, coverageValue, leverageValue, nimValue, liquidityValue];

    if (!charts.covenantRadar) {
        charts.covenantRadar = new Chart(canvas, {
            type: 'radar',
            data: {
                labels: ['DSCR', 'Cobertura', 'Leverage', 'NIM', 'Liquidez'],
                datasets: [
                    {
                        label: 'Salud',
                        data,
                        backgroundColor: 'rgba(56, 189, 248, 0.25)',
                        borderColor: '#38bdf8',
                        borderWidth: 2,
                        pointBackgroundColor: '#38bdf8'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    r: {
                        min: 0,
                        max: 100,
                        grid: { color: 'rgba(148, 163, 184, 0.2)' },
                        angleLines: { color: 'rgba(148, 163, 184, 0.2)' },
                        pointLabels: { color: '#e2e8f0', font: { size: 10 } },
                        ticks: {
                            stepSize: 20,
                            showLabelBackdrop: false,
                            color: '#94a3b8',
                            callback: value => `${value}%`
                        }
                    }
                },
                plugins: {
                    legend: { display: false }
                }
            }
        });
    } else {
        charts.covenantRadar.data.datasets[0].data = data;
        charts.covenantRadar.update();
    }
}

function pushActionLog(kind, message) {
    const entry = {
        kind,
        message,
        timestamp: new Date().toISOString()
    };
    actionLog.unshift(entry);
    if (actionLog.length > 15) actionLog.pop();
    renderChangeLog();
}

function renderChangeLog() {
    const container = document.getElementById('audit-change-log');
    if (!container) return;
    if (!actionLog.length) {
        container.innerHTML = '<li class="text-xs text-slate-500">Aún no hay acciones registradas. Recalcula o exporta para generar el historial.</li>';
        return;
    }
    container.innerHTML = actionLog.map(entry => {
        const badgeClass = entry.kind === 'export' ? 'log-badge log-export' : 'log-badge log-escenario';
        const time = new Date(entry.timestamp).toLocaleString('es-MX', { hour12: false });
        return `<li><span class="${badgeClass}">${entry.kind === 'export' ? 'Export' : 'Escenario'}</span><div class="flex-1"><p class="text-slate-200">${entry.message}</p><p class="text-[10px] text-slate-500">${time}</p></div></li>`;
    }).join('');
}

function downloadCSVFile(filename, csvContent) {
    try {
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        log(`📥 CSV exportado: ${filename}`);
        pushActionLog('export', `CSV generado: ${filename}`);
    } catch (error) {
        log(`⚠️ Error al generar CSV (${filename}): ${error.message}`);
    }
}

function tableToCSV(tableId) {
    const table = document.getElementById(tableId);
    if (!table) {
        log(`⚠️ Tabla no encontrada: ${tableId}`);
        return null;
    }
    const rows = Array.from(table.querySelectorAll('tr'));
    return rows.map(row => {
        const cells = Array.from(row.cells || []);
        return cells.map(cell => {
            const text = cell.innerText.replace(/\s+/g, ' ').trim().replace(/"/g, '""');
            return `"${text}"`;
        }).join(',');
    }).join('\n');
}

function downloadTableAsCSV(tableId, baseName) {
    const csv = tableToCSV(tableId);
    if (!csv) return;
    const scenarioDef = SCENARIO_DEFS[currentScenario] || { name: 'Escenario' };
    const slug = (scenarioDef.name || 'escenario').toLowerCase().replace(/[^a-z0-9]+/g, '_');
    downloadCSVFile(`${baseName}_${slug}.csv`, csv);
}

function exportCovenantsCSV() {
    const scenarioDef = SCENARIO_DEFS[currentScenario] || { name: 'Escenario' };
    const slug = (scenarioDef.name || 'escenario').toLowerCase().replace(/[^a-z0-9]+/g, '_');
    const snapshot = scenarioSnapshots[currentScenario];
    const coverage = snapshot && isFinite(snapshot.coverage) ? `${(snapshot.coverage * 100).toFixed(1)}%` : 'N/A';
    const dscr = snapshot && isFinite(snapshot.dscr) ? `${snapshot.dscr.toFixed(2)}x` : 'N/A';
    const tirEquity = snapshot && isFinite(snapshot.tirEquity) ? `${snapshot.tirEquity.toFixed(1)}%` : 'N/A';
    const tirProyecto = snapshot && isFinite(snapshot.tirProyecto) ? `${snapshot.tirProyecto.toFixed(1)}%` : 'N/A';
    const nim = snapshot && isFinite(snapshot.nimY5) ? `${snapshot.nimY5.toFixed(1)}%` : 'N/A';
    const rows = [
        ['Escenario', scenarioDef.name || 'Personalizado'],
        ['Unidades plan', snapshot && snapshot.plannedUnits !== undefined ? snapshot.plannedUnits.toLocaleString('es-MX') : 'N/A'],
        ['Unidades modeladas', snapshot && snapshot.totalUnits !== undefined ? snapshot.totalUnits.toLocaleString('es-MX') : 'N/A'],
        ['Cobertura CAPEX', coverage],
        ['TIR Equity', tirEquity],
        ['TIR Proyecto', tirProyecto],
        ['DSCR final', dscr],
        ['Equity desplegado', snapshot ? formatCurrency(snapshot.equityDeployed || 0, true) : 'N/A'],
        ['Deuda desplegada', snapshot ? formatCurrency(snapshot.debtDeployed || 0, true) : 'N/A'],
        ['Cash final (Año 5)', snapshot ? formatCurrency(snapshot.cashFinal || 0, true) : 'N/A'],
        ['NIM Y5', nim],
        ['Generado', new Date().toLocaleString('es-MX', { hour12: false })]
    ];
    const csv = rows.map(row => row.map(value => `"${String(value).replace(/"/g, '""')}"`).join(',')).join('\n');
    downloadCSVFile(`covenants_${slug}.csv`, csv);
}

function getPrintableTableHTML(table) {
    if (!table) return '<p>Datos no disponibles.</p>';
    const clone = table.cloneNode(true);
    clone.removeAttribute('id');
    clone.className = 'print-table';
    return clone.outerHTML;
}

function exportFinancialPDF() {
    const scenarioDef = SCENARIO_DEFS[currentScenario] || { name: 'Escenario' };
    const snapshot = scenarioSnapshots[currentScenario];
    const plTable = document.getElementById('pl-table');
    const cfTable = document.getElementById('cf-table');
    const bsTable = document.getElementById('bs-table');

    const summaryRows = [
        ['Escenario', scenarioDef.name || 'Personalizado'],
        ['Unidades modeladas', snapshot && snapshot.totalUnits !== undefined ? snapshot.totalUnits.toLocaleString('es-MX') : modelData.unitsPerYear.reduce((sum, val) => sum + (val || 0), 0).toLocaleString('es-MX')],
        ['Cobertura CAPEX', snapshot && isFinite(snapshot.coverage) ? `${(snapshot.coverage * 100).toFixed(1)}%` : 'N/A'],
        ['TIR Equity', snapshot && isFinite(snapshot.tirEquity) ? `${snapshot.tirEquity.toFixed(1)}%` : 'N/A'],
        ['TIR Proyecto', snapshot && isFinite(snapshot.tirProyecto) ? `${snapshot.tirProyecto.toFixed(1)}%` : 'N/A'],
        ['DSCR final', snapshot && isFinite(snapshot.dscr) ? `${snapshot.dscr.toFixed(2)}x` : 'N/A'],
        ['Equity desplegado', snapshot ? formatCurrency(snapshot.equityDeployed || 0, true) : 'N/A'],
        ['Deuda desplegada', snapshot ? formatCurrency(snapshot.debtDeployed || 0, true) : 'N/A'],
        ['Cash final (Año 5)', snapshot ? formatCurrency(snapshot.cashFinal || 0, true) : 'N/A'],
        ['Generado', new Date().toLocaleString('es-MX', { hour12: false })]
    ];

    const summaryTable = `<table class="summary-table">${summaryRows.map(row => `<tr><th>${row[0]}</th><td>${row[1]}</td></tr>`).join('')}</table>`;
    const html = `<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Reporte Financiero - ${scenarioDef.name || 'Escenario'}</title>
<style>
body { font-family: 'Inter', sans-serif; color: #0f172a; background: #fff; margin: 24px; }
h1 { font-size: 22px; margin-bottom: 12px; }
h2 { font-size: 16px; margin-top: 32px; margin-bottom: 8px; }
.summary-table, .print-table { width: 100%; border-collapse: collapse; margin-top: 12px; font-size: 12px; }
.summary-table th { text-align: left; background: #e2e8f0; padding: 6px 10px; border: 1px solid #cbd5e1; }
.summary-table td { padding: 6px 10px; border: 1px solid #cbd5e1; }
.print-table th, .print-table td { border: 1px solid #cbd5e1; padding: 6px 10px; text-align: right; }
.print-table th:first-child, .print-table td:first-child { text-align: left; }
.print-table th { background: #e2e8f0; }
</style>
</head>
<body>
<h1>Reporte Financiero – ${scenarioDef.name || 'Escenario'}</h1>
${summaryTable}
<h2>Estado de Resultados</h2>
${getPrintableTableHTML(plTable)}
<h2>Flujo de Efectivo</h2>
${getPrintableTableHTML(cfTable)}
<h2>Balance General</h2>
${getPrintableTableHTML(bsTable)}
</body>
</html>`;

    const printWindow = window.open('', '_blank', 'width=1024,height=768');
    if (!printWindow) {
        alert('No se pudo abrir la ventana de impresión. Permite los pop-ups para esta página.');
        return;
    }
    pushActionLog('export', 'Reporte PDF abierto para impresión');
    printWindow.document.write(html);
    printWindow.document.close();
    printWindow.focus();
    setTimeout(() => {
        try { printWindow.print(); }
        catch (err) { log(`⚠️ Error al intentar imprimir: ${err.message}`); }
    }, 400);
}

function setupExportButtons() {
    const bindings = [
        { id: 'export-pl-csv-btn', action: () => downloadTableAsCSV('pl-table', 'estado_resultados') },
        { id: 'export-cf-csv-btn', action: () => downloadTableAsCSV('cf-table', 'flujo_efectivo') },
        { id: 'export-bs-csv-btn', action: () => downloadTableAsCSV('bs-table', 'balance_general') },
        { id: 'export-covenants-csv-btn', action: exportCovenantsCSV },
        { id: 'export-pdf-btn', action: exportFinancialPDF }
    ];
    bindings.forEach(binding => {
        const btn = document.getElementById(binding.id);
        if (btn) {
            btn.addEventListener('click', binding.action);
        }
    });
}

function setupMetricPopovers() {
    if (!metricPopoverEl) {
        metricPopoverEl = document.createElement('div');
        metricPopoverEl.className = 'metric-popover';
        metricPopoverEl.setAttribute('role', 'dialog');
        metricPopoverEl.setAttribute('aria-live', 'polite');
        metricPopoverEl.addEventListener('click', event => event.stopPropagation());
        document.body.appendChild(metricPopoverEl);
    }

    document.querySelectorAll('.metric-explain-btn').forEach(button => {
        button.addEventListener('click', event => {
            event.stopPropagation();
            const content = button.getAttribute('data-content') || 'Calcula el modelo para ver esta fórmula con números actuales.';
            toggleMetricPopover(button, content);
        });
    });

    document.addEventListener('click', hideMetricPopover);
    window.addEventListener('resize', hideMetricPopover);
}

function toggleMetricPopover(anchor, content) {
    if (!metricPopoverEl) return;
    if (metricPopoverAnchor === anchor && metricPopoverEl.classList.contains('visible')) {
        hideMetricPopover();
        return;
    }

    metricPopoverAnchor = anchor;
    metricPopoverEl.innerHTML = content;
    metricPopoverEl.classList.add('visible');
    positionMetricPopover(anchor);
}

function positionMetricPopover(anchor) {
    if (!metricPopoverEl) return;
    metricPopoverEl.style.visibility = 'hidden';
    metricPopoverEl.style.display = 'block';

    const rect = anchor.getBoundingClientRect();
    const padding = 12;
    const popWidth = metricPopoverEl.offsetWidth;
    const popHeight = metricPopoverEl.offsetHeight;

    let left = rect.right + 16 + window.scrollX;
    if (left + popWidth > window.scrollX + window.innerWidth - padding) {
        left = rect.left + window.scrollX - popWidth - 16;
    }
    if (left < padding) left = padding;

    let top = rect.top + window.scrollY + rect.height / 2 - popHeight / 2;
    if (top + popHeight > window.scrollY + window.innerHeight - padding) {
        top = window.scrollY + window.innerHeight - popHeight - padding;
    }
    if (top < window.scrollY + padding) {
        top = window.scrollY + padding;
    }

    metricPopoverEl.style.left = `${left}px`;
    metricPopoverEl.style.top = `${top}px`;
    metricPopoverEl.style.visibility = 'visible';
}

function hideMetricPopover() {
    if (metricPopoverEl) {
        metricPopoverEl.classList.remove('visible');
        metricPopoverEl.style.display = 'none';
        metricPopoverEl.style.visibility = 'hidden';
    }
    metricPopoverAnchor = null;
}

function updateMetricExplanations() {
    const nimBtn = document.querySelector('.metric-explain-btn[data-metric="nim"]');
    const tirBtn = document.querySelector('.metric-explain-btn[data-metric="tir"]');
    const dscrBtn = document.querySelector('.metric-explain-btn[data-metric="dscr"]');
    const defaultMessage = 'Calcula el modelo para ver esta fórmula con números actuales.';

    if (!financialResults || !Array.isArray(financialResults.pl) || financialResults.pl.length < 5 || !Array.isArray(financialResults.bs) || financialResults.bs.length < 2) {
        if (nimBtn) nimBtn.setAttribute('data-content', defaultMessage);
        if (tirBtn) tirBtn.setAttribute('data-content', defaultMessage);
        if (dscrBtn) dscrBtn.setAttribute('data-content', defaultMessage);
        return;
    }

    const year5PL = financialResults.pl[4] || {};
    const year5BS = financialResults.bs[4] || {};
    const year4BS = financialResults.bs[3] || {};
    const year5CF = financialResults.cf?.[4] || {};
    const seriesAMetrics = calculateSeriesAMetrics();

    if (nimBtn) {
        const interestRevenue = year5PL.interestRevenue || 0;
        const interestExpense = year5PL.interestExpense || 0;
        const netInterestIncome = interestRevenue - interestExpense;
        const avgAssets = ((year4BS.receivables || 0) + (year5BS.receivables || 0)) / 2;
        const nimValue = seriesAMetrics.netInterestMargin || 0;
        nimBtn.setAttribute('data-content', `
            <strong>NIM</strong> = (Ingresos por intereses - Costo de fondeo) / Activos productivos promedio
            <hr>
            (${formatCurrency(interestRevenue)} - ${formatCurrency(interestExpense)}) / ${formatCurrency(avgAssets)} = ${nimValue.toFixed(1)}%
        `);
    }

    if (dscrBtn) {
        const ebitda = year5PL.ebitda || 0;
        const debtService = (year5PL.interestExpense || 0) + (year5CF.debtPrincipalRepayment || 0) + (year5CF.balloonPayment || 0);
        const dscrValue = safeRatio(ebitda, debtService, null);
        const dscrText = dscrValue !== null ? `${dscrValue.toFixed(2)}x` : 'N/A';
        dscrBtn.setAttribute('data-content', `
            <strong>DSCR</strong> = EBITDA / (Intereses + Amortizaciones + Balloon)
            <hr>
            ${formatCurrency(ebitda)} / ${formatCurrency(debtService)} = ${dscrText}
        `);
    }

    if (tirBtn) {
        const terminalEV = (year5PL.ebitda || 0) * (modelData.ebitdaMultipleProject || 0);
        const netDebt = (year5BS.debt || 0) - (year5BS.cash || 0);
        const terminalEquityValue = terminalEV - netDebt;
        const bookFloor = (year5BS.equity || 0) * (modelData.floorEquityMultiple || 0);
        const terminalValue = Math.max(terminalEquityValue, bookFloor);
        const equityDeploy = (modelData.seed || 0) + (modelData.seriesA || 0) + (financialResults.cf || []).reduce((sum, cf) => {
            return sum + Math.max(0, (cf.equityInjection || 0) + (cf.partnerCapitalization || 0) + (cf.seriesBNewInvestors || 0));
        }, 0);
        tirBtn.setAttribute('data-content', `
            <strong>TIR Equity</strong> = tasa que hace NPV=0 con los flujos del accionista.
            <hr>
            Desembolsos Equity: ${formatCurrency(equityDeploy)}<br>
            Valor terminal neto (EV - Deuda neta): ${formatCurrency(terminalValue)}<br>
            Resultado: ${financialResults.tirEquity.toFixed(1)}%
        `);
    }
}

// ===== APPLICATION READY AND RUNNING =====
/**
* Runs when the DOM is fully loaded.
* Process: Initializes the UI, configures controls, performs initial calculation, and updates UI and charts.
*/
document.addEventListener('DOMContentLoaded', function() {
log('🚀 STARTING FINANCIAL MODEL APPLICATION');

try {
setupTabs();
setupControls();
setupMetricPopovers();
renderScenarioComparisonTable();
setupExportButtons();
updateCovenantRadar();
renderChangeLog();
setupScenarioListeners(); // ADD SCENARIO LISTENERS
setupInvestorTab();
updateFinancialModeUI();
const resetBtn = document.getElementById('reset-base-btn');
if (resetBtn) {
    resetBtn.addEventListener('click', () => window.applyGrowthScenario(500));
}
const dataRoomBtn = document.getElementById('toggle-data-room');
if (dataRoomBtn) {
    dataRoomBtn.addEventListener('click', () => toggleDataRoomMode());
}
const closeDataRoomBtn = document.getElementById('close-data-room');
if (closeDataRoomBtn) {
    closeDataRoomBtn.addEventListener('click', () => toggleDataRoomMode(true));
}

// ===== STEP 6: INITIALIZE CONSTRAINT SYSTEM (SAFE STARTUP) =====
setTimeout(() => {
    try {
        createConstraintDashboard();
        log('✅ Constraint dashboard created');
        // Bind toggle after dashboard is added
        const btn = document.getElementById('toggle-mode-btn');
        if (btn) {
            btn.addEventListener('click', toggleMode);
            btn.textContent = currentMode === 'growth' ? 'Growth Mode' : 'Steady-State Mode';
        }
    } catch (error) {
        log(`⚠️ Constraint dashboard creation failed: ${error.message}`);
    }
}, 400);

// --- UI calls re-enabled ---
log('✅ UI updates enabled.');

// SET DEFAULT TO BASE SCENARIO
setTimeout(() => {
    window.applyGrowthScenario(currentScenario);
}, 300);

setTimeout(() => {
initializeCharts();
updateCharts();

// INITIALIZE CONSTRAINT SYSTEM AFTER EVERYTHING IS LOADED
try {
    updateConstraintDashboard();
    updateProtectedCapitalMotor();
    enhanceUnitInputsWithConstraints();
    log('✅ Constraint system fully initialized');
} catch (error) {
    log(`⚠️ Constraint system initialization failed: ${error.message}`);
}
}, 700);

log('🎉 APPLICATION READY AND RUNNING WITH CONSTRAINTS');

} catch (error) {
log(`❌ CRITICAL ERROR DURING INITIALIZATION: ${error.message}`);
console.log('Emergency rollback available: emergencyRollback()');
}
});

</script>
<footer class="mt-10 text-center text-xs text-slate-500">
    Documento confidencial · Uso exclusivo para procesos de due diligence y comités de inversión. No distribuir sin autorización de Conductores del Mundo.
</footer>
</body>
</html>
